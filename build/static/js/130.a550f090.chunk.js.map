{"version":3,"file":"static/js/130.a550f090.chunk.js","mappings":"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","sources":["../node_modules/@mui/material/CardContent/cardContentClasses.js","../node_modules/@mui/material/CardContent/CardContent.js","../node_modules/@mui/material/Card/cardClasses.js","../node_modules/@mui/material/Card/Card.js","../node_modules/@mui/material/Divider/Divider.js","../node_modules/@mui/material/ListItemAvatar/listItemAvatarClasses.js","../node_modules/@mui/material/ListItemAvatar/ListItemAvatar.js","../node_modules/@mui/material/ListItem/listItemClasses.js","../node_modules/@mui/material/ListItemSecondaryAction/listItemSecondaryActionClasses.js","../node_modules/@mui/material/ListItemSecondaryAction/ListItemSecondaryAction.js","../node_modules/@mui/material/ListItem/ListItem.js","../node_modules/@kurkle/color/dist/color.esm.js","../node_modules/chart.js/src/helpers/helpers.core.ts","../node_modules/chart.js/src/helpers/helpers.math.ts","../node_modules/chart.js/src/helpers/helpers.collection.ts","../node_modules/chart.js/src/helpers/helpers.extras.ts","../node_modules/chart.js/src/helpers/helpers.easing.ts","../node_modules/chart.js/src/helpers/helpers.color.ts","../node_modules/chart.js/src/core/core.animations.defaults.js","../node_modules/chart.js/src/helpers/helpers.intl.ts","../node_modules/chart.js/src/core/core.ticks.js","../node_modules/chart.js/src/core/core.defaults.js","../node_modules/chart.js/src/core/core.layouts.defaults.js","../node_modules/chart.js/src/core/core.scale.defaults.js","../node_modules/chart.js/src/helpers/helpers.canvas.ts","../node_modules/chart.js/src/helpers/helpers.options.ts","../node_modules/chart.js/src/helpers/helpers.config.ts","../node_modules/chart.js/src/helpers/helpers.curve.ts","../node_modules/chart.js/src/helpers/helpers.dom.ts","../node_modules/chart.js/src/helpers/helpers.interpolation.ts","../node_modules/chart.js/src/helpers/helpers.rtl.ts","../node_modules/chart.js/src/helpers/helpers.segment.js","../node_modules/chart.js/src/core/core.animator.js","../node_modules/chart.js/src/core/core.animation.js","../node_modules/chart.js/src/core/core.animations.js","../node_modules/chart.js/src/core/core.datasetController.js","../node_modules/chart.js/src/controllers/controller.bar.js","../node_modules/chart.js/src/controllers/controller.bubble.js","../node_modules/chart.js/src/controllers/controller.doughnut.js","../node_modules/chart.js/src/controllers/controller.line.js","../node_modules/chart.js/src/controllers/controller.polarArea.js","../node_modules/chart.js/src/controllers/controller.pie.js","../node_modules/chart.js/src/controllers/controller.radar.js","../node_modules/chart.js/src/controllers/controller.scatter.js","../node_modules/chart.js/src/core/core.adapters.ts","../node_modules/chart.js/src/core/core.interaction.js","../node_modules/chart.js/src/core/core.layouts.js","../node_modules/chart.js/src/platform/platform.base.js","../node_modules/chart.js/src/platform/platform.basic.js","../node_modules/chart.js/src/platform/platform.dom.js","../node_modules/chart.js/src/core/core.element.ts","../node_modules/chart.js/src/core/core.scale.autoskip.js","../node_modules/chart.js/src/core/core.scale.js","../node_modules/chart.js/src/core/core.typedRegistry.js","../node_modules/chart.js/src/core/core.registry.js","../node_modules/chart.js/src/core/core.plugins.js","../node_modules/chart.js/src/core/core.config.js","../node_modules/chart.js/src/core/core.controller.js","../node_modules/chart.js/src/platform/index.js","../node_modules/chart.js/src/elements/element.arc.ts","../node_modules/chart.js/src/elements/element.line.js","../node_modules/chart.js/src/elements/element.point.ts","../node_modules/chart.js/src/elements/element.bar.js","../node_modules/chart.js/src/plugins/plugin.legend.js","../node_modules/chart.js/src/plugins/plugin.title.js","../node_modules/chart.js/src/plugins/plugin.subtitle.js","../node_modules/chart.js/src/plugins/plugin.tooltip.js","../node_modules/chart.js/src/scales/scale.category.js","../node_modules/chart.js/src/scales/scale.linearbase.js","../node_modules/chart.js/src/scales/scale.linear.js","../node_modules/chart.js/src/scales/scale.logarithmic.js","../node_modules/chart.js/src/scales/scale.radialLinear.js","../node_modules/chart.js/src/scales/scale.time.js","../node_modules/chart.js/src/scales/scale.timeseries.js","../node_modules/react-chartjs-2/src/utils.ts","../node_modules/react-chartjs-2/src/chart.tsx","../node_modules/react-chartjs-2/src/typedCharts.tsx"],"sourcesContent":["import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCardContentUtilityClass(slot) {\n  return generateUtilityClass('MuiCardContent', slot);\n}\nconst cardContentClasses = generateUtilityClasses('MuiCardContent', ['root']);\nexport default cardContentClasses;","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"className\", \"component\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { unstable_composeClasses as composeClasses } from '@mui/base/composeClasses';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport { getCardContentUtilityClass } from './cardContentClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getCardContentUtilityClass, classes);\n};\nconst CardContentRoot = styled('div', {\n  name: 'MuiCardContent',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})(() => {\n  return {\n    padding: 16,\n    '&:last-child': {\n      paddingBottom: 24\n    }\n  };\n});\nconst CardContent = /*#__PURE__*/React.forwardRef(function CardContent(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiCardContent'\n  });\n  const {\n      className,\n      component = 'div'\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const ownerState = _extends({}, props, {\n    component\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CardContentRoot, _extends({\n    as: component,\n    className: clsx(classes.root, className),\n    ownerState: ownerState,\n    ref: ref\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? CardContent.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default CardContent;","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getCardUtilityClass(slot) {\n  return generateUtilityClass('MuiCard', slot);\n}\nconst cardClasses = generateUtilityClasses('MuiCard', ['root']);\nexport default cardClasses;","'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"className\", \"raised\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { chainPropTypes } from '@mui/utils';\nimport { unstable_composeClasses as composeClasses } from '@mui/base/composeClasses';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport Paper from '../Paper';\nimport { getCardUtilityClass } from './cardClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getCardUtilityClass, classes);\n};\nconst CardRoot = styled(Paper, {\n  name: 'MuiCard',\n  slot: 'Root',\n  overridesResolver: (props, styles) => styles.root\n})(() => {\n  return {\n    overflow: 'hidden'\n  };\n});\nconst Card = /*#__PURE__*/React.forwardRef(function Card(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiCard'\n  });\n  const {\n      className,\n      raised = false\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const ownerState = _extends({}, props, {\n    raised\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(CardRoot, _extends({\n    className: clsx(classes.root, className),\n    elevation: raised ? 8 : undefined,\n    ref: ref,\n    ownerState: ownerState\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? Card.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * If `true`, the card will use raised styling.\n   * @default false\n   */\n  raised: chainPropTypes(PropTypes.bool, props => {\n    if (props.raised && props.variant === 'outlined') {\n      return new Error('MUI: Combining `raised={true}` with `variant=\"outlined\"` has no effect.');\n    }\n    return null;\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default Card;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"absolute\", \"children\", \"className\", \"component\", \"flexItem\", \"light\", \"orientation\", \"role\", \"textAlign\", \"variant\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { unstable_composeClasses as composeClasses } from '@mui/base/composeClasses';\nimport { alpha } from '@mui/system';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport { getDividerUtilityClass } from './dividerClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    absolute,\n    children,\n    classes,\n    flexItem,\n    light,\n    orientation,\n    textAlign,\n    variant\n  } = ownerState;\n  const slots = {\n    root: ['root', absolute && 'absolute', variant, light && 'light', orientation === 'vertical' && 'vertical', flexItem && 'flexItem', children && 'withChildren', children && orientation === 'vertical' && 'withChildrenVertical', textAlign === 'right' && orientation !== 'vertical' && 'textAlignRight', textAlign === 'left' && orientation !== 'vertical' && 'textAlignLeft'],\n    wrapper: ['wrapper', orientation === 'vertical' && 'wrapperVertical']\n  };\n  return composeClasses(slots, getDividerUtilityClass, classes);\n};\nconst DividerRoot = styled('div', {\n  name: 'MuiDivider',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, ownerState.absolute && styles.absolute, styles[ownerState.variant], ownerState.light && styles.light, ownerState.orientation === 'vertical' && styles.vertical, ownerState.flexItem && styles.flexItem, ownerState.children && styles.withChildren, ownerState.children && ownerState.orientation === 'vertical' && styles.withChildrenVertical, ownerState.textAlign === 'right' && ownerState.orientation !== 'vertical' && styles.textAlignRight, ownerState.textAlign === 'left' && ownerState.orientation !== 'vertical' && styles.textAlignLeft];\n  }\n})(({\n  theme,\n  ownerState\n}) => _extends({\n  margin: 0,\n  // Reset browser default style.\n  flexShrink: 0,\n  borderWidth: 0,\n  borderStyle: 'solid',\n  borderColor: (theme.vars || theme).palette.divider,\n  borderBottomWidth: 'thin'\n}, ownerState.absolute && {\n  position: 'absolute',\n  bottom: 0,\n  left: 0,\n  width: '100%'\n}, ownerState.light && {\n  borderColor: theme.vars ? `rgba(${theme.vars.palette.dividerChannel} / 0.08)` : alpha(theme.palette.divider, 0.08)\n}, ownerState.variant === 'inset' && {\n  marginLeft: 72\n}, ownerState.variant === 'middle' && ownerState.orientation === 'horizontal' && {\n  marginLeft: theme.spacing(2),\n  marginRight: theme.spacing(2)\n}, ownerState.variant === 'middle' && ownerState.orientation === 'vertical' && {\n  marginTop: theme.spacing(1),\n  marginBottom: theme.spacing(1)\n}, ownerState.orientation === 'vertical' && {\n  height: '100%',\n  borderBottomWidth: 0,\n  borderRightWidth: 'thin'\n}, ownerState.flexItem && {\n  alignSelf: 'stretch',\n  height: 'auto'\n}), ({\n  ownerState\n}) => _extends({}, ownerState.children && {\n  display: 'flex',\n  whiteSpace: 'nowrap',\n  textAlign: 'center',\n  border: 0,\n  '&::before, &::after': {\n    content: '\"\"',\n    alignSelf: 'center'\n  }\n}), ({\n  theme,\n  ownerState\n}) => _extends({}, ownerState.children && ownerState.orientation !== 'vertical' && {\n  '&::before, &::after': {\n    width: '100%',\n    borderTop: `thin solid ${(theme.vars || theme).palette.divider}`\n  }\n}), ({\n  theme,\n  ownerState\n}) => _extends({}, ownerState.children && ownerState.orientation === 'vertical' && {\n  flexDirection: 'column',\n  '&::before, &::after': {\n    height: '100%',\n    borderLeft: `thin solid ${(theme.vars || theme).palette.divider}`\n  }\n}), ({\n  ownerState\n}) => _extends({}, ownerState.textAlign === 'right' && ownerState.orientation !== 'vertical' && {\n  '&::before': {\n    width: '90%'\n  },\n  '&::after': {\n    width: '10%'\n  }\n}, ownerState.textAlign === 'left' && ownerState.orientation !== 'vertical' && {\n  '&::before': {\n    width: '10%'\n  },\n  '&::after': {\n    width: '90%'\n  }\n}));\nconst DividerWrapper = styled('span', {\n  name: 'MuiDivider',\n  slot: 'Wrapper',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.wrapper, ownerState.orientation === 'vertical' && styles.wrapperVertical];\n  }\n})(({\n  theme,\n  ownerState\n}) => _extends({\n  display: 'inline-block',\n  paddingLeft: `calc(${theme.spacing(1)} * 1.2)`,\n  paddingRight: `calc(${theme.spacing(1)} * 1.2)`\n}, ownerState.orientation === 'vertical' && {\n  paddingTop: `calc(${theme.spacing(1)} * 1.2)`,\n  paddingBottom: `calc(${theme.spacing(1)} * 1.2)`\n}));\nconst Divider = /*#__PURE__*/React.forwardRef(function Divider(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiDivider'\n  });\n  const {\n      absolute = false,\n      children,\n      className,\n      component = children ? 'div' : 'hr',\n      flexItem = false,\n      light = false,\n      orientation = 'horizontal',\n      role = component !== 'hr' ? 'separator' : undefined,\n      textAlign = 'center',\n      variant = 'fullWidth'\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const ownerState = _extends({}, props, {\n    absolute,\n    component,\n    flexItem,\n    light,\n    orientation,\n    role,\n    textAlign,\n    variant\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(DividerRoot, _extends({\n    as: component,\n    className: clsx(classes.root, className),\n    role: role,\n    ref: ref,\n    ownerState: ownerState\n  }, other, {\n    children: children ? /*#__PURE__*/_jsx(DividerWrapper, {\n      className: classes.wrapper,\n      ownerState: ownerState,\n      children: children\n    }) : null\n  }));\n});\n\n/**\n * The following flag is used to ensure that this component isn't tabbable i.e.\n * does not get highlight/focus inside of MUI List.\n */\nDivider.muiSkipListHighlight = true;\nprocess.env.NODE_ENV !== \"production\" ? Divider.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * Absolutely position the element.\n   * @default false\n   */\n  absolute: PropTypes.bool,\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * If `true`, a vertical divider will have the correct height when used in flex container.\n   * (By default, a vertical divider will have a calculated height of `0px` if it is the child of a flex container.)\n   * @default false\n   */\n  flexItem: PropTypes.bool,\n  /**\n   * If `true`, the divider will have a lighter color.\n   * @default false\n   */\n  light: PropTypes.bool,\n  /**\n   * The component orientation.\n   * @default 'horizontal'\n   */\n  orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n  /**\n   * @ignore\n   */\n  role: PropTypes /* @typescript-to-proptypes-ignore */.string,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The text alignment.\n   * @default 'center'\n   */\n  textAlign: PropTypes.oneOf(['center', 'left', 'right']),\n  /**\n   * The variant to use.\n   * @default 'fullWidth'\n   */\n  variant: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['fullWidth', 'inset', 'middle']), PropTypes.string])\n} : void 0;\nexport default Divider;","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getListItemAvatarUtilityClass(slot) {\n  return generateUtilityClass('MuiListItemAvatar', slot);\n}\nconst listItemAvatarClasses = generateUtilityClasses('MuiListItemAvatar', ['root', 'alignItemsFlexStart']);\nexport default listItemAvatarClasses;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"className\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { unstable_composeClasses as composeClasses } from '@mui/base/composeClasses';\nimport ListContext from '../List/ListContext';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport { getListItemAvatarUtilityClass } from './listItemAvatarClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    alignItems,\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root', alignItems === 'flex-start' && 'alignItemsFlexStart']\n  };\n  return composeClasses(slots, getListItemAvatarUtilityClass, classes);\n};\nconst ListItemAvatarRoot = styled('div', {\n  name: 'MuiListItemAvatar',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, ownerState.alignItems === 'flex-start' && styles.alignItemsFlexStart];\n  }\n})(({\n  ownerState\n}) => _extends({\n  minWidth: 56,\n  flexShrink: 0\n}, ownerState.alignItems === 'flex-start' && {\n  marginTop: 8\n}));\n\n/**\n * A simple wrapper to apply `List` styles to an `Avatar`.\n */\nconst ListItemAvatar = /*#__PURE__*/React.forwardRef(function ListItemAvatar(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiListItemAvatar'\n  });\n  const {\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const context = React.useContext(ListContext);\n  const ownerState = _extends({}, props, {\n    alignItems: context.alignItems\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(ListItemAvatarRoot, _extends({\n    className: clsx(classes.root, className),\n    ownerState: ownerState,\n    ref: ref\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? ListItemAvatar.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * The content of the component, normally an `Avatar`.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default ListItemAvatar;","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getListItemUtilityClass(slot) {\n  return generateUtilityClass('MuiListItem', slot);\n}\nconst listItemClasses = generateUtilityClasses('MuiListItem', ['root', 'container', 'focusVisible', 'dense', 'alignItemsFlexStart', 'disabled', 'divider', 'gutters', 'padding', 'button', 'secondaryAction', 'selected']);\nexport default listItemClasses;","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getListItemSecondaryActionClassesUtilityClass(slot) {\n  return generateUtilityClass('MuiListItemSecondaryAction', slot);\n}\nconst listItemSecondaryActionClasses = generateUtilityClasses('MuiListItemSecondaryAction', ['root', 'disableGutters']);\nexport default listItemSecondaryActionClasses;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"className\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { unstable_composeClasses as composeClasses } from '@mui/base/composeClasses';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport ListContext from '../List/ListContext';\nimport { getListItemSecondaryActionClassesUtilityClass } from './listItemSecondaryActionClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    disableGutters,\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root', disableGutters && 'disableGutters']\n  };\n  return composeClasses(slots, getListItemSecondaryActionClassesUtilityClass, classes);\n};\nconst ListItemSecondaryActionRoot = styled('div', {\n  name: 'MuiListItemSecondaryAction',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, ownerState.disableGutters && styles.disableGutters];\n  }\n})(({\n  ownerState\n}) => _extends({\n  position: 'absolute',\n  right: 16,\n  top: '50%',\n  transform: 'translateY(-50%)'\n}, ownerState.disableGutters && {\n  right: 0\n}));\n\n/**\n * Must be used as the last child of ListItem to function properly.\n */\nconst ListItemSecondaryAction = /*#__PURE__*/React.forwardRef(function ListItemSecondaryAction(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiListItemSecondaryAction'\n  });\n  const {\n      className\n    } = props,\n    other = _objectWithoutPropertiesLoose(props, _excluded);\n  const context = React.useContext(ListContext);\n  const ownerState = _extends({}, props, {\n    disableGutters: context.disableGutters\n  });\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(ListItemSecondaryActionRoot, _extends({\n    className: clsx(classes.root, className),\n    ownerState: ownerState,\n    ref: ref\n  }, other));\n});\nprocess.env.NODE_ENV !== \"production\" ? ListItemSecondaryAction.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * The content of the component, normally an `IconButton` or selection control.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nListItemSecondaryAction.muiName = 'ListItemSecondaryAction';\nexport default ListItemSecondaryAction;","'use client';\n\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst _excluded = [\"className\"],\n  _excluded2 = [\"alignItems\", \"autoFocus\", \"button\", \"children\", \"className\", \"component\", \"components\", \"componentsProps\", \"ContainerComponent\", \"ContainerProps\", \"dense\", \"disabled\", \"disableGutters\", \"disablePadding\", \"divider\", \"focusVisibleClassName\", \"secondaryAction\", \"selected\", \"slotProps\", \"slots\"];\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport { unstable_composeClasses as composeClasses, isHostComponent } from '@mui/base';\nimport { chainPropTypes, elementTypeAcceptingRef } from '@mui/utils';\nimport { alpha } from '@mui/system';\nimport styled from '../styles/styled';\nimport useThemeProps from '../styles/useThemeProps';\nimport ButtonBase from '../ButtonBase';\nimport isMuiElement from '../utils/isMuiElement';\nimport useEnhancedEffect from '../utils/useEnhancedEffect';\nimport useForkRef from '../utils/useForkRef';\nimport ListContext from '../List/ListContext';\nimport listItemClasses, { getListItemUtilityClass } from './listItemClasses';\nimport { listItemButtonClasses } from '../ListItemButton';\nimport ListItemSecondaryAction from '../ListItemSecondaryAction';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nimport { jsxs as _jsxs } from \"react/jsx-runtime\";\nexport const overridesResolver = (props, styles) => {\n  const {\n    ownerState\n  } = props;\n  return [styles.root, ownerState.dense && styles.dense, ownerState.alignItems === 'flex-start' && styles.alignItemsFlexStart, ownerState.divider && styles.divider, !ownerState.disableGutters && styles.gutters, !ownerState.disablePadding && styles.padding, ownerState.button && styles.button, ownerState.hasSecondaryAction && styles.secondaryAction];\n};\nconst useUtilityClasses = ownerState => {\n  const {\n    alignItems,\n    button,\n    classes,\n    dense,\n    disabled,\n    disableGutters,\n    disablePadding,\n    divider,\n    hasSecondaryAction,\n    selected\n  } = ownerState;\n  const slots = {\n    root: ['root', dense && 'dense', !disableGutters && 'gutters', !disablePadding && 'padding', divider && 'divider', disabled && 'disabled', button && 'button', alignItems === 'flex-start' && 'alignItemsFlexStart', hasSecondaryAction && 'secondaryAction', selected && 'selected'],\n    container: ['container']\n  };\n  return composeClasses(slots, getListItemUtilityClass, classes);\n};\nexport const ListItemRoot = styled('div', {\n  name: 'MuiListItem',\n  slot: 'Root',\n  overridesResolver\n})(({\n  theme,\n  ownerState\n}) => _extends({\n  display: 'flex',\n  justifyContent: 'flex-start',\n  alignItems: 'center',\n  position: 'relative',\n  textDecoration: 'none',\n  width: '100%',\n  boxSizing: 'border-box',\n  textAlign: 'left'\n}, !ownerState.disablePadding && _extends({\n  paddingTop: 8,\n  paddingBottom: 8\n}, ownerState.dense && {\n  paddingTop: 4,\n  paddingBottom: 4\n}, !ownerState.disableGutters && {\n  paddingLeft: 16,\n  paddingRight: 16\n}, !!ownerState.secondaryAction && {\n  // Add some space to avoid collision as `ListItemSecondaryAction`\n  // is absolutely positioned.\n  paddingRight: 48\n}), !!ownerState.secondaryAction && {\n  [`& > .${listItemButtonClasses.root}`]: {\n    paddingRight: 48\n  }\n}, {\n  [`&.${listItemClasses.focusVisible}`]: {\n    backgroundColor: (theme.vars || theme).palette.action.focus\n  },\n  [`&.${listItemClasses.selected}`]: {\n    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity),\n    [`&.${listItemClasses.focusVisible}`]: {\n      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)\n    }\n  },\n  [`&.${listItemClasses.disabled}`]: {\n    opacity: (theme.vars || theme).palette.action.disabledOpacity\n  }\n}, ownerState.alignItems === 'flex-start' && {\n  alignItems: 'flex-start'\n}, ownerState.divider && {\n  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,\n  backgroundClip: 'padding-box'\n}, ownerState.button && {\n  transition: theme.transitions.create('background-color', {\n    duration: theme.transitions.duration.shortest\n  }),\n  '&:hover': {\n    textDecoration: 'none',\n    backgroundColor: (theme.vars || theme).palette.action.hover,\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: 'transparent'\n    }\n  },\n  [`&.${listItemClasses.selected}:hover`]: {\n    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha(theme.palette.primary.main, theme.palette.action.selectedOpacity)\n    }\n  }\n}, ownerState.hasSecondaryAction && {\n  // Add some space to avoid collision as `ListItemSecondaryAction`\n  // is absolutely positioned.\n  paddingRight: 48\n}));\nconst ListItemContainer = styled('li', {\n  name: 'MuiListItem',\n  slot: 'Container',\n  overridesResolver: (props, styles) => styles.container\n})({\n  position: 'relative'\n});\n\n/**\n * Uses an additional container component if `ListItemSecondaryAction` is the last child.\n */\nconst ListItem = /*#__PURE__*/React.forwardRef(function ListItem(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiListItem'\n  });\n  const {\n      alignItems = 'center',\n      autoFocus = false,\n      button = false,\n      children: childrenProp,\n      className,\n      component: componentProp,\n      components = {},\n      componentsProps = {},\n      ContainerComponent = 'li',\n      ContainerProps: {\n        className: ContainerClassName\n      } = {},\n      dense = false,\n      disabled = false,\n      disableGutters = false,\n      disablePadding = false,\n      divider = false,\n      focusVisibleClassName,\n      secondaryAction,\n      selected = false,\n      slotProps = {},\n      slots = {}\n    } = props,\n    ContainerProps = _objectWithoutPropertiesLoose(props.ContainerProps, _excluded),\n    other = _objectWithoutPropertiesLoose(props, _excluded2);\n  const context = React.useContext(ListContext);\n  const childContext = React.useMemo(() => ({\n    dense: dense || context.dense || false,\n    alignItems,\n    disableGutters\n  }), [alignItems, context.dense, dense, disableGutters]);\n  const listItemRef = React.useRef(null);\n  useEnhancedEffect(() => {\n    if (autoFocus) {\n      if (listItemRef.current) {\n        listItemRef.current.focus();\n      } else if (process.env.NODE_ENV !== 'production') {\n        console.error('MUI: Unable to set focus to a ListItem whose component has not been rendered.');\n      }\n    }\n  }, [autoFocus]);\n  const children = React.Children.toArray(childrenProp);\n\n  // v4 implementation, deprecated in v5, will be removed in v6\n  const hasSecondaryAction = children.length && isMuiElement(children[children.length - 1], ['ListItemSecondaryAction']);\n  const ownerState = _extends({}, props, {\n    alignItems,\n    autoFocus,\n    button,\n    dense: childContext.dense,\n    disabled,\n    disableGutters,\n    disablePadding,\n    divider,\n    hasSecondaryAction,\n    selected\n  });\n  const classes = useUtilityClasses(ownerState);\n  const handleRef = useForkRef(listItemRef, ref);\n  const Root = slots.root || components.Root || ListItemRoot;\n  const rootProps = slotProps.root || componentsProps.root || {};\n  const componentProps = _extends({\n    className: clsx(classes.root, rootProps.className, className),\n    disabled\n  }, other);\n  let Component = componentProp || 'li';\n  if (button) {\n    componentProps.component = componentProp || 'div';\n    componentProps.focusVisibleClassName = clsx(listItemClasses.focusVisible, focusVisibleClassName);\n    Component = ButtonBase;\n  }\n\n  // v4 implementation, deprecated in v5, will be removed in v6\n  if (hasSecondaryAction) {\n    // Use div by default.\n    Component = !componentProps.component && !componentProp ? 'div' : Component;\n\n    // Avoid nesting of li > li.\n    if (ContainerComponent === 'li') {\n      if (Component === 'li') {\n        Component = 'div';\n      } else if (componentProps.component === 'li') {\n        componentProps.component = 'div';\n      }\n    }\n    return /*#__PURE__*/_jsx(ListContext.Provider, {\n      value: childContext,\n      children: /*#__PURE__*/_jsxs(ListItemContainer, _extends({\n        as: ContainerComponent,\n        className: clsx(classes.container, ContainerClassName),\n        ref: handleRef,\n        ownerState: ownerState\n      }, ContainerProps, {\n        children: [/*#__PURE__*/_jsx(Root, _extends({}, rootProps, !isHostComponent(Root) && {\n          as: Component,\n          ownerState: _extends({}, ownerState, rootProps.ownerState)\n        }, componentProps, {\n          children: children\n        })), children.pop()]\n      }))\n    });\n  }\n  return /*#__PURE__*/_jsx(ListContext.Provider, {\n    value: childContext,\n    children: /*#__PURE__*/_jsxs(Root, _extends({}, rootProps, {\n      as: Component,\n      ref: handleRef\n    }, !isHostComponent(Root) && {\n      ownerState: _extends({}, ownerState, rootProps.ownerState)\n    }, componentProps, {\n      children: [children, secondaryAction && /*#__PURE__*/_jsx(ListItemSecondaryAction, {\n        children: secondaryAction\n      })]\n    }))\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? ListItem.propTypes /* remove-proptypes */ = {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n  /**\n   * Defines the `align-items` style property.\n   * @default 'center'\n   */\n  alignItems: PropTypes.oneOf(['center', 'flex-start']),\n  /**\n   * If `true`, the list item is focused during the first mount.\n   * Focus will also be triggered if the value changes from false to true.\n   * @default false\n   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead\n   */\n  autoFocus: PropTypes.bool,\n  /**\n   * If `true`, the list item is a button (using `ButtonBase`). Props intended\n   * for `ButtonBase` can then be applied to `ListItem`.\n   * @default false\n   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead\n   */\n  button: PropTypes.bool,\n  /**\n   * The content of the component if a `ListItemSecondaryAction` is used it must\n   * be the last child.\n   */\n  children: chainPropTypes(PropTypes.node, props => {\n    const children = React.Children.toArray(props.children);\n\n    // React.Children.toArray(props.children).findLastIndex(isListItemSecondaryAction)\n    let secondaryActionIndex = -1;\n    for (let i = children.length - 1; i >= 0; i -= 1) {\n      const child = children[i];\n      if (isMuiElement(child, ['ListItemSecondaryAction'])) {\n        secondaryActionIndex = i;\n        break;\n      }\n    }\n\n    //  is ListItemSecondaryAction the last child of ListItem\n    if (secondaryActionIndex !== -1 && secondaryActionIndex !== children.length - 1) {\n      return new Error('MUI: You used an element after ListItemSecondaryAction. ' + 'For ListItem to detect that it has a secondary action ' + 'you must pass it as the last child to ListItem.');\n    }\n    return null;\n  }),\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * The components used for each slot inside.\n   *\n   * This prop is an alias for the `slots` prop.\n   * It's recommended to use the `slots` prop instead.\n   *\n   * @default {}\n   */\n  components: PropTypes.shape({\n    Root: PropTypes.elementType\n  }),\n  /**\n   * The extra props for the slot components.\n   * You can override the existing props or add new ones.\n   *\n   * This prop is an alias for the `slotProps` prop.\n   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.\n   *\n   * @default {}\n   */\n  componentsProps: PropTypes.shape({\n    root: PropTypes.object\n  }),\n  /**\n   * The container component used when a `ListItemSecondaryAction` is the last child.\n   * @default 'li'\n   * @deprecated\n   */\n  ContainerComponent: elementTypeAcceptingRef,\n  /**\n   * Props applied to the container component if used.\n   * @default {}\n   * @deprecated\n   */\n  ContainerProps: PropTypes.object,\n  /**\n   * If `true`, compact vertical padding designed for keyboard and mouse input is used.\n   * The prop defaults to the value inherited from the parent List component.\n   * @default false\n   */\n  dense: PropTypes.bool,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the left and right padding is removed.\n   * @default false\n   */\n  disableGutters: PropTypes.bool,\n  /**\n   * If `true`, all padding is removed.\n   * @default false\n   */\n  disablePadding: PropTypes.bool,\n  /**\n   * If `true`, a 1px light border is added to the bottom of the list item.\n   * @default false\n   */\n  divider: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  focusVisibleClassName: PropTypes.string,\n  /**\n   * The element to display at the end of ListItem.\n   */\n  secondaryAction: PropTypes.node,\n  /**\n   * Use to apply selected styling.\n   * @default false\n   * @deprecated checkout [ListItemButton](/material-ui/api/list-item-button/) instead\n   */\n  selected: PropTypes.bool,\n  /**\n   * The extra props for the slot components.\n   * You can override the existing props or add new ones.\n   *\n   * This prop is an alias for the `componentsProps` prop, which will be deprecated in the future.\n   *\n   * @default {}\n   */\n  slotProps: PropTypes.shape({\n    root: PropTypes.object\n  }),\n  /**\n   * The components used for each slot inside.\n   *\n   * This prop is an alias for the `components` prop, which will be deprecated in the future.\n   *\n   * @default {}\n   */\n  slots: PropTypes.shape({\n    root: PropTypes.elementType\n  }),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default ListItem;","/*!\n * @kurkle/color v0.3.2\n * https://github.com/kurkle/color#readme\n * (c) 2023 Jukka Kurkela\n * Released under the MIT License\n */\nfunction round(v) {\n  return v + 0.5 | 0;\n}\nconst lim = (v, l, h) => Math.max(Math.min(v, h), l);\nfunction p2b(v) {\n  return lim(round(v * 2.55), 0, 255);\n}\nfunction b2p(v) {\n  return lim(round(v / 2.55), 0, 100);\n}\nfunction n2b(v) {\n  return lim(round(v * 255), 0, 255);\n}\nfunction b2n(v) {\n  return lim(round(v / 2.55) / 100, 0, 1);\n}\nfunction n2p(v) {\n  return lim(round(v * 100), 0, 100);\n}\n\nconst map$1 = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15};\nconst hex = [...'0123456789ABCDEF'];\nconst h1 = b => hex[b & 0xF];\nconst h2 = b => hex[(b & 0xF0) >> 4] + hex[b & 0xF];\nconst eq = b => ((b & 0xF0) >> 4) === (b & 0xF);\nconst isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);\nfunction hexParse(str) {\n  var len = str.length;\n  var ret;\n  if (str[0] === '#') {\n    if (len === 4 || len === 5) {\n      ret = {\n        r: 255 & map$1[str[1]] * 17,\n        g: 255 & map$1[str[2]] * 17,\n        b: 255 & map$1[str[3]] * 17,\n        a: len === 5 ? map$1[str[4]] * 17 : 255\n      };\n    } else if (len === 7 || len === 9) {\n      ret = {\n        r: map$1[str[1]] << 4 | map$1[str[2]],\n        g: map$1[str[3]] << 4 | map$1[str[4]],\n        b: map$1[str[5]] << 4 | map$1[str[6]],\n        a: len === 9 ? (map$1[str[7]] << 4 | map$1[str[8]]) : 255\n      };\n    }\n  }\n  return ret;\n}\nconst alpha = (a, f) => a < 255 ? f(a) : '';\nfunction hexString(v) {\n  var f = isShort(v) ? h1 : h2;\n  return v\n    ? '#' + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f)\n    : undefined;\n}\n\nconst HUE_RE = /^(hsla?|hwb|hsv)\\(\\s*([-+.e\\d]+)(?:deg)?[\\s,]+([-+.e\\d]+)%[\\s,]+([-+.e\\d]+)%(?:[\\s,]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction hsl2rgbn(h, s, l) {\n  const a = s * Math.min(l, 1 - l);\n  const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\n  return [f(0), f(8), f(4)];\n}\nfunction hsv2rgbn(h, s, v) {\n  const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);\n  return [f(5), f(3), f(1)];\n}\nfunction hwb2rgbn(h, w, b) {\n  const rgb = hsl2rgbn(h, 1, 0.5);\n  let i;\n  if (w + b > 1) {\n    i = 1 / (w + b);\n    w *= i;\n    b *= i;\n  }\n  for (i = 0; i < 3; i++) {\n    rgb[i] *= 1 - w - b;\n    rgb[i] += w;\n  }\n  return rgb;\n}\nfunction hueValue(r, g, b, d, max) {\n  if (r === max) {\n    return ((g - b) / d) + (g < b ? 6 : 0);\n  }\n  if (g === max) {\n    return (b - r) / d + 2;\n  }\n  return (r - g) / d + 4;\n}\nfunction rgb2hsl(v) {\n  const range = 255;\n  const r = v.r / range;\n  const g = v.g / range;\n  const b = v.b / range;\n  const max = Math.max(r, g, b);\n  const min = Math.min(r, g, b);\n  const l = (max + min) / 2;\n  let h, s, d;\n  if (max !== min) {\n    d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    h = hueValue(r, g, b, d, max);\n    h = h * 60 + 0.5;\n  }\n  return [h | 0, s || 0, l];\n}\nfunction calln(f, a, b, c) {\n  return (\n    Array.isArray(a)\n      ? f(a[0], a[1], a[2])\n      : f(a, b, c)\n  ).map(n2b);\n}\nfunction hsl2rgb(h, s, l) {\n  return calln(hsl2rgbn, h, s, l);\n}\nfunction hwb2rgb(h, w, b) {\n  return calln(hwb2rgbn, h, w, b);\n}\nfunction hsv2rgb(h, s, v) {\n  return calln(hsv2rgbn, h, s, v);\n}\nfunction hue(h) {\n  return (h % 360 + 360) % 360;\n}\nfunction hueParse(str) {\n  const m = HUE_RE.exec(str);\n  let a = 255;\n  let v;\n  if (!m) {\n    return;\n  }\n  if (m[5] !== v) {\n    a = m[6] ? p2b(+m[5]) : n2b(+m[5]);\n  }\n  const h = hue(+m[2]);\n  const p1 = +m[3] / 100;\n  const p2 = +m[4] / 100;\n  if (m[1] === 'hwb') {\n    v = hwb2rgb(h, p1, p2);\n  } else if (m[1] === 'hsv') {\n    v = hsv2rgb(h, p1, p2);\n  } else {\n    v = hsl2rgb(h, p1, p2);\n  }\n  return {\n    r: v[0],\n    g: v[1],\n    b: v[2],\n    a: a\n  };\n}\nfunction rotate(v, deg) {\n  var h = rgb2hsl(v);\n  h[0] = hue(h[0] + deg);\n  h = hsl2rgb(h);\n  v.r = h[0];\n  v.g = h[1];\n  v.b = h[2];\n}\nfunction hslString(v) {\n  if (!v) {\n    return;\n  }\n  const a = rgb2hsl(v);\n  const h = a[0];\n  const s = n2p(a[1]);\n  const l = n2p(a[2]);\n  return v.a < 255\n    ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})`\n    : `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nconst map = {\n  x: 'dark',\n  Z: 'light',\n  Y: 're',\n  X: 'blu',\n  W: 'gr',\n  V: 'medium',\n  U: 'slate',\n  A: 'ee',\n  T: 'ol',\n  S: 'or',\n  B: 'ra',\n  C: 'lateg',\n  D: 'ights',\n  R: 'in',\n  Q: 'turquois',\n  E: 'hi',\n  P: 'ro',\n  O: 'al',\n  N: 'le',\n  M: 'de',\n  L: 'yello',\n  F: 'en',\n  K: 'ch',\n  G: 'arks',\n  H: 'ea',\n  I: 'ightg',\n  J: 'wh'\n};\nconst names$1 = {\n  OiceXe: 'f0f8ff',\n  antiquewEte: 'faebd7',\n  aqua: 'ffff',\n  aquamarRe: '7fffd4',\n  azuY: 'f0ffff',\n  beige: 'f5f5dc',\n  bisque: 'ffe4c4',\n  black: '0',\n  blanKedOmond: 'ffebcd',\n  Xe: 'ff',\n  XeviTet: '8a2be2',\n  bPwn: 'a52a2a',\n  burlywood: 'deb887',\n  caMtXe: '5f9ea0',\n  KartYuse: '7fff00',\n  KocTate: 'd2691e',\n  cSO: 'ff7f50',\n  cSnflowerXe: '6495ed',\n  cSnsilk: 'fff8dc',\n  crimson: 'dc143c',\n  cyan: 'ffff',\n  xXe: '8b',\n  xcyan: '8b8b',\n  xgTMnPd: 'b8860b',\n  xWay: 'a9a9a9',\n  xgYF: '6400',\n  xgYy: 'a9a9a9',\n  xkhaki: 'bdb76b',\n  xmagFta: '8b008b',\n  xTivegYF: '556b2f',\n  xSange: 'ff8c00',\n  xScEd: '9932cc',\n  xYd: '8b0000',\n  xsOmon: 'e9967a',\n  xsHgYF: '8fbc8f',\n  xUXe: '483d8b',\n  xUWay: '2f4f4f',\n  xUgYy: '2f4f4f',\n  xQe: 'ced1',\n  xviTet: '9400d3',\n  dAppRk: 'ff1493',\n  dApskyXe: 'bfff',\n  dimWay: '696969',\n  dimgYy: '696969',\n  dodgerXe: '1e90ff',\n  fiYbrick: 'b22222',\n  flSOwEte: 'fffaf0',\n  foYstWAn: '228b22',\n  fuKsia: 'ff00ff',\n  gaRsbSo: 'dcdcdc',\n  ghostwEte: 'f8f8ff',\n  gTd: 'ffd700',\n  gTMnPd: 'daa520',\n  Way: '808080',\n  gYF: '8000',\n  gYFLw: 'adff2f',\n  gYy: '808080',\n  honeyMw: 'f0fff0',\n  hotpRk: 'ff69b4',\n  RdianYd: 'cd5c5c',\n  Rdigo: '4b0082',\n  ivSy: 'fffff0',\n  khaki: 'f0e68c',\n  lavFMr: 'e6e6fa',\n  lavFMrXsh: 'fff0f5',\n  lawngYF: '7cfc00',\n  NmoncEffon: 'fffacd',\n  ZXe: 'add8e6',\n  ZcSO: 'f08080',\n  Zcyan: 'e0ffff',\n  ZgTMnPdLw: 'fafad2',\n  ZWay: 'd3d3d3',\n  ZgYF: '90ee90',\n  ZgYy: 'd3d3d3',\n  ZpRk: 'ffb6c1',\n  ZsOmon: 'ffa07a',\n  ZsHgYF: '20b2aa',\n  ZskyXe: '87cefa',\n  ZUWay: '778899',\n  ZUgYy: '778899',\n  ZstAlXe: 'b0c4de',\n  ZLw: 'ffffe0',\n  lime: 'ff00',\n  limegYF: '32cd32',\n  lRF: 'faf0e6',\n  magFta: 'ff00ff',\n  maPon: '800000',\n  VaquamarRe: '66cdaa',\n  VXe: 'cd',\n  VScEd: 'ba55d3',\n  VpurpN: '9370db',\n  VsHgYF: '3cb371',\n  VUXe: '7b68ee',\n  VsprRggYF: 'fa9a',\n  VQe: '48d1cc',\n  VviTetYd: 'c71585',\n  midnightXe: '191970',\n  mRtcYam: 'f5fffa',\n  mistyPse: 'ffe4e1',\n  moccasR: 'ffe4b5',\n  navajowEte: 'ffdead',\n  navy: '80',\n  Tdlace: 'fdf5e6',\n  Tive: '808000',\n  TivedBb: '6b8e23',\n  Sange: 'ffa500',\n  SangeYd: 'ff4500',\n  ScEd: 'da70d6',\n  pOegTMnPd: 'eee8aa',\n  pOegYF: '98fb98',\n  pOeQe: 'afeeee',\n  pOeviTetYd: 'db7093',\n  papayawEp: 'ffefd5',\n  pHKpuff: 'ffdab9',\n  peru: 'cd853f',\n  pRk: 'ffc0cb',\n  plum: 'dda0dd',\n  powMrXe: 'b0e0e6',\n  purpN: '800080',\n  YbeccapurpN: '663399',\n  Yd: 'ff0000',\n  Psybrown: 'bc8f8f',\n  PyOXe: '4169e1',\n  saddNbPwn: '8b4513',\n  sOmon: 'fa8072',\n  sandybPwn: 'f4a460',\n  sHgYF: '2e8b57',\n  sHshell: 'fff5ee',\n  siFna: 'a0522d',\n  silver: 'c0c0c0',\n  skyXe: '87ceeb',\n  UXe: '6a5acd',\n  UWay: '708090',\n  UgYy: '708090',\n  snow: 'fffafa',\n  sprRggYF: 'ff7f',\n  stAlXe: '4682b4',\n  tan: 'd2b48c',\n  teO: '8080',\n  tEstN: 'd8bfd8',\n  tomato: 'ff6347',\n  Qe: '40e0d0',\n  viTet: 'ee82ee',\n  JHt: 'f5deb3',\n  wEte: 'ffffff',\n  wEtesmoke: 'f5f5f5',\n  Lw: 'ffff00',\n  LwgYF: '9acd32'\n};\nfunction unpack() {\n  const unpacked = {};\n  const keys = Object.keys(names$1);\n  const tkeys = Object.keys(map);\n  let i, j, k, ok, nk;\n  for (i = 0; i < keys.length; i++) {\n    ok = nk = keys[i];\n    for (j = 0; j < tkeys.length; j++) {\n      k = tkeys[j];\n      nk = nk.replace(k, map[k]);\n    }\n    k = parseInt(names$1[ok], 16);\n    unpacked[nk] = [k >> 16 & 0xFF, k >> 8 & 0xFF, k & 0xFF];\n  }\n  return unpacked;\n}\n\nlet names;\nfunction nameParse(str) {\n  if (!names) {\n    names = unpack();\n    names.transparent = [0, 0, 0, 0];\n  }\n  const a = names[str.toLowerCase()];\n  return a && {\n    r: a[0],\n    g: a[1],\n    b: a[2],\n    a: a.length === 4 ? a[3] : 255\n  };\n}\n\nconst RGB_RE = /^rgba?\\(\\s*([-+.\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?[\\s,]+([-+.e\\d]+)(%)?(?:[\\s,/]+([-+.e\\d]+)(%)?)?\\s*\\)$/;\nfunction rgbParse(str) {\n  const m = RGB_RE.exec(str);\n  let a = 255;\n  let r, g, b;\n  if (!m) {\n    return;\n  }\n  if (m[7] !== r) {\n    const v = +m[7];\n    a = m[8] ? p2b(v) : lim(v * 255, 0, 255);\n  }\n  r = +m[1];\n  g = +m[3];\n  b = +m[5];\n  r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));\n  g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));\n  b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nfunction rgbString(v) {\n  return v && (\n    v.a < 255\n      ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})`\n      : `rgb(${v.r}, ${v.g}, ${v.b})`\n  );\n}\n\nconst to = v => v <= 0.0031308 ? v * 12.92 : Math.pow(v, 1.0 / 2.4) * 1.055 - 0.055;\nconst from = v => v <= 0.04045 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);\nfunction interpolate(rgb1, rgb2, t) {\n  const r = from(b2n(rgb1.r));\n  const g = from(b2n(rgb1.g));\n  const b = from(b2n(rgb1.b));\n  return {\n    r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),\n    g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),\n    b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),\n    a: rgb1.a + t * (rgb2.a - rgb1.a)\n  };\n}\n\nfunction modHSL(v, i, ratio) {\n  if (v) {\n    let tmp = rgb2hsl(v);\n    tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));\n    tmp = hsl2rgb(tmp);\n    v.r = tmp[0];\n    v.g = tmp[1];\n    v.b = tmp[2];\n  }\n}\nfunction clone(v, proto) {\n  return v ? Object.assign(proto || {}, v) : v;\n}\nfunction fromObject(input) {\n  var v = {r: 0, g: 0, b: 0, a: 255};\n  if (Array.isArray(input)) {\n    if (input.length >= 3) {\n      v = {r: input[0], g: input[1], b: input[2], a: 255};\n      if (input.length > 3) {\n        v.a = n2b(input[3]);\n      }\n    }\n  } else {\n    v = clone(input, {r: 0, g: 0, b: 0, a: 1});\n    v.a = n2b(v.a);\n  }\n  return v;\n}\nfunction functionParse(str) {\n  if (str.charAt(0) === 'r') {\n    return rgbParse(str);\n  }\n  return hueParse(str);\n}\nclass Color {\n  constructor(input) {\n    if (input instanceof Color) {\n      return input;\n    }\n    const type = typeof input;\n    let v;\n    if (type === 'object') {\n      v = fromObject(input);\n    } else if (type === 'string') {\n      v = hexParse(input) || nameParse(input) || functionParse(input);\n    }\n    this._rgb = v;\n    this._valid = !!v;\n  }\n  get valid() {\n    return this._valid;\n  }\n  get rgb() {\n    var v = clone(this._rgb);\n    if (v) {\n      v.a = b2n(v.a);\n    }\n    return v;\n  }\n  set rgb(obj) {\n    this._rgb = fromObject(obj);\n  }\n  rgbString() {\n    return this._valid ? rgbString(this._rgb) : undefined;\n  }\n  hexString() {\n    return this._valid ? hexString(this._rgb) : undefined;\n  }\n  hslString() {\n    return this._valid ? hslString(this._rgb) : undefined;\n  }\n  mix(color, weight) {\n    if (color) {\n      const c1 = this.rgb;\n      const c2 = color.rgb;\n      let w2;\n      const p = weight === w2 ? 0.5 : weight;\n      const w = 2 * p - 1;\n      const a = c1.a - c2.a;\n      const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2.0;\n      w2 = 1 - w1;\n      c1.r = 0xFF & w1 * c1.r + w2 * c2.r + 0.5;\n      c1.g = 0xFF & w1 * c1.g + w2 * c2.g + 0.5;\n      c1.b = 0xFF & w1 * c1.b + w2 * c2.b + 0.5;\n      c1.a = p * c1.a + (1 - p) * c2.a;\n      this.rgb = c1;\n    }\n    return this;\n  }\n  interpolate(color, t) {\n    if (color) {\n      this._rgb = interpolate(this._rgb, color._rgb, t);\n    }\n    return this;\n  }\n  clone() {\n    return new Color(this.rgb);\n  }\n  alpha(a) {\n    this._rgb.a = n2b(a);\n    return this;\n  }\n  clearer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 - ratio;\n    return this;\n  }\n  greyscale() {\n    const rgb = this._rgb;\n    const val = round(rgb.r * 0.3 + rgb.g * 0.59 + rgb.b * 0.11);\n    rgb.r = rgb.g = rgb.b = val;\n    return this;\n  }\n  opaquer(ratio) {\n    const rgb = this._rgb;\n    rgb.a *= 1 + ratio;\n    return this;\n  }\n  negate() {\n    const v = this._rgb;\n    v.r = 255 - v.r;\n    v.g = 255 - v.g;\n    v.b = 255 - v.b;\n    return this;\n  }\n  lighten(ratio) {\n    modHSL(this._rgb, 2, ratio);\n    return this;\n  }\n  darken(ratio) {\n    modHSL(this._rgb, 2, -ratio);\n    return this;\n  }\n  saturate(ratio) {\n    modHSL(this._rgb, 1, ratio);\n    return this;\n  }\n  desaturate(ratio) {\n    modHSL(this._rgb, 1, -ratio);\n    return this;\n  }\n  rotate(deg) {\n    rotate(this._rgb, deg);\n    return this;\n  }\n}\n\nfunction index_esm(input) {\n  return new Color(input);\n}\n\nexport { Color, b2n, b2p, index_esm as default, hexParse, hexString, hsl2rgb, hslString, hsv2rgb, hueParse, hwb2rgb, lim, n2b, n2p, nameParse, p2b, rgb2hsl, rgbParse, rgbString, rotate, round };\n","/**\n * @namespace Chart.helpers\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ActiveDataPoint, ChartEvent} from '../types/index.js';\n\n/**\n * An empty function that can be used, for example, for optional callback.\n */\nexport function noop() {\n  /* noop */\n}\n\n/**\n * Returns a unique id, sequentially generated from a global variable.\n */\nexport const uid = (() => {\n  let id = 0;\n  return () => id++;\n})();\n\n/**\n * Returns true if `value` is neither null nor undefined, else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isNullOrUndef(value: unknown): value is null | undefined {\n  return value === null || typeof value === 'undefined';\n}\n\n/**\n * Returns true if `value` is an array (including typed arrays), else returns false.\n * @param value - The value to test.\n * @function\n */\nexport function isArray<T = unknown>(value: unknown): value is T[] {\n  if (Array.isArray && Array.isArray(value)) {\n    return true;\n  }\n  const type = Object.prototype.toString.call(value);\n  if (type.slice(0, 7) === '[object' && type.slice(-6) === 'Array]') {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Returns true if `value` is an object (excluding null), else returns false.\n * @param value - The value to test.\n * @since 2.7.0\n */\nexport function isObject(value: unknown): value is AnyObject {\n  return value !== null && Object.prototype.toString.call(value) === '[object Object]';\n}\n\n/**\n * Returns true if `value` is a finite number, else returns false\n * @param value  - The value to test.\n */\nfunction isNumberFinite(value: unknown): value is number {\n  return (typeof value === 'number' || value instanceof Number) && isFinite(+value);\n}\nexport {\n  isNumberFinite as isFinite,\n};\n\n/**\n * Returns `value` if finite, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is not finite.\n */\nexport function finiteOrDefault(value: unknown, defaultValue: number) {\n  return isNumberFinite(value) ? value : defaultValue;\n}\n\n/**\n * Returns `value` if defined, else returns `defaultValue`.\n * @param value - The value to return if defined.\n * @param defaultValue - The value to return if `value` is undefined.\n */\nexport function valueOrDefault<T>(value: T | undefined, defaultValue: T) {\n  return typeof value === 'undefined' ? defaultValue : value;\n}\n\nexport const toPercentage = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100\n    : +value / dimension;\n\nexport const toDimension = (value: number | string, dimension: number) =>\n  typeof value === 'string' && value.endsWith('%') ?\n    parseFloat(value) / 100 * dimension\n    : +value;\n\n/**\n * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the\n * value returned by `fn`. If `fn` is not a function, this method returns undefined.\n * @param fn - The function to call.\n * @param args - The arguments with which `fn` should be called.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n */\nexport function callback<T extends (this: TA, ...restArgs: unknown[]) => R, TA, R>(\n  fn: T | undefined,\n  args: unknown[],\n  thisArg?: TA\n): R | undefined {\n  if (fn && typeof fn.call === 'function') {\n    return fn.apply(thisArg, args);\n  }\n}\n\n/**\n * Note(SB) for performance sake, this method should only be used when loopable type\n * is unknown or in none intensive code (not called often and small loopable). Else\n * it's preferable to use a regular for() loop and save extra function calls.\n * @param loopable - The object or array to be iterated.\n * @param fn - The function to call for each item.\n * @param [thisArg] - The value of `this` provided for the call to `fn`.\n * @param [reverse] - If true, iterates backward on the loopable.\n */\nexport function each<T, TA>(\n  loopable: Record<string, T>,\n  fn: (this: TA, v: T, i: string) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[],\n  fn: (this: TA, v: T, i: number) => void,\n  thisArg?: TA,\n  reverse?: boolean\n): void;\nexport function each<T, TA>(\n  loopable: T[] | Record<string, T>,\n  fn: (this: TA, v: T, i: any) => void,\n  thisArg?: TA,\n  reverse?: boolean\n) {\n  let i: number, len: number, keys: string[];\n  if (isArray(loopable)) {\n    len = loopable.length;\n    if (reverse) {\n      for (i = len - 1; i >= 0; i--) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    } else {\n      for (i = 0; i < len; i++) {\n        fn.call(thisArg, loopable[i], i);\n      }\n    }\n  } else if (isObject(loopable)) {\n    keys = Object.keys(loopable);\n    len = keys.length;\n    for (i = 0; i < len; i++) {\n      fn.call(thisArg, loopable[keys[i]], keys[i]);\n    }\n  }\n}\n\n/**\n * Returns true if the `a0` and `a1` arrays have the same content, else returns false.\n * @param a0 - The array to compare\n * @param a1 - The array to compare\n * @private\n */\nexport function _elementsEqual(a0: ActiveDataPoint[], a1: ActiveDataPoint[]) {\n  let i: number, ilen: number, v0: ActiveDataPoint, v1: ActiveDataPoint;\n\n  if (!a0 || !a1 || a0.length !== a1.length) {\n    return false;\n  }\n\n  for (i = 0, ilen = a0.length; i < ilen; ++i) {\n    v0 = a0[i];\n    v1 = a1[i];\n\n    if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Returns a deep copy of `source` without keeping references on objects and arrays.\n * @param source - The value to clone.\n */\nexport function clone<T>(source: T): T {\n  if (isArray(source)) {\n    return source.map(clone) as unknown as T;\n  }\n\n  if (isObject(source)) {\n    const target = Object.create(null);\n    const keys = Object.keys(source);\n    const klen = keys.length;\n    let k = 0;\n\n    for (; k < klen; ++k) {\n      target[keys[k]] = clone(source[keys[k]]);\n    }\n\n    return target;\n  }\n\n  return source;\n}\n\nfunction isValidKey(key: string) {\n  return ['__proto__', 'prototype', 'constructor'].indexOf(key) === -1;\n}\n\n/**\n * The default merger when Chart.helpers.merge is called without merger option.\n * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.\n * @private\n */\nexport function _merger(key: string, target: AnyObject, source: AnyObject, options: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    merge(tval, sval, options);\n  } else {\n    target[key] = clone(sval);\n  }\n}\n\nexport interface MergeOptions {\n  merger?: (key: string, target: AnyObject, source: AnyObject, options?: AnyObject) => void;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` with the given `options`.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @param [options] - Merging options:\n * @param [options.merger] - The merge method (key, target, source, options)\n * @returns The `target` object.\n */\nexport function merge<T>(target: T, source: [], options?: MergeOptions): T;\nexport function merge<T, S1>(target: T, source: S1, options?: MergeOptions): T & S1;\nexport function merge<T, S1>(target: T, source: [S1], options?: MergeOptions): T & S1;\nexport function merge<T, S1, S2>(target: T, source: [S1, S2], options?: MergeOptions): T & S1 & S2;\nexport function merge<T, S1, S2, S3>(target: T, source: [S1, S2, S3], options?: MergeOptions): T & S1 & S2 & S3;\nexport function merge<T, S1, S2, S3, S4>(\n  target: T,\n  source: [S1, S2, S3, S4],\n  options?: MergeOptions\n): T & S1 & S2 & S3 & S4;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject;\nexport function merge<T>(target: T, source: AnyObject[], options?: MergeOptions): AnyObject {\n  const sources = isArray(source) ? source : [source];\n  const ilen = sources.length;\n\n  if (!isObject(target)) {\n    return target as AnyObject;\n  }\n\n  options = options || {};\n  const merger = options.merger || _merger;\n  let current: AnyObject;\n\n  for (let i = 0; i < ilen; ++i) {\n    current = sources[i];\n    if (!isObject(current)) {\n      continue;\n    }\n\n    const keys = Object.keys(current);\n    for (let k = 0, klen = keys.length; k < klen; ++k) {\n      merger(keys[k], target, current, options as AnyObject);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Recursively deep copies `source` properties into `target` *only* if not defined in target.\n * IMPORTANT: `target` is not cloned and will be updated with `source` properties.\n * @param target - The target object in which all sources are merged into.\n * @param source - Object(s) to merge into `target`.\n * @returns The `target` object.\n */\nexport function mergeIf<T>(target: T, source: []): T;\nexport function mergeIf<T, S1>(target: T, source: S1): T & S1;\nexport function mergeIf<T, S1>(target: T, source: [S1]): T & S1;\nexport function mergeIf<T, S1, S2>(target: T, source: [S1, S2]): T & S1 & S2;\nexport function mergeIf<T, S1, S2, S3>(target: T, source: [S1, S2, S3]): T & S1 & S2 & S3;\nexport function mergeIf<T, S1, S2, S3, S4>(target: T, source: [S1, S2, S3, S4]): T & S1 & S2 & S3 & S4;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject;\nexport function mergeIf<T>(target: T, source: AnyObject[]): AnyObject {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  return merge<T>(target, source, {merger: _mergerIf});\n}\n\n/**\n * Merges source[key] in target[key] only if target[key] is undefined.\n * @private\n */\nexport function _mergerIf(key: string, target: AnyObject, source: AnyObject) {\n  if (!isValidKey(key)) {\n    return;\n  }\n\n  const tval = target[key];\n  const sval = source[key];\n\n  if (isObject(tval) && isObject(sval)) {\n    mergeIf(tval, sval);\n  } else if (!Object.prototype.hasOwnProperty.call(target, key)) {\n    target[key] = clone(sval);\n  }\n}\n\n/**\n * @private\n */\nexport function _deprecated(scope: string, value: unknown, previous: string, current: string) {\n  if (value !== undefined) {\n    console.warn(scope + ': \"' + previous +\n      '\" is deprecated. Please use \"' + current + '\" instead');\n  }\n}\n\n// resolveObjectKey resolver cache\nconst keyResolvers = {\n  // Chart.helpers.core resolveObjectKey should resolve empty key to root object\n  '': v => v,\n  // default resolvers\n  x: o => o.x,\n  y: o => o.y\n};\n\n/**\n * @private\n */\nexport function _splitKey(key: string) {\n  const parts = key.split('.');\n  const keys: string[] = [];\n  let tmp = '';\n  for (const part of parts) {\n    tmp += part;\n    if (tmp.endsWith('\\\\')) {\n      tmp = tmp.slice(0, -1) + '.';\n    } else {\n      keys.push(tmp);\n      tmp = '';\n    }\n  }\n  return keys;\n}\n\nfunction _getKeyResolver(key: string) {\n  const keys = _splitKey(key);\n  return obj => {\n    for (const k of keys) {\n      if (k === '') {\n        // For backward compatibility:\n        // Chart.helpers.core resolveObjectKey should break at empty key\n        break;\n      }\n      obj = obj && obj[k];\n    }\n    return obj;\n  };\n}\n\nexport function resolveObjectKey(obj: AnyObject, key: string): any {\n  const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));\n  return resolver(obj);\n}\n\n/**\n * @private\n */\nexport function _capitalize(str: string) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\n\nexport const defined = (value: unknown) => typeof value !== 'undefined';\n\nexport const isFunction = (value: unknown): value is (...args: any[]) => any => typeof value === 'function';\n\n// Adapted from https://stackoverflow.com/questions/31128855/comparing-ecma6-sets-for-equality#31129384\nexport const setsEqual = <T>(a: Set<T>, b: Set<T>) => {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  for (const item of a) {\n    if (!b.has(item)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\n/**\n * @param e - The event\n * @private\n */\nexport function _isClickEvent(e: ChartEvent) {\n  return e.type === 'mouseup' || e.type === 'click' || e.type === 'contextmenu';\n}\n","import type {Point} from '../types/geometric.js';\nimport {isFinite as isFiniteNumber} from './helpers.core.js';\n\n/**\n * @alias Chart.helpers.math\n * @namespace\n */\n\nexport const PI = Math.PI;\nexport const TAU = 2 * PI;\nexport const PITAU = TAU + PI;\nexport const INFINITY = Number.POSITIVE_INFINITY;\nexport const RAD_PER_DEG = PI / 180;\nexport const HALF_PI = PI / 2;\nexport const QUARTER_PI = PI / 4;\nexport const TWO_THIRDS_PI = PI * 2 / 3;\n\nexport const log10 = Math.log10;\nexport const sign = Math.sign;\n\nexport function almostEquals(x: number, y: number, epsilon: number) {\n  return Math.abs(x - y) < epsilon;\n}\n\n/**\n * Implementation of the nice number algorithm used in determining where axis labels will go\n */\nexport function niceNum(range: number) {\n  const roundedRange = Math.round(range);\n  range = almostEquals(range, roundedRange, range / 1000) ? roundedRange : range;\n  const niceRange = Math.pow(10, Math.floor(log10(range)));\n  const fraction = range / niceRange;\n  const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;\n  return niceFraction * niceRange;\n}\n\n/**\n * Returns an array of factors sorted from 1 to sqrt(value)\n * @private\n */\nexport function _factorize(value: number) {\n  const result: number[] = [];\n  const sqrt = Math.sqrt(value);\n  let i: number;\n\n  for (i = 1; i < sqrt; i++) {\n    if (value % i === 0) {\n      result.push(i);\n      result.push(value / i);\n    }\n  }\n  if (sqrt === (sqrt | 0)) { // if value is a square number\n    result.push(sqrt);\n  }\n\n  result.sort((a, b) => a - b).pop();\n  return result;\n}\n\nexport function isNumber(n: unknown): n is number {\n  return !isNaN(parseFloat(n as string)) && isFinite(n as number);\n}\n\nexport function almostWhole(x: number, epsilon: number) {\n  const rounded = Math.round(x);\n  return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);\n}\n\n/**\n * @private\n */\nexport function _setMinAndMaxByKey(\n  array: Record<string, number>[],\n  target: { min: number, max: number },\n  property: string\n) {\n  let i: number, ilen: number, value: number;\n\n  for (i = 0, ilen = array.length; i < ilen; i++) {\n    value = array[i][property];\n    if (!isNaN(value)) {\n      target.min = Math.min(target.min, value);\n      target.max = Math.max(target.max, value);\n    }\n  }\n}\n\nexport function toRadians(degrees: number) {\n  return degrees * (PI / 180);\n}\n\nexport function toDegrees(radians: number) {\n  return radians * (180 / PI);\n}\n\n/**\n * Returns the number of decimal places\n * i.e. the number of digits after the decimal point, of the value of this Number.\n * @param x - A number.\n * @returns The number of decimal places.\n * @private\n */\nexport function _decimalPlaces(x: number) {\n  if (!isFiniteNumber(x)) {\n    return;\n  }\n  let e = 1;\n  let p = 0;\n  while (Math.round(x * e) / e !== x) {\n    e *= 10;\n    p++;\n  }\n  return p;\n}\n\n// Gets the angle from vertical upright to the point about a centre.\nexport function getAngleFromPoint(\n  centrePoint: Point,\n  anglePoint: Point\n) {\n  const distanceFromXCenter = anglePoint.x - centrePoint.x;\n  const distanceFromYCenter = anglePoint.y - centrePoint.y;\n  const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);\n\n  let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);\n\n  if (angle < (-0.5 * PI)) {\n    angle += TAU; // make sure the returned angle is in the range of (-PI/2, 3PI/2]\n  }\n\n  return {\n    angle,\n    distance: radialDistanceFromCenter\n  };\n}\n\nexport function distanceBetweenPoints(pt1: Point, pt2: Point) {\n  return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));\n}\n\n/**\n * Shortest distance between angles, in either direction.\n * @private\n */\nexport function _angleDiff(a: number, b: number) {\n  return (a - b + PITAU) % TAU - PI;\n}\n\n/**\n * Normalize angle to be between 0 and 2*PI\n * @private\n */\nexport function _normalizeAngle(a: number) {\n  return (a % TAU + TAU) % TAU;\n}\n\n/**\n * @private\n */\nexport function _angleBetween(angle: number, start: number, end: number, sameAngleIsFullCircle?: boolean) {\n  const a = _normalizeAngle(angle);\n  const s = _normalizeAngle(start);\n  const e = _normalizeAngle(end);\n  const angleToStart = _normalizeAngle(s - a);\n  const angleToEnd = _normalizeAngle(e - a);\n  const startToAngle = _normalizeAngle(a - s);\n  const endToAngle = _normalizeAngle(a - e);\n  return a === s || a === e || (sameAngleIsFullCircle && s === e)\n    || (angleToStart > angleToEnd && startToAngle < endToAngle);\n}\n\n/**\n * Limit `value` between `min` and `max`\n * @param value\n * @param min\n * @param max\n * @private\n */\nexport function _limitValue(value: number, min: number, max: number) {\n  return Math.max(min, Math.min(max, value));\n}\n\n/**\n * @param {number} value\n * @private\n */\nexport function _int16Range(value: number) {\n  return _limitValue(value, -32768, 32767);\n}\n\n/**\n * @param value\n * @param start\n * @param end\n * @param [epsilon]\n * @private\n */\nexport function _isBetween(value: number, start: number, end: number, epsilon = 1e-6) {\n  return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;\n}\n","import {_capitalize} from './helpers.core.js';\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param value - value to find\n * @param cmp\n * @private\n */\nexport function _lookup(\n  table: number[],\n  value: number,\n  cmp?: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup<T>(\n  table: T[],\n  value: number,\n  cmp: (value: number) => boolean\n): {lo: number, hi: number};\nexport function _lookup(\n  table: unknown[],\n  value: number,\n  cmp?: (value: number) => boolean\n) {\n  cmp = cmp || ((index) => table[index] < value);\n  let hi = table.length - 1;\n  let lo = 0;\n  let mid: number;\n\n  while (hi - lo > 1) {\n    mid = (lo + hi) >> 1;\n    if (cmp(mid)) {\n      lo = mid;\n    } else {\n      hi = mid;\n    }\n  }\n\n  return {lo, hi};\n}\n\n/**\n * Binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @param last - lookup last index\n * @private\n */\nexport const _lookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number,\n  last?: boolean\n) =>\n  _lookup(table, value, last\n    ? index => {\n      const ti = table[index][key];\n      return ti < value || ti === value && table[index + 1][key] === value;\n    }\n    : index => table[index][key] < value);\n\n/**\n * Reverse binary search\n * @param table - the table search. must be sorted!\n * @param key - property name for the value in each entry\n * @param value - value to find\n * @private\n */\nexport const _rlookupByKey = (\n  table: Record<string, number>[],\n  key: string,\n  value: number\n) =>\n  _lookup(table, value, index => table[index][key] >= value);\n\n/**\n * Return subset of `values` between `min` and `max` inclusive.\n * Values are assumed to be in sorted order.\n * @param values - sorted array of values\n * @param min - min value\n * @param max - max value\n */\nexport function _filterBetween(values: number[], min: number, max: number) {\n  let start = 0;\n  let end = values.length;\n\n  while (start < end && values[start] < min) {\n    start++;\n  }\n  while (end > start && values[end - 1] > max) {\n    end--;\n  }\n\n  return start > 0 || end < values.length\n    ? values.slice(start, end)\n    : values;\n}\n\nconst arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'] as const;\n\nexport interface ArrayListener<T> {\n  _onDataPush?(...item: T[]): void;\n  _onDataPop?(): void;\n  _onDataShift?(): void;\n  _onDataSplice?(index: number, deleteCount: number, ...items: T[]): void;\n  _onDataUnshift?(...item: T[]): void;\n}\n\n/**\n * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',\n * 'unshift') and notify the listener AFTER the array has been altered. Listeners are\n * called on the '_onData*' callbacks (e.g. _onDataPush, etc.) with same arguments.\n */\nexport function listenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function listenArrayEvents(array, listener) {\n  if (array._chartjs) {\n    array._chartjs.listeners.push(listener);\n    return;\n  }\n\n  Object.defineProperty(array, '_chartjs', {\n    configurable: true,\n    enumerable: false,\n    value: {\n      listeners: [listener]\n    }\n  });\n\n  arrayEvents.forEach((key) => {\n    const method = '_onData' + _capitalize(key);\n    const base = array[key];\n\n    Object.defineProperty(array, key, {\n      configurable: true,\n      enumerable: false,\n      value(...args) {\n        const res = base.apply(this, args);\n\n        array._chartjs.listeners.forEach((object) => {\n          if (typeof object[method] === 'function') {\n            object[method](...args);\n          }\n        });\n\n        return res;\n      }\n    });\n  });\n}\n\n\n/**\n * Removes the given array event listener and cleanup extra attached properties (such as\n * the _chartjs stub and overridden methods) if array doesn't have any more listeners.\n */\nexport function unlistenArrayEvents<T>(array: T[], listener: ArrayListener<T>): void;\nexport function unlistenArrayEvents(array, listener) {\n  const stub = array._chartjs;\n  if (!stub) {\n    return;\n  }\n\n  const listeners = stub.listeners;\n  const index = listeners.indexOf(listener);\n  if (index !== -1) {\n    listeners.splice(index, 1);\n  }\n\n  if (listeners.length > 0) {\n    return;\n  }\n\n  arrayEvents.forEach((key) => {\n    delete array[key];\n  });\n\n  delete array._chartjs;\n}\n\n/**\n * @param items\n */\nexport function _arrayUnique<T>(items: T[]) {\n  const set = new Set<T>(items);\n\n  if (set.size === items.length) {\n    return items;\n  }\n\n  return Array.from(set);\n}\n","import type {ChartMeta, PointElement} from '../types/index.js';\n\nimport {_limitValue} from './helpers.math.js';\nimport {_lookupByKey} from './helpers.collection.js';\n\nexport function fontString(pixelSize: number, fontStyle: string, fontFamily: string) {\n  return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;\n}\n\n/**\n* Request animation polyfill\n*/\nexport const requestAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return function(callback) {\n      return callback();\n    };\n  }\n  return window.requestAnimationFrame;\n}());\n\n/**\n * Throttles calling `fn` once per animation frame\n * Latest arguments are used on the actual call\n */\nexport function throttled<TArgs extends Array<any>>(\n  fn: (...args: TArgs) => void,\n  thisArg: any,\n) {\n  let argsToUse = [] as TArgs;\n  let ticking = false;\n\n  return function(...args: TArgs) {\n    // Save the args for use later\n    argsToUse = args;\n    if (!ticking) {\n      ticking = true;\n      requestAnimFrame.call(window, () => {\n        ticking = false;\n        fn.apply(thisArg, argsToUse);\n      });\n    }\n  };\n}\n\n/**\n * Debounces calling `fn` for `delay` ms\n */\nexport function debounce<TArgs extends Array<any>>(fn: (...args: TArgs) => void, delay: number) {\n  let timeout;\n  return function(...args: TArgs) {\n    if (delay) {\n      clearTimeout(timeout);\n      timeout = setTimeout(fn, delay, args);\n    } else {\n      fn.apply(this, args);\n    }\n    return delay;\n  };\n}\n\n/**\n * Converts 'start' to 'left', 'end' to 'right' and others to 'center'\n * @private\n */\nexport const _toLeftRightCenter = (align: 'start' | 'end' | 'center') => align === 'start' ? 'left' : align === 'end' ? 'right' : 'center';\n\n/**\n * Returns `start`, `end` or `(start + end) / 2` depending on `align`. Defaults to `center`\n * @private\n */\nexport const _alignStartEnd = (align: 'start' | 'end' | 'center', start: number, end: number) => align === 'start' ? start : align === 'end' ? end : (start + end) / 2;\n\n/**\n * Returns `left`, `right` or `(left + right) / 2` depending on `align`. Defaults to `left`\n * @private\n */\nexport const _textX = (align: 'left' | 'right' | 'center', left: number, right: number, rtl: boolean) => {\n  const check = rtl ? 'left' : 'right';\n  return align === check ? right : align === 'center' ? (left + right) / 2 : left;\n};\n\n/**\n * Return start and count of visible points.\n * @private\n */\nexport function _getStartAndCountOfVisiblePoints(meta: ChartMeta<'line' | 'scatter'>, points: PointElement[], animationsDisabled: boolean) {\n  const pointCount = points.length;\n\n  let start = 0;\n  let count = pointCount;\n\n  if (meta._sorted) {\n    const {iScale, _parsed} = meta;\n    const axis = iScale.axis;\n    const {min, max, minDefined, maxDefined} = iScale.getUserBounds();\n\n    if (minDefined) {\n      start = _limitValue(Math.min(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, axis, min).lo,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo),\n      0, pointCount - 1);\n    }\n    if (maxDefined) {\n      count = _limitValue(Math.max(\n        // @ts-expect-error Need to type _parsed\n        _lookupByKey(_parsed, iScale.axis, max, true).hi + 1,\n        // @ts-expect-error Need to fix types on _lookupByKey\n        animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1),\n      start, pointCount) - start;\n    } else {\n      count = pointCount - start;\n    }\n  }\n\n  return {start, count};\n}\n\n/**\n * Checks if the scale ranges have changed.\n * @param {object} meta - dataset meta.\n * @returns {boolean}\n * @private\n */\nexport function _scaleRangesChanged(meta) {\n  const {xScale, yScale, _scaleRanges} = meta;\n  const newRanges = {\n    xmin: xScale.min,\n    xmax: xScale.max,\n    ymin: yScale.min,\n    ymax: yScale.max\n  };\n  if (!_scaleRanges) {\n    meta._scaleRanges = newRanges;\n    return true;\n  }\n  const changed = _scaleRanges.xmin !== xScale.min\n\t\t|| _scaleRanges.xmax !== xScale.max\n\t\t|| _scaleRanges.ymin !== yScale.min\n\t\t|| _scaleRanges.ymax !== yScale.max;\n\n  Object.assign(_scaleRanges, newRanges);\n  return changed;\n}\n","import {PI, TAU, HALF_PI} from './helpers.math.js';\n\nconst atEdge = (t: number) => t === 0 || t === 1;\nconst elasticIn = (t: number, s: number, p: number) => -(Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p));\nconst elasticOut = (t: number, s: number, p: number) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;\n\n/**\n * Easing functions adapted from Robert Penner's easing equations.\n * @namespace Chart.helpers.easing.effects\n * @see http://www.robertpenner.com/easing/\n */\nconst effects = {\n  linear: (t: number) => t,\n\n  easeInQuad: (t: number) => t * t,\n\n  easeOutQuad: (t: number) => -t * (t - 2),\n\n  easeInOutQuad: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t\n    : -0.5 * ((--t) * (t - 2) - 1),\n\n  easeInCubic: (t: number) => t * t * t,\n\n  easeOutCubic: (t: number) => (t -= 1) * t * t + 1,\n\n  easeInOutCubic: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t\n    : 0.5 * ((t -= 2) * t * t + 2),\n\n  easeInQuart: (t: number) => t * t * t * t,\n\n  easeOutQuart: (t: number) => -((t -= 1) * t * t * t - 1),\n\n  easeInOutQuart: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t\n    : -0.5 * ((t -= 2) * t * t * t - 2),\n\n  easeInQuint: (t: number) => t * t * t * t * t,\n\n  easeOutQuint: (t: number) => (t -= 1) * t * t * t * t + 1,\n\n  easeInOutQuint: (t: number) => ((t /= 0.5) < 1)\n    ? 0.5 * t * t * t * t * t\n    : 0.5 * ((t -= 2) * t * t * t * t + 2),\n\n  easeInSine: (t: number) => -Math.cos(t * HALF_PI) + 1,\n\n  easeOutSine: (t: number) => Math.sin(t * HALF_PI),\n\n  easeInOutSine: (t: number) => -0.5 * (Math.cos(PI * t) - 1),\n\n  easeInExpo: (t: number) => (t === 0) ? 0 : Math.pow(2, 10 * (t - 1)),\n\n  easeOutExpo: (t: number) => (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1,\n\n  easeInOutExpo: (t: number) => atEdge(t) ? t : t < 0.5\n    ? 0.5 * Math.pow(2, 10 * (t * 2 - 1))\n    : 0.5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),\n\n  easeInCirc: (t: number) => (t >= 1) ? t : -(Math.sqrt(1 - t * t) - 1),\n\n  easeOutCirc: (t: number) => Math.sqrt(1 - (t -= 1) * t),\n\n  easeInOutCirc: (t: number) => ((t /= 0.5) < 1)\n    ? -0.5 * (Math.sqrt(1 - t * t) - 1)\n    : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1),\n\n  easeInElastic: (t: number) => atEdge(t) ? t : elasticIn(t, 0.075, 0.3),\n\n  easeOutElastic: (t: number) => atEdge(t) ? t : elasticOut(t, 0.075, 0.3),\n\n  easeInOutElastic(t: number) {\n    const s = 0.1125;\n    const p = 0.45;\n    return atEdge(t) ? t :\n      t < 0.5\n        ? 0.5 * elasticIn(t * 2, s, p)\n        : 0.5 + 0.5 * elasticOut(t * 2 - 1, s, p);\n  },\n\n  easeInBack(t: number) {\n    const s = 1.70158;\n    return t * t * ((s + 1) * t - s);\n  },\n\n  easeOutBack(t: number) {\n    const s = 1.70158;\n    return (t -= 1) * t * ((s + 1) * t + s) + 1;\n  },\n\n  easeInOutBack(t: number) {\n    let s = 1.70158;\n    if ((t /= 0.5) < 1) {\n      return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));\n    }\n    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);\n  },\n\n  easeInBounce: (t: number) => 1 - effects.easeOutBounce(1 - t),\n\n  easeOutBounce(t: number) {\n    const m = 7.5625;\n    const d = 2.75;\n    if (t < (1 / d)) {\n      return m * t * t;\n    }\n    if (t < (2 / d)) {\n      return m * (t -= (1.5 / d)) * t + 0.75;\n    }\n    if (t < (2.5 / d)) {\n      return m * (t -= (2.25 / d)) * t + 0.9375;\n    }\n    return m * (t -= (2.625 / d)) * t + 0.984375;\n  },\n\n  easeInOutBounce: (t: number) => (t < 0.5)\n    ? effects.easeInBounce(t * 2) * 0.5\n    : effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5,\n} as const;\n\nexport type EasingFunction = keyof typeof effects\n\nexport default effects;\n","import {Color} from '@kurkle/color';\n\nexport function isPatternOrGradient(value: unknown): value is CanvasPattern | CanvasGradient {\n  if (value && typeof value === 'object') {\n    const type = value.toString();\n    return type === '[object CanvasPattern]' || type === '[object CanvasGradient]';\n  }\n\n  return false;\n}\n\nexport function color(value: CanvasGradient): CanvasGradient;\nexport function color(value: CanvasPattern): CanvasPattern;\nexport function color(\n  value:\n  | string\n  | { r: number; g: number; b: number; a: number }\n  | [number, number, number]\n  | [number, number, number, number]\n): Color;\nexport function color(value) {\n  return isPatternOrGradient(value) ? value : new Color(value);\n}\n\nexport function getHoverColor(value: CanvasGradient): CanvasGradient;\nexport function getHoverColor(value: CanvasPattern): CanvasPattern;\nexport function getHoverColor(value: string): string;\nexport function getHoverColor(value) {\n  return isPatternOrGradient(value)\n    ? value\n    : new Color(value).saturate(0.5).darken(0.1).hexString();\n}\n","const numbers = ['x', 'y', 'borderWidth', 'radius', 'tension'];\nconst colors = ['color', 'borderColor', 'backgroundColor'];\n\nexport function applyAnimationsDefaults(defaults) {\n  defaults.set('animation', {\n    delay: undefined,\n    duration: 1000,\n    easing: 'easeOutQuart',\n    fn: undefined,\n    from: undefined,\n    loop: undefined,\n    to: undefined,\n    type: undefined,\n  });\n\n  defaults.describe('animation', {\n    _fallback: false,\n    _indexable: false,\n    _scriptable: (name) => name !== 'onProgress' && name !== 'onComplete' && name !== 'fn',\n  });\n\n  defaults.set('animations', {\n    colors: {\n      type: 'color',\n      properties: colors\n    },\n    numbers: {\n      type: 'number',\n      properties: numbers\n    },\n  });\n\n  defaults.describe('animations', {\n    _fallback: 'animation',\n  });\n\n  defaults.set('transitions', {\n    active: {\n      animation: {\n        duration: 400\n      }\n    },\n    resize: {\n      animation: {\n        duration: 0\n      }\n    },\n    show: {\n      animations: {\n        colors: {\n          from: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          duration: 0 // show immediately\n        },\n      }\n    },\n    hide: {\n      animations: {\n        colors: {\n          to: 'transparent'\n        },\n        visible: {\n          type: 'boolean',\n          easing: 'linear',\n          fn: v => v | 0 // for keeping the dataset visible all the way through the animation\n        },\n      }\n    }\n  });\n}\n","\nconst intlCache = new Map<string, Intl.NumberFormat>();\n\nfunction getNumberFormat(locale: string, options?: Intl.NumberFormatOptions) {\n  options = options || {};\n  const cacheKey = locale + JSON.stringify(options);\n  let formatter = intlCache.get(cacheKey);\n  if (!formatter) {\n    formatter = new Intl.NumberFormat(locale, options);\n    intlCache.set(cacheKey, formatter);\n  }\n  return formatter;\n}\n\nexport function formatNumber(num: number, locale: string, options?: Intl.NumberFormatOptions) {\n  return getNumberFormat(locale, options).format(num);\n}\n","import {isArray} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {log10} from '../helpers/helpers.math.js';\n\n/**\n * Namespace to hold formatters for different types of ticks\n * @namespace Chart.Ticks.formatters\n */\nconst formatters = {\n  /**\n   * Formatter for value labels\n   * @method Chart.Ticks.formatters.values\n   * @param value the value to display\n   * @return {string|string[]} the label to display\n   */\n  values(value) {\n    return isArray(value) ? /** @type {string[]} */ (value) : '' + value;\n  },\n\n  /**\n   * Formatter for numeric ticks\n   * @method Chart.Ticks.formatters.numeric\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  numeric(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0'; // never show decimal places for 0\n    }\n\n    const locale = this.chart.options.locale;\n    let notation;\n    let delta = tickValue; // This is used when there are less than 2 ticks as the tick interval.\n\n    if (ticks.length > 1) {\n      // all ticks are small or there huge numbers; use scientific notation\n      const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));\n      if (maxTick < 1e-4 || maxTick > 1e+15) {\n        notation = 'scientific';\n      }\n\n      delta = calculateDelta(tickValue, ticks);\n    }\n\n    const logDelta = log10(Math.abs(delta));\n\n    // When datasets have values approaching Number.MAX_VALUE, the tick calculations might result in\n    // infinity and eventually NaN. Passing NaN for minimumFractionDigits or maximumFractionDigits\n    // will make the number formatter throw. So instead we check for isNaN and use a fallback value.\n    //\n    // toFixed has a max of 20 decimal places\n    const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);\n\n    const options = {notation, minimumFractionDigits: numDecimal, maximumFractionDigits: numDecimal};\n    Object.assign(options, this.options.ticks.format);\n\n    return formatNumber(tickValue, locale, options);\n  },\n\n\n  /**\n   * Formatter for logarithmic ticks\n   * @method Chart.Ticks.formatters.logarithmic\n   * @param tickValue {number} the value to be formatted\n   * @param index {number} the position of the tickValue parameter in the ticks array\n   * @param ticks {object[]} the list of ticks being converted\n   * @return {string} string representation of the tickValue parameter\n   */\n  logarithmic(tickValue, index, ticks) {\n    if (tickValue === 0) {\n      return '0';\n    }\n    const remain = ticks[index].significand || (tickValue / (Math.pow(10, Math.floor(log10(tickValue)))));\n    if ([1, 2, 3, 5, 10, 15].includes(remain) || index > 0.8 * ticks.length) {\n      return formatters.numeric.call(this, tickValue, index, ticks);\n    }\n    return '';\n  }\n\n};\n\n\nfunction calculateDelta(tickValue, ticks) {\n  // Figure out how many digits to show\n  // The space between the first two ticks might be smaller than normal spacing\n  let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;\n\n  // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n  if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) {\n    // not an integer\n    delta = tickValue - Math.floor(tickValue);\n  }\n  return delta;\n}\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nexport default {formatters};\n","import {getHoverColor} from '../helpers/helpers.color.js';\nimport {isObject, merge, valueOrDefault} from '../helpers/helpers.core.js';\nimport {applyAnimationsDefaults} from './core.animations.defaults.js';\nimport {applyLayoutsDefaults} from './core.layouts.defaults.js';\nimport {applyScaleDefaults} from './core.scale.defaults.js';\n\nexport const overrides = Object.create(null);\nexport const descriptors = Object.create(null);\n\n/**\n * @param {object} node\n * @param {string} key\n * @return {object}\n */\nfunction getScope(node, key) {\n  if (!key) {\n    return node;\n  }\n  const keys = key.split('.');\n  for (let i = 0, n = keys.length; i < n; ++i) {\n    const k = keys[i];\n    node = node[k] || (node[k] = Object.create(null));\n  }\n  return node;\n}\n\nfunction set(root, scope, values) {\n  if (typeof scope === 'string') {\n    return merge(getScope(root, scope), values);\n  }\n  return merge(getScope(root, ''), scope);\n}\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Defaults {\n  constructor(_descriptors, _appliers) {\n    this.animation = undefined;\n    this.backgroundColor = 'rgba(0,0,0,0.1)';\n    this.borderColor = 'rgba(0,0,0,0.1)';\n    this.color = '#666';\n    this.datasets = {};\n    this.devicePixelRatio = (context) => context.chart.platform.getDevicePixelRatio();\n    this.elements = {};\n    this.events = [\n      'mousemove',\n      'mouseout',\n      'click',\n      'touchstart',\n      'touchmove'\n    ];\n    this.font = {\n      family: \"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\",\n      size: 12,\n      style: 'normal',\n      lineHeight: 1.2,\n      weight: null\n    };\n    this.hover = {};\n    this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);\n    this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);\n    this.hoverColor = (ctx, options) => getHoverColor(options.color);\n    this.indexAxis = 'x';\n    this.interaction = {\n      mode: 'nearest',\n      intersect: true,\n      includeInvisible: false\n    };\n    this.maintainAspectRatio = true;\n    this.onHover = null;\n    this.onClick = null;\n    this.parsing = true;\n    this.plugins = {};\n    this.responsive = true;\n    this.scale = undefined;\n    this.scales = {};\n    this.showLine = true;\n    this.drawActiveElementsOnTop = true;\n\n    this.describe(_descriptors);\n    this.apply(_appliers);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  set(scope, values) {\n    return set(this, scope, values);\n  }\n\n  /**\n\t * @param {string} scope\n\t */\n  get(scope) {\n    return getScope(this, scope);\n  }\n\n  /**\n\t * @param {string|object} scope\n\t * @param {object} [values]\n\t */\n  describe(scope, values) {\n    return set(descriptors, scope, values);\n  }\n\n  override(scope, values) {\n    return set(overrides, scope, values);\n  }\n\n  /**\n\t * Routes the named defaults to fallback to another scope/name.\n\t * This routing is useful when those target values, like defaults.color, are changed runtime.\n\t * If the values would be copied, the runtime change would not take effect. By routing, the\n\t * fallback is evaluated at each access, so its always up to date.\n\t *\n\t * Example:\n\t *\n\t * \tdefaults.route('elements.arc', 'backgroundColor', '', 'color')\n\t *   - reads the backgroundColor from defaults.color when undefined locally\n\t *\n\t * @param {string} scope Scope this route applies to.\n\t * @param {string} name Property name that should be routed to different namespace when not defined here.\n\t * @param {string} targetScope The namespace where those properties should be routed to.\n\t * Empty string ('') is the root of defaults.\n\t * @param {string} targetName The target name in the target scope the property should be routed to.\n\t */\n  route(scope, name, targetScope, targetName) {\n    const scopeObject = getScope(this, scope);\n    const targetScopeObject = getScope(this, targetScope);\n    const privateName = '_' + name;\n\n    Object.defineProperties(scopeObject, {\n      // A private property is defined to hold the actual value, when this property is set in its scope (set in the setter)\n      [privateName]: {\n        value: scopeObject[name],\n        writable: true\n      },\n      // The actual property is defined as getter/setter so we can do the routing when value is not locally set.\n      [name]: {\n        enumerable: true,\n        get() {\n          const local = this[privateName];\n          const target = targetScopeObject[targetName];\n          if (isObject(local)) {\n            return Object.assign({}, target, local);\n          }\n          return valueOrDefault(local, target);\n        },\n        set(value) {\n          this[privateName] = value;\n        }\n      }\n    });\n  }\n\n  apply(appliers) {\n    appliers.forEach((apply) => apply(this));\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Defaults({\n  _scriptable: (name) => !name.startsWith('on'),\n  _indexable: (name) => name !== 'events',\n  hover: {\n    _fallback: 'interaction'\n  },\n  interaction: {\n    _scriptable: false,\n    _indexable: false,\n  }\n}, [applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults]);\n","export function applyLayoutsDefaults(defaults) {\n  defaults.set('layout', {\n    autoPadding: true,\n    padding: {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    }\n  });\n}\n","import Ticks from './core.ticks.js';\n\nexport function applyScaleDefaults(defaults) {\n  defaults.set('scale', {\n    display: true,\n    offset: false,\n    reverse: false,\n    beginAtZero: false,\n\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 3.0.0\n     */\n    bounds: 'ticks',\n\n    clip: true,\n\n    /**\n     * Addition grace added to max and reduced from min data value.\n     * @since 3.0.0\n     */\n    grace: 0,\n\n    // grid line settings\n    grid: {\n      display: true,\n      lineWidth: 1,\n      drawOnChartArea: true,\n      drawTicks: true,\n      tickLength: 8,\n      tickWidth: (_ctx, options) => options.lineWidth,\n      tickColor: (_ctx, options) => options.color,\n      offset: false,\n    },\n\n    border: {\n      display: true,\n      dash: [],\n      dashOffset: 0.0,\n      width: 1\n    },\n\n    // scale title\n    title: {\n      // display property\n      display: false,\n\n      // actual label\n      text: '',\n\n      // top/bottom padding\n      padding: {\n        top: 4,\n        bottom: 4\n      }\n    },\n\n    // label settings\n    ticks: {\n      minRotation: 0,\n      maxRotation: 50,\n      mirror: false,\n      textStrokeWidth: 0,\n      textStrokeColor: '',\n      padding: 3,\n      display: true,\n      autoSkip: true,\n      autoSkipPadding: 3,\n      labelOffset: 0,\n      // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n      callback: Ticks.formatters.values,\n      minor: {},\n      major: {},\n      align: 'center',\n      crossAlign: 'near',\n\n      showLabelBackdrop: false,\n      backdropColor: 'rgba(255, 255, 255, 0.75)',\n      backdropPadding: 2,\n    }\n  });\n\n  defaults.route('scale.ticks', 'color', '', 'color');\n  defaults.route('scale.grid', 'color', '', 'borderColor');\n  defaults.route('scale.border', 'color', '', 'borderColor');\n  defaults.route('scale.title', 'color', '', 'color');\n\n  defaults.describe('scale', {\n    _fallback: false,\n    _scriptable: (name) => !name.startsWith('before') && !name.startsWith('after') && name !== 'callback' && name !== 'parser',\n    _indexable: (name) => name !== 'borderDash' && name !== 'tickBorderDash' && name !== 'dash',\n  });\n\n  defaults.describe('scales', {\n    _fallback: 'scale',\n  });\n\n  defaults.describe('scale.ticks', {\n    _scriptable: (name) => name !== 'backdropPadding' && name !== 'callback',\n    _indexable: (name) => name !== 'backdropPadding',\n  });\n}\n","import type {\n  Chart,\n  Point,\n  FontSpec,\n  CanvasFontSpec,\n  PointStyle,\n  RenderTextOpts,\n  BackdropOptions\n} from '../types/index.js';\nimport type {\n  TRBL,\n  SplinePoint,\n  RoundedRect,\n  TRBLCorners\n} from '../types/geometric.js';\nimport {isArray, isNullOrUndef} from './helpers.core.js';\nimport {PI, TAU, HALF_PI, QUARTER_PI, TWO_THIRDS_PI, RAD_PER_DEG} from './helpers.math.js';\n\n/**\n * Converts the given font object into a CSS font string.\n * @param font - A font object.\n * @return The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font\n * @private\n */\nexport function toFontString(font: FontSpec) {\n  if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) {\n    return null;\n  }\n\n  return (font.style ? font.style + ' ' : '')\n\t\t+ (font.weight ? font.weight + ' ' : '')\n\t\t+ font.size + 'px '\n\t\t+ font.family;\n}\n\n/**\n * @private\n */\nexport function _measureText(\n  ctx: CanvasRenderingContext2D,\n  data: Record<string, number>,\n  gc: string[],\n  longest: number,\n  string: string\n) {\n  let textWidth = data[string];\n  if (!textWidth) {\n    textWidth = data[string] = ctx.measureText(string).width;\n    gc.push(string);\n  }\n  if (textWidth > longest) {\n    longest = textWidth;\n  }\n  return longest;\n}\n\ntype Thing = string | undefined | null\ntype Things = (Thing | Thing[])[]\n\n/**\n * @private\n */\n// eslint-disable-next-line complexity\nexport function _longestText(\n  ctx: CanvasRenderingContext2D,\n  font: string,\n  arrayOfThings: Things,\n  cache?: {data?: Record<string, number>, garbageCollect?: string[], font?: string}\n) {\n  cache = cache || {};\n  let data = cache.data = cache.data || {};\n  let gc = cache.garbageCollect = cache.garbageCollect || [];\n\n  if (cache.font !== font) {\n    data = cache.data = {};\n    gc = cache.garbageCollect = [];\n    cache.font = font;\n  }\n\n  ctx.save();\n\n  ctx.font = font;\n  let longest = 0;\n  const ilen = arrayOfThings.length;\n  let i: number, j: number, jlen: number, thing: Thing | Thing[], nestedThing: Thing | Thing[];\n  for (i = 0; i < ilen; i++) {\n    thing = arrayOfThings[i];\n\n    // Undefined strings and arrays should not be measured\n    if (thing !== undefined && thing !== null && !isArray(thing)) {\n      longest = _measureText(ctx, data, gc, longest, thing);\n    } else if (isArray(thing)) {\n      // if it is an array lets measure each element\n      // to do maybe simplify this function a bit so we can do this more recursively?\n      for (j = 0, jlen = thing.length; j < jlen; j++) {\n        nestedThing = thing[j];\n        // Undefined strings and arrays should not be measured\n        if (nestedThing !== undefined && nestedThing !== null && !isArray(nestedThing)) {\n          longest = _measureText(ctx, data, gc, longest, nestedThing);\n        }\n      }\n    }\n  }\n\n  ctx.restore();\n\n  const gcLen = gc.length / 2;\n  if (gcLen > arrayOfThings.length) {\n    for (i = 0; i < gcLen; i++) {\n      delete data[gc[i]];\n    }\n    gc.splice(0, gcLen);\n  }\n  return longest;\n}\n\n/**\n * Returns the aligned pixel value to avoid anti-aliasing blur\n * @param chart - The chart instance.\n * @param pixel - A pixel value.\n * @param width - The width of the element.\n * @returns The aligned pixel value.\n * @private\n */\nexport function _alignPixel(chart: Chart, pixel: number, width: number) {\n  const devicePixelRatio = chart.currentDevicePixelRatio;\n  const halfWidth = width !== 0 ? Math.max(width / 2, 0.5) : 0;\n  return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;\n}\n\n/**\n * Clears the entire canvas.\n */\nexport function clearCanvas(canvas: HTMLCanvasElement, ctx?: CanvasRenderingContext2D) {\n  ctx = ctx || canvas.getContext('2d');\n\n  ctx.save();\n  // canvas.width and canvas.height do not consider the canvas transform,\n  // while clearRect does\n  ctx.resetTransform();\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n  ctx.restore();\n}\n\nexport interface DrawPointOptions {\n  pointStyle: PointStyle;\n  rotation?: number;\n  radius: number;\n  borderWidth: number;\n}\n\nexport function drawPoint(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number\n) {\n  // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  drawPointLegend(ctx, options, x, y, null);\n}\n\n// eslint-disable-next-line complexity\nexport function drawPointLegend(\n  ctx: CanvasRenderingContext2D,\n  options: DrawPointOptions,\n  x: number,\n  y: number,\n  w: number\n) {\n  let type: string, xOffset: number, yOffset: number, size: number, cornerRadius: number, width: number, xOffsetW: number, yOffsetW: number;\n  const style = options.pointStyle;\n  const rotation = options.rotation;\n  const radius = options.radius;\n  let rad = (rotation || 0) * RAD_PER_DEG;\n\n  if (style && typeof style === 'object') {\n    type = style.toString();\n    if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.rotate(rad);\n      ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);\n      ctx.restore();\n      return;\n    }\n  }\n\n  if (isNaN(radius) || radius <= 0) {\n    return;\n  }\n\n  ctx.beginPath();\n\n  switch (style) {\n  // Default includes circle\n    default:\n      if (w) {\n        ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU);\n      } else {\n        ctx.arc(x, y, radius, 0, TAU);\n      }\n      ctx.closePath();\n      break;\n    case 'triangle':\n      width = w ? w / 2 : radius;\n      ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      rad += TWO_THIRDS_PI;\n      ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);\n      ctx.closePath();\n      break;\n    case 'rectRounded':\n    // NOTE: the rounded rect implementation changed to use `arc` instead of\n    // `quadraticCurveTo` since it generates better results when rect is\n    // almost a circle. 0.516 (instead of 0.5) produces results with visually\n    // closer proportion to the previous impl and it is inscribed in the\n    // circle with `radius`. For more details, see the following PRs:\n    // https://github.com/chartjs/Chart.js/issues/5597\n    // https://github.com/chartjs/Chart.js/issues/5858\n      cornerRadius = radius * 0.516;\n      size = radius - cornerRadius;\n      xOffset = Math.cos(rad + QUARTER_PI) * size;\n      xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      yOffset = Math.sin(rad + QUARTER_PI) * size;\n      yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);\n      ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);\n      ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);\n      ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);\n      ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);\n      ctx.closePath();\n      break;\n    case 'rect':\n      if (!rotation) {\n        size = Math.SQRT1_2 * radius;\n        width = w ? w / 2 : size;\n        ctx.rect(x - width, y - size, 2 * width, 2 * size);\n        break;\n      }\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'rectRot':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      ctx.closePath();\n      break;\n    case 'crossRot':\n      rad += QUARTER_PI;\n    /* falls through */\n    case 'cross':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'star':\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      rad += QUARTER_PI;\n      xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);\n      xOffset = Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);\n      ctx.moveTo(x - xOffsetW, y - yOffset);\n      ctx.lineTo(x + xOffsetW, y + yOffset);\n      ctx.moveTo(x + yOffsetW, y - xOffset);\n      ctx.lineTo(x - yOffsetW, y + xOffset);\n      break;\n    case 'line':\n      xOffset = w ? w / 2 : Math.cos(rad) * radius;\n      yOffset = Math.sin(rad) * radius;\n      ctx.moveTo(x - xOffset, y - yOffset);\n      ctx.lineTo(x + xOffset, y + yOffset);\n      break;\n    case 'dash':\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);\n      break;\n    case false:\n      ctx.closePath();\n      break;\n  }\n\n  ctx.fill();\n  if (options.borderWidth > 0) {\n    ctx.stroke();\n  }\n}\n\n/**\n * Returns true if the point is inside the rectangle\n * @param point - The point to test\n * @param area - The rectangle\n * @param margin - allowed margin\n * @private\n */\nexport function _isPointInArea(\n  point: Point,\n  area: TRBL,\n  margin?: number\n) {\n  margin = margin || 0.5; // margin - default is to match rounded decimals\n\n  return !area || (point && point.x > area.left - margin && point.x < area.right + margin &&\n\t\tpoint.y > area.top - margin && point.y < area.bottom + margin);\n}\n\nexport function clipArea(ctx: CanvasRenderingContext2D, area: TRBL) {\n  ctx.save();\n  ctx.beginPath();\n  ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);\n  ctx.clip();\n}\n\nexport function unclipArea(ctx: CanvasRenderingContext2D) {\n  ctx.restore();\n}\n\n/**\n * @private\n */\nexport function _steppedLineTo(\n  ctx: CanvasRenderingContext2D,\n  previous: Point,\n  target: Point,\n  flip?: boolean,\n  mode?: string\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  if (mode === 'middle') {\n    const midpoint = (previous.x + target.x) / 2.0;\n    ctx.lineTo(midpoint, previous.y);\n    ctx.lineTo(midpoint, target.y);\n  } else if (mode === 'after' !== !!flip) {\n    ctx.lineTo(previous.x, target.y);\n  } else {\n    ctx.lineTo(target.x, previous.y);\n  }\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @private\n */\nexport function _bezierCurveTo(\n  ctx: CanvasRenderingContext2D,\n  previous: SplinePoint,\n  target: SplinePoint,\n  flip?: boolean\n) {\n  if (!previous) {\n    return ctx.lineTo(target.x, target.y);\n  }\n  ctx.bezierCurveTo(\n    flip ? previous.cp1x : previous.cp2x,\n    flip ? previous.cp1y : previous.cp2y,\n    flip ? target.cp2x : target.cp1x,\n    flip ? target.cp2y : target.cp1y,\n    target.x,\n    target.y);\n}\n\nfunction setRenderOpts(ctx: CanvasRenderingContext2D, opts: RenderTextOpts) {\n  if (opts.translation) {\n    ctx.translate(opts.translation[0], opts.translation[1]);\n  }\n\n  if (!isNullOrUndef(opts.rotation)) {\n    ctx.rotate(opts.rotation);\n  }\n\n  if (opts.color) {\n    ctx.fillStyle = opts.color;\n  }\n\n  if (opts.textAlign) {\n    ctx.textAlign = opts.textAlign;\n  }\n\n  if (opts.textBaseline) {\n    ctx.textBaseline = opts.textBaseline;\n  }\n}\n\nfunction decorateText(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  line: string,\n  opts: RenderTextOpts\n) {\n  if (opts.strikethrough || opts.underline) {\n    /**\n     * Now that IE11 support has been dropped, we can use more\n     * of the TextMetrics object. The actual bounding boxes\n     * are unflagged in Chrome, Firefox, Edge, and Safari so they\n     * can be safely used.\n     * See https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics#Browser_compatibility\n     */\n    const metrics = ctx.measureText(line);\n    const left = x - metrics.actualBoundingBoxLeft;\n    const right = x + metrics.actualBoundingBoxRight;\n    const top = y - metrics.actualBoundingBoxAscent;\n    const bottom = y + metrics.actualBoundingBoxDescent;\n    const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;\n\n    ctx.strokeStyle = ctx.fillStyle;\n    ctx.beginPath();\n    ctx.lineWidth = opts.decorationWidth || 2;\n    ctx.moveTo(left, yDecoration);\n    ctx.lineTo(right, yDecoration);\n    ctx.stroke();\n  }\n}\n\nfunction drawBackdrop(ctx: CanvasRenderingContext2D, opts: BackdropOptions) {\n  const oldColor = ctx.fillStyle;\n\n  ctx.fillStyle = opts.color as string;\n  ctx.fillRect(opts.left, opts.top, opts.width, opts.height);\n  ctx.fillStyle = oldColor;\n}\n\n/**\n * Render text onto the canvas\n */\nexport function renderText(\n  ctx: CanvasRenderingContext2D,\n  text: string | string[],\n  x: number,\n  y: number,\n  font: CanvasFontSpec,\n  opts: RenderTextOpts = {}\n) {\n  const lines = isArray(text) ? text : [text];\n  const stroke = opts.strokeWidth > 0 && opts.strokeColor !== '';\n  let i: number, line: string;\n\n  ctx.save();\n  ctx.font = font.string;\n  setRenderOpts(ctx, opts);\n\n  for (i = 0; i < lines.length; ++i) {\n    line = lines[i];\n\n    if (opts.backdrop) {\n      drawBackdrop(ctx, opts.backdrop);\n    }\n\n    if (stroke) {\n      if (opts.strokeColor) {\n        ctx.strokeStyle = opts.strokeColor;\n      }\n\n      if (!isNullOrUndef(opts.strokeWidth)) {\n        ctx.lineWidth = opts.strokeWidth;\n      }\n\n      ctx.strokeText(line, x, y, opts.maxWidth);\n    }\n\n    ctx.fillText(line, x, y, opts.maxWidth);\n    decorateText(ctx, x, y, line, opts);\n\n    y += Number(font.lineHeight);\n  }\n\n  ctx.restore();\n}\n\n/**\n * Add a path of a rectangle with rounded corners to the current sub-path\n * @param ctx - Context\n * @param rect - Bounding rect\n */\nexport function addRoundedRectPath(\n  ctx: CanvasRenderingContext2D,\n  rect: RoundedRect & { radius: TRBLCorners }\n) {\n  const {x, y, w, h, radius} = rect;\n\n  // top left arc\n  ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);\n\n  // line from top left to bottom left\n  ctx.lineTo(x, y + h - radius.bottomLeft);\n\n  // bottom left arc\n  ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);\n\n  // line from bottom left to bottom right\n  ctx.lineTo(x + w - radius.bottomRight, y + h);\n\n  // bottom right arc\n  ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);\n\n  // line from bottom right to top right\n  ctx.lineTo(x + w, y + radius.topRight);\n\n  // top right arc\n  ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);\n\n  // line from top right to top left\n  ctx.lineTo(x + radius.topLeft, y);\n}\n","import defaults from '../core/core.defaults.js';\nimport {isArray, isObject, toDimension, valueOrDefault} from './helpers.core.js';\nimport {toFontString} from './helpers.canvas.js';\nimport type {ChartArea, FontSpec, Point} from '../types/index.js';\nimport type {TRBL, TRBLCorners} from '../types/geometric.js';\n\nconst LINE_HEIGHT = /^(normal|(\\d+(?:\\.\\d+)?)(px|em|%)?)$/;\nconst FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;\n\n/**\n * @alias Chart.helpers.options\n * @namespace\n */\n/**\n * Converts the given line height `value` in pixels for a specific font `size`.\n * @param value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').\n * @param size - The font size (in pixels) used to resolve relative `value`.\n * @returns The effective line height in pixels (size * 1.2 if value is invalid).\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height\n * @since 2.7.0\n */\nexport function toLineHeight(value: number | string, size: number): number {\n  const matches = ('' + value).match(LINE_HEIGHT);\n  if (!matches || matches[1] === 'normal') {\n    return size * 1.2;\n  }\n\n  value = +matches[2];\n\n  switch (matches[3]) {\n    case 'px':\n      return value;\n    case '%':\n      value /= 100;\n      break;\n    default:\n      break;\n  }\n\n  return size * value;\n}\n\nconst numberOrZero = (v: unknown) => +v || 0;\n\n/**\n * @param value\n * @param props\n */\nexport function _readValueToProps<K extends string>(value: number | Record<K, number>, props: K[]): Record<K, number>;\nexport function _readValueToProps<K extends string, T extends string>(value: number | Record<K & T, number>, props: Record<T, K>): Record<T, number>;\nexport function _readValueToProps(value: number | Record<string, number>, props: string[] | Record<string, string>) {\n  const ret = {};\n  const objProps = isObject(props);\n  const keys = objProps ? Object.keys(props) : props;\n  const read = isObject(value)\n    ? objProps\n      ? prop => valueOrDefault(value[prop], value[props[prop]])\n      : prop => value[prop]\n    : () => value;\n\n  for (const prop of keys) {\n    ret[prop] = numberOrZero(read(prop));\n  }\n  return ret;\n}\n\n/**\n * Converts the given value into a TRBL object.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left)\n * @since 3.0.0\n */\nexport function toTRBL(value: number | TRBL | Point) {\n  return _readValueToProps(value, {top: 'y', right: 'x', bottom: 'y', left: 'x'});\n}\n\n/**\n * Converts the given value into a TRBL corners object (similar with css border-radius).\n * @param value - If a number, set the value to all TRBL corner components,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n * @returns The TRBL corner values (topLeft, topRight, bottomLeft, bottomRight)\n * @since 3.0.0\n */\nexport function toTRBLCorners(value: number | TRBLCorners) {\n  return _readValueToProps(value, ['topLeft', 'topRight', 'bottomLeft', 'bottomRight']);\n}\n\n/**\n * Converts the given value into a padding object with pre-computed width/height.\n * @param value - If a number, set the value to all TRBL component,\n *  else, if an object, use defined properties and sets undefined ones to 0.\n *  x / y are shorthands for same value for left/right and top/bottom.\n * @returns The padding values (top, right, bottom, left, width, height)\n * @since 2.7.0\n */\nexport function toPadding(value?: number | TRBL): ChartArea {\n  const obj = toTRBL(value) as ChartArea;\n\n  obj.width = obj.left + obj.right;\n  obj.height = obj.top + obj.bottom;\n\n  return obj;\n}\n\n/**\n * Parses font options and returns the font object.\n * @param options - A object that contains font options to be parsed.\n * @param fallback - A object that contains fallback font options.\n * @return The font object.\n * @private\n */\n\nexport function toFont(options: Partial<FontSpec>, fallback?: Partial<FontSpec>) {\n  options = options || {};\n  fallback = fallback || defaults.font as FontSpec;\n\n  let size = valueOrDefault(options.size, fallback.size);\n\n  if (typeof size === 'string') {\n    size = parseInt(size, 10);\n  }\n  let style = valueOrDefault(options.style, fallback.style);\n  if (style && !('' + style).match(FONT_STYLE)) {\n    console.warn('Invalid font style specified: \"' + style + '\"');\n    style = undefined;\n  }\n\n  const font = {\n    family: valueOrDefault(options.family, fallback.family),\n    lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),\n    size,\n    style,\n    weight: valueOrDefault(options.weight, fallback.weight),\n    string: ''\n  };\n\n  font.string = toFontString(font);\n  return font;\n}\n\n/**\n * Evaluates the given `inputs` sequentially and returns the first defined value.\n * @param inputs - An array of values, falling back to the last value.\n * @param context - If defined and the current value is a function, the value\n * is called with `context` as first argument and the result becomes the new input.\n * @param index - If defined and the current value is an array, the value\n * at `index` become the new input.\n * @param info - object to return information about resolution in\n * @param info.cacheable - Will be set to `false` if option is not cacheable.\n * @since 2.7.0\n */\nexport function resolve(inputs: Array<unknown>, context?: object, index?: number, info?: { cacheable: boolean }) {\n  let cacheable = true;\n  let i: number, ilen: number, value: unknown;\n\n  for (i = 0, ilen = inputs.length; i < ilen; ++i) {\n    value = inputs[i];\n    if (value === undefined) {\n      continue;\n    }\n    if (context !== undefined && typeof value === 'function') {\n      value = value(context);\n      cacheable = false;\n    }\n    if (index !== undefined && isArray(value)) {\n      value = value[index % value.length];\n      cacheable = false;\n    }\n    if (value !== undefined) {\n      if (info && !cacheable) {\n        info.cacheable = false;\n      }\n      return value;\n    }\n  }\n}\n\n/**\n * @param minmax\n * @param grace\n * @param beginAtZero\n * @private\n */\nexport function _addGrace(minmax: { min: number; max: number; }, grace: number | string, beginAtZero: boolean) {\n  const {min, max} = minmax;\n  const change = toDimension(grace, (max - min) / 2);\n  const keepZero = (value: number, add: number) => beginAtZero && value === 0 ? 0 : value + add;\n  return {\n    min: keepZero(min, -Math.abs(change)),\n    max: keepZero(max, change)\n  };\n}\n\n/**\n * Create a context inheriting parentContext\n * @param parentContext\n * @param context\n * @returns\n */\nexport function createContext<T extends object>(parentContext: null, context: T): T;\nexport function createContext<T extends object, P extends T>(parentContext: P, context: T): P & T;\nexport function createContext(parentContext: object, context: object) {\n  return Object.assign(Object.create(parentContext), context);\n}\n","/* eslint-disable @typescript-eslint/no-use-before-define */\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartMeta} from '../types/index.js';\nimport type {\n  ResolverObjectKey,\n  ResolverCache,\n  ResolverProxy,\n  DescriptorDefaults,\n  Descriptor,\n  ContextCache,\n  ContextProxy\n} from './helpers.config.types.js';\nimport {isArray, isFunction, isObject, resolveObjectKey, _capitalize} from './helpers.core.js';\n\nexport * from './helpers.config.types.js';\n\n/**\n * Creates a Proxy for resolving raw values for options.\n * @param scopes - The option scopes to look for values, in resolution order\n * @param prefixes - The prefixes for values, in resolution order.\n * @param rootScopes - The root option scopes\n * @param fallback - Parent scopes fallback\n * @param getTarget - callback for getting the target for changed values\n * @returns Proxy\n * @private\n */\nexport function _createResolver<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  scopes: T,\n  prefixes = [''],\n  rootScopes?: R,\n  fallback?: ResolverObjectKey,\n  getTarget = () => scopes[0]\n) {\n  const finalRootScopes = rootScopes || scopes;\n  if (typeof fallback === 'undefined') {\n    fallback = _resolve('_fallback', scopes);\n  }\n  const cache: ResolverCache<T, R> = {\n    [Symbol.toStringTag]: 'Object',\n    _cacheable: true,\n    _scopes: scopes,\n    _rootScopes: finalRootScopes,\n    _fallback: fallback,\n    _getTarget: getTarget,\n    override: (scope: AnyObject) => _createResolver([scope, ...scopes], prefixes, finalRootScopes, fallback),\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop: string) {\n      delete target[prop]; // remove from cache\n      delete target._keys; // remove cached keys\n      delete scopes[0][prop]; // remove from top level scope\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string) {\n      return _cached(target, prop,\n        () => _resolveWithPrefixes(prop, prefixes, scopes, target));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(scopes[0]);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop: string) {\n      return getKeysFromAllScopes(target).includes(prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys(target) {\n      return getKeysFromAllScopes(target);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop: string, value) {\n      const storage = target._storage || (target._storage = getTarget());\n      target[prop] = storage[prop] = value; // set to top level scope + cache\n      delete target._keys; // remove cached keys\n      return true;\n    }\n  }) as ResolverProxy<T, R>;\n}\n\n/**\n * Returns an Proxy for resolving option values with context.\n * @param proxy - The Proxy returned by `_createResolver`\n * @param context - Context object for scriptable/indexable options\n * @param subProxy - The proxy provided for scriptable options\n * @param descriptorDefaults - Defaults for descriptors\n * @private\n */\nexport function _attachContext<\n  T extends AnyObject[] = AnyObject[],\n  R extends AnyObject[] = T\n>(\n  proxy: ResolverProxy<T, R>,\n  context: AnyObject,\n  subProxy?: ResolverProxy<T, R>,\n  descriptorDefaults?: DescriptorDefaults\n) {\n  const cache: ContextCache<T, R> = {\n    _cacheable: false,\n    _proxy: proxy,\n    _context: context,\n    _subProxy: subProxy,\n    _stack: new Set(),\n    _descriptors: _descriptors(proxy, descriptorDefaults),\n    setContext: (ctx: AnyObject) => _attachContext(proxy, ctx, subProxy, descriptorDefaults),\n    override: (scope: AnyObject) => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)\n  };\n  return new Proxy(cache, {\n    /**\n     * A trap for the delete operator.\n     */\n    deleteProperty(target, prop) {\n      delete target[prop]; // remove from cache\n      delete proxy[prop]; // remove from proxy\n      return true;\n    },\n\n    /**\n     * A trap for getting property values.\n     */\n    get(target, prop: string, receiver) {\n      return _cached(target, prop,\n        () => _resolveWithContext(target, prop, receiver));\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyDescriptor.\n     * Also used by Object.hasOwnProperty.\n     */\n    getOwnPropertyDescriptor(target, prop) {\n      return target._descriptors.allKeys\n        ? Reflect.has(proxy, prop) ? {enumerable: true, configurable: true} : undefined\n        : Reflect.getOwnPropertyDescriptor(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getPrototypeOf.\n     */\n    getPrototypeOf() {\n      return Reflect.getPrototypeOf(proxy);\n    },\n\n    /**\n     * A trap for the in operator.\n     */\n    has(target, prop) {\n      return Reflect.has(proxy, prop);\n    },\n\n    /**\n     * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.\n     */\n    ownKeys() {\n      return Reflect.ownKeys(proxy);\n    },\n\n    /**\n     * A trap for setting property values.\n     */\n    set(target, prop, value) {\n      proxy[prop] = value; // set to proxy\n      delete target[prop]; // remove from cache\n      return true;\n    }\n  }) as ContextProxy<T, R>;\n}\n\n/**\n * @private\n */\nexport function _descriptors(\n  proxy: ResolverCache,\n  defaults: DescriptorDefaults = {scriptable: true, indexable: true}\n): Descriptor {\n  const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;\n  return {\n    allKeys: _allKeys,\n    scriptable: _scriptable,\n    indexable: _indexable,\n    isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,\n    isIndexable: isFunction(_indexable) ? _indexable : () => _indexable\n  };\n}\n\nconst readKey = (prefix: string, name: string) => prefix ? prefix + _capitalize(name) : name;\nconst needsSubResolver = (prop: string, value: unknown) => isObject(value) && prop !== 'adapters' &&\n  (Object.getPrototypeOf(value) === null || value.constructor === Object);\n\nfunction _cached(\n  target: AnyObject,\n  prop: string,\n  resolve: () => unknown\n) {\n  if (Object.prototype.hasOwnProperty.call(target, prop)) {\n    return target[prop];\n  }\n\n  const value = resolve();\n  // cache the resolved value\n  target[prop] = value;\n  return value;\n}\n\nfunction _resolveWithContext(\n  target: ContextCache,\n  prop: string,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n  let value = _proxy[prop]; // resolve from proxy\n\n  // resolve with context\n  if (isFunction(value) && descriptors.isScriptable(prop)) {\n    value = _resolveScriptable(prop, value, target, receiver);\n  }\n  if (isArray(value) && value.length) {\n    value = _resolveArray(prop, value, target, descriptors.isIndexable);\n  }\n  if (needsSubResolver(prop, value)) {\n    // if the resolved value is an object, create a sub resolver for it\n    value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);\n  }\n  return value;\n}\n\nfunction _resolveScriptable(\n  prop: string,\n  getValue: (ctx: AnyObject, sub: AnyObject) => unknown,\n  target: ContextCache,\n  receiver: AnyObject\n) {\n  const {_proxy, _context, _subProxy, _stack} = target;\n  if (_stack.has(prop)) {\n    throw new Error('Recursion detected: ' + Array.from(_stack).join('->') + '->' + prop);\n  }\n  _stack.add(prop);\n  let value = getValue(_context, _subProxy || receiver);\n  _stack.delete(prop);\n  if (needsSubResolver(prop, value)) {\n    // When scriptable option returns an object, create a resolver on that.\n    value = createSubResolver(_proxy._scopes, _proxy, prop, value);\n  }\n  return value;\n}\n\nfunction _resolveArray(\n  prop: string,\n  value: unknown[],\n  target: ContextCache,\n  isIndexable: (key: string) => boolean\n) {\n  const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;\n\n  if (typeof _context.index !== 'undefined' && isIndexable(prop)) {\n    return value[_context.index % value.length];\n  } else if (isObject(value[0])) {\n    // Array of objects, return array or resolvers\n    const arr = value;\n    const scopes = _proxy._scopes.filter(s => s !== arr);\n    value = [];\n    for (const item of arr) {\n      const resolver = createSubResolver(scopes, _proxy, prop, item);\n      value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));\n    }\n  }\n  return value;\n}\n\nfunction resolveFallback(\n  fallback: ResolverObjectKey | ((prop: ResolverObjectKey, value: unknown) => ResolverObjectKey),\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  return isFunction(fallback) ? fallback(prop, value) : fallback;\n}\n\nconst getScope = (key: ResolverObjectKey, parent: AnyObject) => key === true ? parent\n  : typeof key === 'string' ? resolveObjectKey(parent, key) : undefined;\n\nfunction addScopes(\n  set: Set<AnyObject>,\n  parentScopes: AnyObject[],\n  key: ResolverObjectKey,\n  parentFallback: ResolverObjectKey,\n  value: unknown\n) {\n  for (const parent of parentScopes) {\n    const scope = getScope(key, parent);\n    if (scope) {\n      set.add(scope);\n      const fallback = resolveFallback(scope._fallback, key, value);\n      if (typeof fallback !== 'undefined' && fallback !== key && fallback !== parentFallback) {\n        // When we reach the descriptor that defines a new _fallback, return that.\n        // The fallback will resume to that new scope.\n        return fallback;\n      }\n    } else if (scope === false && typeof parentFallback !== 'undefined' && key !== parentFallback) {\n      // Fallback to `false` results to `false`, when falling back to different key.\n      // For example `interaction` from `hover` or `plugins.tooltip` and `animation` from `animations`\n      return null;\n    }\n  }\n  return false;\n}\n\nfunction createSubResolver(\n  parentScopes: AnyObject[],\n  resolver: ResolverCache,\n  prop: ResolverObjectKey,\n  value: unknown\n) {\n  const rootScopes = resolver._rootScopes;\n  const fallback = resolveFallback(resolver._fallback, prop, value);\n  const allScopes = [...parentScopes, ...rootScopes];\n  const set = new Set<AnyObject>();\n  set.add(value);\n  let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);\n  if (key === null) {\n    return false;\n  }\n  if (typeof fallback !== 'undefined' && fallback !== prop) {\n    key = addScopesFromKey(set, allScopes, fallback, key, value);\n    if (key === null) {\n      return false;\n    }\n  }\n  return _createResolver(Array.from(set), [''], rootScopes, fallback,\n    () => subGetTarget(resolver, prop as string, value));\n}\n\nfunction addScopesFromKey(\n  set: Set<AnyObject>,\n  allScopes: AnyObject[],\n  key: ResolverObjectKey,\n  fallback: ResolverObjectKey,\n  item: unknown\n) {\n  while (key) {\n    key = addScopes(set, allScopes, key, fallback, item);\n  }\n  return key;\n}\n\nfunction subGetTarget(\n  resolver: ResolverCache,\n  prop: string,\n  value: unknown\n) {\n  const parent = resolver._getTarget();\n  if (!(prop in parent)) {\n    parent[prop] = {};\n  }\n  const target = parent[prop];\n  if (isArray(target) && isObject(value)) {\n    // For array of objects, the object is used to store updated values\n    return value;\n  }\n  return target || {};\n}\n\nfunction _resolveWithPrefixes(\n  prop: string,\n  prefixes: string[],\n  scopes: AnyObject[],\n  proxy: ResolverProxy\n) {\n  let value: unknown;\n  for (const prefix of prefixes) {\n    value = _resolve(readKey(prefix, prop), scopes);\n    if (typeof value !== 'undefined') {\n      return needsSubResolver(prop, value)\n        ? createSubResolver(scopes, proxy, prop, value)\n        : value;\n    }\n  }\n}\n\nfunction _resolve(key: string, scopes: AnyObject[]) {\n  for (const scope of scopes) {\n    if (!scope) {\n      continue;\n    }\n    const value = scope[key];\n    if (typeof value !== 'undefined') {\n      return value;\n    }\n  }\n}\n\nfunction getKeysFromAllScopes(target: ResolverCache) {\n  let keys = target._keys;\n  if (!keys) {\n    keys = target._keys = resolveKeysFromAllScopes(target._scopes);\n  }\n  return keys;\n}\n\nfunction resolveKeysFromAllScopes(scopes: AnyObject[]) {\n  const set = new Set<string>();\n  for (const scope of scopes) {\n    for (const key of Object.keys(scope).filter(k => !k.startsWith('_'))) {\n      set.add(key);\n    }\n  }\n  return Array.from(set);\n}\n\nexport function _parseObjectDataRadialScale(\n  meta: ChartMeta<'line' | 'scatter'>,\n  data: AnyObject[],\n  start: number,\n  count: number\n) {\n  const {iScale} = meta;\n  const {key = 'r'} = this._parsing;\n  const parsed = new Array<{r: unknown}>(count);\n  let i: number, ilen: number, index: number, item: AnyObject;\n\n  for (i = 0, ilen = count; i < ilen; ++i) {\n    index = i + start;\n    item = data[index];\n    parsed[i] = {\n      r: iScale.parse(resolveObjectKey(item, key), index)\n    };\n  }\n  return parsed;\n}\n","import {almostEquals, distanceBetweenPoints, sign} from './helpers.math.js';\nimport {_isPointInArea} from './helpers.canvas.js';\nimport type {ChartArea} from '../types/index.js';\nimport type {SplinePoint} from '../types/geometric.js';\n\nconst EPSILON = Number.EPSILON || 1e-14;\n\ntype OptionalSplinePoint = SplinePoint | false\nconst getPoint = (points: SplinePoint[], i: number): OptionalSplinePoint => i < points.length && !points[i].skip && points[i];\nconst getValueAxis = (indexAxis: 'x' | 'y') => indexAxis === 'x' ? 'y' : 'x';\n\nexport function splineCurve(\n  firstPoint: SplinePoint,\n  middlePoint: SplinePoint,\n  afterPoint: SplinePoint,\n  t: number\n): {\n    previous: SplinePoint\n    next: SplinePoint\n  } {\n  // Props to Rob Spencer at scaled innovation for his post on splining between points\n  // http://scaledinnovation.com/analytics/splines/aboutSplines.html\n\n  // This function must also respect \"skipped\" points\n\n  const previous = firstPoint.skip ? middlePoint : firstPoint;\n  const current = middlePoint;\n  const next = afterPoint.skip ? middlePoint : afterPoint;\n  const d01 = distanceBetweenPoints(current, previous);\n  const d12 = distanceBetweenPoints(next, current);\n\n  let s01 = d01 / (d01 + d12);\n  let s12 = d12 / (d01 + d12);\n\n  // If all points are the same, s01 & s02 will be inf\n  s01 = isNaN(s01) ? 0 : s01;\n  s12 = isNaN(s12) ? 0 : s12;\n\n  const fa = t * s01; // scaling factor for triangle Ta\n  const fb = t * s12;\n\n  return {\n    previous: {\n      x: current.x - fa * (next.x - previous.x),\n      y: current.y - fa * (next.y - previous.y)\n    },\n    next: {\n      x: current.x + fb * (next.x - previous.x),\n      y: current.y + fb * (next.y - previous.y)\n    }\n  };\n}\n\n/**\n * Adjust tangents to ensure monotonic properties\n */\nfunction monotoneAdjust(points: SplinePoint[], deltaK: number[], mK: number[]) {\n  const pointsLen = points.length;\n\n  let alphaK: number, betaK: number, tauK: number, squaredMagnitude: number, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n  for (let i = 0; i < pointsLen - 1; ++i) {\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent || !pointAfter) {\n      continue;\n    }\n\n    if (almostEquals(deltaK[i], 0, EPSILON)) {\n      mK[i] = mK[i + 1] = 0;\n      continue;\n    }\n\n    alphaK = mK[i] / deltaK[i];\n    betaK = mK[i + 1] / deltaK[i];\n    squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);\n    if (squaredMagnitude <= 9) {\n      continue;\n    }\n\n    tauK = 3 / Math.sqrt(squaredMagnitude);\n    mK[i] = alphaK * tauK * deltaK[i];\n    mK[i + 1] = betaK * tauK * deltaK[i];\n  }\n}\n\nfunction monotoneCompute(points: SplinePoint[], mK: number[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  let delta: number, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (let i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    const iPixel = pointCurrent[indexAxis];\n    const vPixel = pointCurrent[valueAxis];\n    if (pointBefore) {\n      delta = (iPixel - pointBefore[indexAxis]) / 3;\n      pointCurrent[`cp1${indexAxis}`] = iPixel - delta;\n      pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];\n    }\n    if (pointAfter) {\n      delta = (pointAfter[indexAxis] - iPixel) / 3;\n      pointCurrent[`cp2${indexAxis}`] = iPixel + delta;\n      pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];\n    }\n  }\n}\n\n/**\n * This function calculates Bzier control points in a similar way than |splineCurve|,\n * but preserves monotonicity of the provided data and ensures no local extremums are added\n * between the dataset discrete points due to the interpolation.\n * See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation\n */\nexport function splineCurveMonotone(points: SplinePoint[], indexAxis: 'x' | 'y' = 'x') {\n  const valueAxis = getValueAxis(indexAxis);\n  const pointsLen = points.length;\n  const deltaK: number[] = Array(pointsLen).fill(0);\n  const mK: number[] = Array(pointsLen);\n\n  // Calculate slopes (deltaK) and initialize tangents (mK)\n  let i, pointBefore: OptionalSplinePoint, pointCurrent: OptionalSplinePoint;\n  let pointAfter = getPoint(points, 0);\n\n  for (i = 0; i < pointsLen; ++i) {\n    pointBefore = pointCurrent;\n    pointCurrent = pointAfter;\n    pointAfter = getPoint(points, i + 1);\n    if (!pointCurrent) {\n      continue;\n    }\n\n    if (pointAfter) {\n      const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];\n\n      // In the case of two points that appear at the same x pixel, slopeDeltaX is 0\n      deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;\n    }\n    mK[i] = !pointBefore ? deltaK[i]\n      : !pointAfter ? deltaK[i - 1]\n        : (sign(deltaK[i - 1]) !== sign(deltaK[i])) ? 0\n          : (deltaK[i - 1] + deltaK[i]) / 2;\n  }\n\n  monotoneAdjust(points, deltaK, mK);\n\n  monotoneCompute(points, mK, indexAxis);\n}\n\nfunction capControlPoint(pt: number, min: number, max: number) {\n  return Math.max(Math.min(pt, max), min);\n}\n\nfunction capBezierPoints(points: SplinePoint[], area: ChartArea) {\n  let i, ilen, point, inArea, inAreaPrev;\n  let inAreaNext = _isPointInArea(points[0], area);\n  for (i = 0, ilen = points.length; i < ilen; ++i) {\n    inAreaPrev = inArea;\n    inArea = inAreaNext;\n    inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);\n    if (!inArea) {\n      continue;\n    }\n    point = points[i];\n    if (inAreaPrev) {\n      point.cp1x = capControlPoint(point.cp1x, area.left, area.right);\n      point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);\n    }\n    if (inAreaNext) {\n      point.cp2x = capControlPoint(point.cp2x, area.left, area.right);\n      point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);\n    }\n  }\n}\n\n/**\n * @private\n */\nexport function _updateBezierControlPoints(\n  points: SplinePoint[],\n  options,\n  area: ChartArea,\n  loop: boolean,\n  indexAxis: 'x' | 'y'\n) {\n  let i: number, ilen: number, point: SplinePoint, controlPoints: ReturnType<typeof splineCurve>;\n\n  // Only consider points that are drawn in case the spanGaps option is used\n  if (options.spanGaps) {\n    points = points.filter((pt) => !pt.skip);\n  }\n\n  if (options.cubicInterpolationMode === 'monotone') {\n    splineCurveMonotone(points, indexAxis);\n  } else {\n    let prev = loop ? points[points.length - 1] : points[0];\n    for (i = 0, ilen = points.length; i < ilen; ++i) {\n      point = points[i];\n      controlPoints = splineCurve(\n        prev,\n        point,\n        points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen],\n        options.tension\n      );\n      point.cp1x = controlPoints.previous.x;\n      point.cp1y = controlPoints.previous.y;\n      point.cp2x = controlPoints.next.x;\n      point.cp2y = controlPoints.next.y;\n      prev = point;\n    }\n  }\n\n  if (options.capBezierPoints) {\n    capBezierPoints(points, area);\n  }\n}\n","import type {ChartArea, Scale} from '../types/index.js';\nimport type Chart from '../core/core.controller.js';\nimport type {ChartEvent} from '../types.js';\nimport {INFINITY} from './helpers.math.js';\n\n/**\n * Note: typedefs are auto-exported, so use a made-up `dom` namespace where\n * necessary to avoid duplicates with `export * from './helpers`; see\n * https://github.com/microsoft/TypeScript/issues/46011\n * @typedef { import('../core/core.controller.js').default } dom.Chart\n * @typedef { import('../../types').ChartEvent } ChartEvent\n */\n\n/**\n * @private\n */\nexport function _isDomSupported(): boolean {\n  return typeof window !== 'undefined' && typeof document !== 'undefined';\n}\n\n/**\n * @private\n */\nexport function _getParentNode(domNode: HTMLCanvasElement): HTMLCanvasElement {\n  let parent = domNode.parentNode;\n  if (parent && parent.toString() === '[object ShadowRoot]') {\n    parent = (parent as ShadowRoot).host;\n  }\n  return parent as HTMLCanvasElement;\n}\n\n/**\n * convert max-width/max-height values that may be percentages into a number\n * @private\n */\n\nfunction parseMaxStyle(styleValue: string | number, node: HTMLElement, parentProperty: string) {\n  let valueInPixels: number;\n  if (typeof styleValue === 'string') {\n    valueInPixels = parseInt(styleValue, 10);\n\n    if (styleValue.indexOf('%') !== -1) {\n      // percentage * size in dimension\n      valueInPixels = (valueInPixels / 100) * node.parentNode[parentProperty];\n    }\n  } else {\n    valueInPixels = styleValue;\n  }\n\n  return valueInPixels;\n}\n\nconst getComputedStyle = (element: HTMLElement): CSSStyleDeclaration =>\n  element.ownerDocument.defaultView.getComputedStyle(element, null);\n\nexport function getStyle(el: HTMLElement, property: string): string {\n  return getComputedStyle(el).getPropertyValue(property);\n}\n\nconst positions = ['top', 'right', 'bottom', 'left'];\nfunction getPositionedStyle(styles: CSSStyleDeclaration, style: string, suffix?: string): ChartArea {\n  const result = {} as ChartArea;\n  suffix = suffix ? '-' + suffix : '';\n  for (let i = 0; i < 4; i++) {\n    const pos = positions[i];\n    result[pos] = parseFloat(styles[style + '-' + pos + suffix]) || 0;\n  }\n  result.width = result.left + result.right;\n  result.height = result.top + result.bottom;\n  return result;\n}\n\nconst useOffsetPos = (x: number, y: number, target: HTMLElement | EventTarget) =>\n  (x > 0 || y > 0) && (!target || !(target as HTMLElement).shadowRoot);\n\n/**\n * @param e\n * @param canvas\n * @returns Canvas position\n */\nfunction getCanvasPosition(\n  e: Event | TouchEvent | MouseEvent,\n  canvas: HTMLCanvasElement\n): {\n    x: number;\n    y: number;\n    box: boolean;\n  } {\n  const touches = (e as TouchEvent).touches;\n  const source = (touches && touches.length ? touches[0] : e) as MouseEvent;\n  const {offsetX, offsetY} = source as MouseEvent;\n  let box = false;\n  let x, y;\n  if (useOffsetPos(offsetX, offsetY, e.target)) {\n    x = offsetX;\n    y = offsetY;\n  } else {\n    const rect = canvas.getBoundingClientRect();\n    x = source.clientX - rect.left;\n    y = source.clientY - rect.top;\n    box = true;\n  }\n  return {x, y, box};\n}\n\n/**\n * Gets an event's x, y coordinates, relative to the chart area\n * @param event\n * @param chart\n * @returns x and y coordinates of the event\n */\n\nexport function getRelativePosition(\n  event: Event | ChartEvent | TouchEvent | MouseEvent,\n  chart: Chart\n): { x: number; y: number } {\n  if ('native' in event) {\n    return event;\n  }\n\n  const {canvas, currentDevicePixelRatio} = chart;\n  const style = getComputedStyle(canvas);\n  const borderBox = style.boxSizing === 'border-box';\n  const paddings = getPositionedStyle(style, 'padding');\n  const borders = getPositionedStyle(style, 'border', 'width');\n  const {x, y, box} = getCanvasPosition(event, canvas);\n  const xOffset = paddings.left + (box && borders.left);\n  const yOffset = paddings.top + (box && borders.top);\n\n  let {width, height} = chart;\n  if (borderBox) {\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  return {\n    x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),\n    y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)\n  };\n}\n\nfunction getContainerSize(canvas: HTMLCanvasElement, width: number, height: number): Partial<Scale> {\n  let maxWidth: number, maxHeight: number;\n\n  if (width === undefined || height === undefined) {\n    const container = _getParentNode(canvas);\n    if (!container) {\n      width = canvas.clientWidth;\n      height = canvas.clientHeight;\n    } else {\n      const rect = container.getBoundingClientRect(); // this is the border box of the container\n      const containerStyle = getComputedStyle(container);\n      const containerBorder = getPositionedStyle(containerStyle, 'border', 'width');\n      const containerPadding = getPositionedStyle(containerStyle, 'padding');\n      width = rect.width - containerPadding.width - containerBorder.width;\n      height = rect.height - containerPadding.height - containerBorder.height;\n      maxWidth = parseMaxStyle(containerStyle.maxWidth, container, 'clientWidth');\n      maxHeight = parseMaxStyle(containerStyle.maxHeight, container, 'clientHeight');\n    }\n  }\n  return {\n    width,\n    height,\n    maxWidth: maxWidth || INFINITY,\n    maxHeight: maxHeight || INFINITY\n  };\n}\n\nconst round1 = (v: number) => Math.round(v * 10) / 10;\n\n// eslint-disable-next-line complexity\nexport function getMaximumSize(\n  canvas: HTMLCanvasElement,\n  bbWidth?: number,\n  bbHeight?: number,\n  aspectRatio?: number\n): { width: number; height: number } {\n  const style = getComputedStyle(canvas);\n  const margins = getPositionedStyle(style, 'margin');\n  const maxWidth = parseMaxStyle(style.maxWidth, canvas, 'clientWidth') || INFINITY;\n  const maxHeight = parseMaxStyle(style.maxHeight, canvas, 'clientHeight') || INFINITY;\n  const containerSize = getContainerSize(canvas, bbWidth, bbHeight);\n  let {width, height} = containerSize;\n\n  if (style.boxSizing === 'content-box') {\n    const borders = getPositionedStyle(style, 'border', 'width');\n    const paddings = getPositionedStyle(style, 'padding');\n    width -= paddings.width + borders.width;\n    height -= paddings.height + borders.height;\n  }\n  width = Math.max(0, width - margins.width);\n  height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);\n  width = round1(Math.min(width, maxWidth, containerSize.maxWidth));\n  height = round1(Math.min(height, maxHeight, containerSize.maxHeight));\n  if (width && !height) {\n    // https://github.com/chartjs/Chart.js/issues/4659\n    // If the canvas has width, but no height, default to aspectRatio of 2 (canvas default)\n    height = round1(width / 2);\n  }\n\n  const maintainHeight = bbWidth !== undefined || bbHeight !== undefined;\n\n  if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {\n    height = containerSize.height;\n    width = round1(Math.floor(height * aspectRatio));\n  }\n\n  return {width, height};\n}\n\n/**\n * @param chart\n * @param forceRatio\n * @param forceStyle\n * @returns True if the canvas context size or transformation has changed.\n */\nexport function retinaScale(\n  chart: Chart,\n  forceRatio: number,\n  forceStyle?: boolean\n): boolean | void {\n  const pixelRatio = forceRatio || 1;\n  const deviceHeight = Math.floor(chart.height * pixelRatio);\n  const deviceWidth = Math.floor(chart.width * pixelRatio);\n\n  chart.height = Math.floor(chart.height);\n  chart.width = Math.floor(chart.width);\n\n  const canvas = chart.canvas;\n\n  // If no style has been set on the canvas, the render size is used as display size,\n  // making the chart visually bigger, so let's enforce it to the \"correct\" values.\n  // See https://github.com/chartjs/Chart.js/issues/3575\n  if (canvas.style && (forceStyle || (!canvas.style.height && !canvas.style.width))) {\n    canvas.style.height = `${chart.height}px`;\n    canvas.style.width = `${chart.width}px`;\n  }\n\n  if (chart.currentDevicePixelRatio !== pixelRatio\n      || canvas.height !== deviceHeight\n      || canvas.width !== deviceWidth) {\n    chart.currentDevicePixelRatio = pixelRatio;\n    canvas.height = deviceHeight;\n    canvas.width = deviceWidth;\n    chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\nexport const supportsEventListenerOptions = (function() {\n  let passiveSupported = false;\n  try {\n    const options = {\n      get passive() { // This function will be called when the browser attempts to access the passive property.\n        passiveSupported = true;\n        return false;\n      }\n    } as EventListenerOptions;\n\n    if (_isDomSupported()) {\n      window.addEventListener('test', null, options);\n      window.removeEventListener('test', null, options);\n    }\n  } catch (e) {\n    // continue regardless of error\n  }\n  return passiveSupported;\n}());\n\n/**\n * The \"used\" size is the final value of a dimension property after all calculations have\n * been performed. This method uses the computed style of `element` but returns undefined\n * if the computed style is not expressed in pixels. That can happen in some cases where\n * `element` has a size relative to its parent and this last one is not yet displayed,\n * for example because of `display: none` on a parent node.\n * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value\n * @returns Size in pixels or undefined if unknown.\n */\n\nexport function readUsedSize(\n  element: HTMLElement,\n  property: 'width' | 'height'\n): number | undefined {\n  const value = getStyle(element, property);\n  const matches = value && value.match(/^(\\d+)(\\.\\d+)?px$/);\n  return matches ? +matches[1] : undefined;\n}\n","import type {Point, SplinePoint} from '../types/geometric.js';\n\n/**\n * @private\n */\nexport function _pointInLine(p1: Point, p2: Point, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: p1.y + t * (p2.y - p1.y)\n  };\n}\n\n/**\n * @private\n */\nexport function _steppedInterpolation(\n  p1: Point,\n  p2: Point,\n  t: number, mode: 'middle' | 'after' | unknown\n) {\n  return {\n    x: p1.x + t * (p2.x - p1.x),\n    y: mode === 'middle' ? t < 0.5 ? p1.y : p2.y\n      : mode === 'after' ? t < 1 ? p1.y : p2.y\n        : t > 0 ? p2.y : p1.y\n  };\n}\n\n/**\n * @private\n */\nexport function _bezierInterpolation(p1: SplinePoint, p2: SplinePoint, t: number, mode?) { // eslint-disable-line @typescript-eslint/no-unused-vars\n  const cp1 = {x: p1.cp2x, y: p1.cp2y};\n  const cp2 = {x: p2.cp1x, y: p2.cp1y};\n  const a = _pointInLine(p1, cp1, t);\n  const b = _pointInLine(cp1, cp2, t);\n  const c = _pointInLine(cp2, p2, t);\n  const d = _pointInLine(a, b, t);\n  const e = _pointInLine(b, c, t);\n  return _pointInLine(d, e, t);\n}\n","export interface RTLAdapter {\n  x(x: number): number;\n  setWidth(w: number): void;\n  textAlign(align: 'center' | 'left' | 'right'): 'center' | 'left' | 'right';\n  xPlus(x: number, value: number): number;\n  leftForLtr(x: number, itemWidth: number): number;\n}\n\nconst getRightToLeftAdapter = function(rectX: number, width: number): RTLAdapter {\n  return {\n    x(x) {\n      return rectX + rectX + width - x;\n    },\n    setWidth(w) {\n      width = w;\n    },\n    textAlign(align) {\n      if (align === 'center') {\n        return align;\n      }\n      return align === 'right' ? 'left' : 'right';\n    },\n    xPlus(x, value) {\n      return x - value;\n    },\n    leftForLtr(x, itemWidth) {\n      return x - itemWidth;\n    },\n  };\n};\n\nconst getLeftToRightAdapter = function(): RTLAdapter {\n  return {\n    x(x) {\n      return x;\n    },\n    setWidth(w) { // eslint-disable-line no-unused-vars\n    },\n    textAlign(align) {\n      return align;\n    },\n    xPlus(x, value) {\n      return x + value;\n    },\n    leftForLtr(x, _itemWidth) { // eslint-disable-line @typescript-eslint/no-unused-vars\n      return x;\n    },\n  };\n};\n\nexport function getRtlAdapter(rtl: boolean, rectX: number, width: number) {\n  return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();\n}\n\nexport function overrideTextDirection(ctx: CanvasRenderingContext2D, direction: 'ltr' | 'rtl') {\n  let style: CSSStyleDeclaration, original: [string, string];\n  if (direction === 'ltr' || direction === 'rtl') {\n    style = ctx.canvas.style;\n    original = [\n      style.getPropertyValue('direction'),\n      style.getPropertyPriority('direction'),\n    ];\n\n    style.setProperty('direction', direction, 'important');\n    (ctx as { prevTextDirection?: [string, string] }).prevTextDirection = original;\n  }\n}\n\nexport function restoreTextDirection(ctx: CanvasRenderingContext2D, original?: [string, string]) {\n  if (original !== undefined) {\n    delete (ctx as { prevTextDirection?: [string, string] }).prevTextDirection;\n    ctx.canvas.style.setProperty('direction', original[0], original[1]);\n  }\n}\n","import {_angleBetween, _angleDiff, _isBetween, _normalizeAngle} from './helpers.math.js';\nimport {createContext} from './helpers.options.js';\nimport {isPatternOrGradient} from './helpers.color.js';\n\n/**\n * @typedef { import('../elements/element.line.js').default } LineElement\n * @typedef { import('../elements/element.point.js').default } PointElement\n * @typedef {{start: number, end: number, loop: boolean, style?: any}} Segment\n */\n\nfunction propertyFn(property) {\n  if (property === 'angle') {\n    return {\n      between: _angleBetween,\n      compare: _angleDiff,\n      normalize: _normalizeAngle,\n    };\n  }\n  return {\n    between: _isBetween,\n    compare: (a, b) => a - b,\n    normalize: x => x\n  };\n}\n\nfunction normalizeSegment({start, end, count, loop, style}) {\n  return {\n    start: start % count,\n    end: end % count,\n    loop: loop && (end - start + 1) % count === 0,\n    style\n  };\n}\n\nfunction getSegment(segment, points, bounds) {\n  const {property, start: startBound, end: endBound} = bounds;\n  const {between, normalize} = propertyFn(property);\n  const count = points.length;\n  // eslint-disable-next-line prefer-const\n  let {start, end, loop} = segment;\n  let i, ilen;\n\n  if (loop) {\n    start += count;\n    end += count;\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      if (!between(normalize(points[start % count][property]), startBound, endBound)) {\n        break;\n      }\n      start--;\n      end--;\n    }\n    start %= count;\n    end %= count;\n  }\n\n  if (end < start) {\n    end += count;\n  }\n  return {start, end, loop, style: segment.style};\n}\n\n/**\n * Returns the sub-segment(s) of a line segment that fall in the given bounds\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} [segment.style] - segment style\n * @param {PointElement[]} points - the points that this segment refers to\n * @param {object} [bounds]\n * @param {string} bounds.property - the property of a `PointElement` we are bounding. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the property\n * @param {number} bounds.end - end value of the property\n * @private\n **/\nexport function _boundSegment(segment, points, bounds) {\n  if (!bounds) {\n    return [segment];\n  }\n\n  const {property, start: startBound, end: endBound} = bounds;\n  const count = points.length;\n  const {compare, between, normalize} = propertyFn(property);\n  const {start, end, loop, style} = getSegment(segment, points, bounds);\n\n  const result = [];\n  let inside = false;\n  let subStart = null;\n  let value, point, prevValue;\n\n  const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;\n  const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);\n  const shouldStart = () => inside || startIsBefore();\n  const shouldStop = () => !inside || endIsBefore();\n\n  for (let i = start, prev = start; i <= end; ++i) {\n    point = points[i % count];\n\n    if (point.skip) {\n      continue;\n    }\n\n    value = normalize(point[property]);\n\n    if (value === prevValue) {\n      continue;\n    }\n\n    inside = between(value, startBound, endBound);\n\n    if (subStart === null && shouldStart()) {\n      subStart = compare(value, startBound) === 0 ? i : prev;\n    }\n\n    if (subStart !== null && shouldStop()) {\n      result.push(normalizeSegment({start: subStart, end: i, loop, count, style}));\n      subStart = null;\n    }\n    prev = i;\n    prevValue = value;\n  }\n\n  if (subStart !== null) {\n    result.push(normalizeSegment({start: subStart, end, loop, count, style}));\n  }\n\n  return result;\n}\n\n\n/**\n * Returns the segments of the line that are inside given bounds\n * @param {LineElement} line\n * @param {object} [bounds]\n * @param {string} bounds.property - the property we are bounding with. `x`, `y` or `angle`.\n * @param {number} bounds.start - start value of the `property`\n * @param {number} bounds.end - end value of the `property`\n * @private\n */\nexport function _boundSegments(line, bounds) {\n  const result = [];\n  const segments = line.segments;\n\n  for (let i = 0; i < segments.length; i++) {\n    const sub = _boundSegment(segments[i], line.points, bounds);\n    if (sub.length) {\n      result.push(...sub);\n    }\n  }\n  return result;\n}\n\n/**\n * Find start and end index of a line.\n */\nfunction findStartAndEnd(points, count, loop, spanGaps) {\n  let start = 0;\n  let end = count - 1;\n\n  if (loop && !spanGaps) {\n    // loop and not spanning gaps, first find a gap to start from\n    while (start < count && !points[start].skip) {\n      start++;\n    }\n  }\n\n  // find first non skipped point (after the first gap possibly)\n  while (start < count && points[start].skip) {\n    start++;\n  }\n\n  // if we looped to count, start needs to be 0\n  start %= count;\n\n  if (loop) {\n    // loop will go past count, if start > 0\n    end += start;\n  }\n\n  while (end > start && points[end % count].skip) {\n    end--;\n  }\n\n  // end could be more than count, normalize\n  end %= count;\n\n  return {start, end};\n}\n\n/**\n * Compute solid segments from Points, when spanGaps === false\n * @param {PointElement[]} points - the points\n * @param {number} start - start index\n * @param {number} max - max index (can go past count on a loop)\n * @param {boolean} loop - boolean indicating that this would be a loop if no gaps are found\n */\nfunction solidSegments(points, start, max, loop) {\n  const count = points.length;\n  const result = [];\n  let last = start;\n  let prev = points[start];\n  let end;\n\n  for (end = start + 1; end <= max; ++end) {\n    const cur = points[end % count];\n    if (cur.skip || cur.stop) {\n      if (!prev.skip) {\n        loop = false;\n        result.push({start: start % count, end: (end - 1) % count, loop});\n        // @ts-ignore\n        start = last = cur.stop ? end : null;\n      }\n    } else {\n      last = end;\n      if (prev.skip) {\n        start = end;\n      }\n    }\n    prev = cur;\n  }\n\n  if (last !== null) {\n    result.push({start: start % count, end: last % count, loop});\n  }\n\n  return result;\n}\n\n/**\n * Compute the continuous segments that define the whole line\n * There can be skipped points within a segment, if spanGaps is true.\n * @param {LineElement} line\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n * @private\n */\nexport function _computeSegments(line, segmentOptions) {\n  const points = line.points;\n  const spanGaps = line.options.spanGaps;\n  const count = points.length;\n\n  if (!count) {\n    return [];\n  }\n\n  const loop = !!line._loop;\n  const {start, end} = findStartAndEnd(points, count, loop, spanGaps);\n\n  if (spanGaps === true) {\n    return splitByStyles(line, [{start, end, loop}], points, segmentOptions);\n  }\n\n  const max = end < start ? end + count : end;\n  const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;\n  return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);\n}\n\n/**\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction splitByStyles(line, segments, points, segmentOptions) {\n  if (!segmentOptions || !segmentOptions.setContext || !points) {\n    return segments;\n  }\n  return doSplitByStyles(line, segments, points, segmentOptions);\n}\n\n/**\n * @param {LineElement} line\n * @param {Segment[]} segments\n * @param {PointElement[]} points\n * @param {object} [segmentOptions]\n * @return {Segment[]}\n */\nfunction doSplitByStyles(line, segments, points, segmentOptions) {\n  const chartContext = line._chart.getContext();\n  const baseStyle = readStyle(line.options);\n  const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;\n  const count = points.length;\n  const result = [];\n  let prevStyle = baseStyle;\n  let start = segments[0].start;\n  let i = start;\n\n  function addStyle(s, e, l, st) {\n    const dir = spanGaps ? -1 : 1;\n    if (s === e) {\n      return;\n    }\n    // Style can not start/end on a skipped point, adjust indices accordingly\n    s += count;\n    while (points[s % count].skip) {\n      s -= dir;\n    }\n    while (points[e % count].skip) {\n      e += dir;\n    }\n    if (s % count !== e % count) {\n      result.push({start: s % count, end: e % count, loop: l, style: st});\n      prevStyle = st;\n      start = e % count;\n    }\n  }\n\n  for (const segment of segments) {\n    start = spanGaps ? start : segment.start;\n    let prev = points[start % count];\n    let style;\n    for (i = start + 1; i <= segment.end; i++) {\n      const pt = points[i % count];\n      style = readStyle(segmentOptions.setContext(createContext(chartContext, {\n        type: 'segment',\n        p0: prev,\n        p1: pt,\n        p0DataIndex: (i - 1) % count,\n        p1DataIndex: i % count,\n        datasetIndex\n      })));\n      if (styleChanged(style, prevStyle)) {\n        addStyle(start, i - 1, segment.loop, prevStyle);\n      }\n      prev = pt;\n      prevStyle = style;\n    }\n    if (start < i - 1) {\n      addStyle(start, i - 1, segment.loop, prevStyle);\n    }\n  }\n\n  return result;\n}\n\nfunction readStyle(options) {\n  return {\n    backgroundColor: options.backgroundColor,\n    borderCapStyle: options.borderCapStyle,\n    borderDash: options.borderDash,\n    borderDashOffset: options.borderDashOffset,\n    borderJoinStyle: options.borderJoinStyle,\n    borderWidth: options.borderWidth,\n    borderColor: options.borderColor\n  };\n}\n\nfunction styleChanged(style, prevStyle) {\n  if (!prevStyle) {\n    return false;\n  }\n  const cache = [];\n  const replacer = function(key, value) {\n    if (!isPatternOrGradient(value)) {\n      return value;\n    }\n    if (!cache.includes(value)) {\n      cache.push(value);\n    }\n    return cache.indexOf(value);\n  };\n  return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);\n}\n","import {requestAnimFrame} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('./core.animation.js').default } Animation\n * @typedef { import('./core.controller.js').default } Chart\n */\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is export for typedoc\n */\nexport class Animator {\n  constructor() {\n    this._request = null;\n    this._charts = new Map();\n    this._running = false;\n    this._lastDate = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(chart, anims, date, type) {\n    const callbacks = anims.listeners[type];\n    const numSteps = anims.duration;\n\n    callbacks.forEach(fn => fn({\n      chart,\n      initial: anims.initial,\n      numSteps,\n      currentStep: Math.min(date - anims.start, numSteps)\n    }));\n  }\n\n  /**\n\t * @private\n\t */\n  _refresh() {\n    if (this._request) {\n      return;\n    }\n    this._running = true;\n\n    this._request = requestAnimFrame.call(window, () => {\n      this._update();\n      this._request = null;\n\n      if (this._running) {\n        this._refresh();\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _update(date = Date.now()) {\n    let remaining = 0;\n\n    this._charts.forEach((anims, chart) => {\n      if (!anims.running || !anims.items.length) {\n        return;\n      }\n      const items = anims.items;\n      let i = items.length - 1;\n      let draw = false;\n      let item;\n\n      for (; i >= 0; --i) {\n        item = items[i];\n\n        if (item._active) {\n          if (item._total > anims.duration) {\n            // if the animation has been updated and its duration prolonged,\n            // update to total duration of current animations run (for progress event)\n            anims.duration = item._total;\n          }\n          item.tick(date);\n          draw = true;\n        } else {\n          // Remove the item by replacing it with last item and removing the last\n          // A lot faster than splice.\n          items[i] = items[items.length - 1];\n          items.pop();\n        }\n      }\n\n      if (draw) {\n        chart.draw();\n        this._notify(chart, anims, date, 'progress');\n      }\n\n      if (!items.length) {\n        anims.running = false;\n        this._notify(chart, anims, date, 'complete');\n        anims.initial = false;\n      }\n\n      remaining += items.length;\n    });\n\n    this._lastDate = date;\n\n    if (remaining === 0) {\n      this._running = false;\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getAnims(chart) {\n    const charts = this._charts;\n    let anims = charts.get(chart);\n    if (!anims) {\n      anims = {\n        running: false,\n        initial: true,\n        items: [],\n        listeners: {\n          complete: [],\n          progress: []\n        }\n      };\n      charts.set(chart, anims);\n    }\n    return anims;\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} event - event name\n\t * @param {Function} cb - callback\n\t */\n  listen(chart, event, cb) {\n    this._getAnims(chart).listeners[event].push(cb);\n  }\n\n  /**\n\t * Add animations\n\t * @param {Chart} chart\n\t * @param {Animation[]} items - animations\n\t */\n  add(chart, items) {\n    if (!items || !items.length) {\n      return;\n    }\n    this._getAnims(chart).items.push(...items);\n  }\n\n  /**\n\t * Counts number of active animations for the chart\n\t * @param {Chart} chart\n\t */\n  has(chart) {\n    return this._getAnims(chart).items.length > 0;\n  }\n\n  /**\n\t * Start animating (all charts)\n\t * @param {Chart} chart\n\t */\n  start(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims) {\n      return;\n    }\n    anims.running = true;\n    anims.start = Date.now();\n    anims.duration = anims.items.reduce((acc, cur) => Math.max(acc, cur._duration), 0);\n    this._refresh();\n  }\n\n  running(chart) {\n    if (!this._running) {\n      return false;\n    }\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.running || !anims.items.length) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n\t * Stop all animations for the chart\n\t * @param {Chart} chart\n\t */\n  stop(chart) {\n    const anims = this._charts.get(chart);\n    if (!anims || !anims.items.length) {\n      return;\n    }\n    const items = anims.items;\n    let i = items.length - 1;\n\n    for (; i >= 0; --i) {\n      items[i].cancel();\n    }\n    anims.items = [];\n    this._notify(chart, anims, Date.now(), 'complete');\n  }\n\n  /**\n\t * Remove chart from Animator\n\t * @param {Chart} chart\n\t */\n  remove(chart) {\n    return this._charts.delete(chart);\n  }\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Animator();\n","import effects from '../helpers/helpers.easing.js';\nimport {resolve} from '../helpers/helpers.options.js';\nimport {color as helpersColor} from '../helpers/helpers.color.js';\n\nconst transparent = 'transparent';\nconst interpolators = {\n  boolean(from, to, factor) {\n    return factor > 0.5 ? to : from;\n  },\n  /**\n   * @param {string} from\n   * @param {string} to\n   * @param {number} factor\n   */\n  color(from, to, factor) {\n    const c0 = helpersColor(from || transparent);\n    const c1 = c0.valid && helpersColor(to || transparent);\n    return c1 && c1.valid\n      ? c1.mix(c0, factor).hexString()\n      : to;\n  },\n  number(from, to, factor) {\n    return from + (to - from) * factor;\n  }\n};\n\nexport default class Animation {\n  constructor(cfg, target, prop, to) {\n    const currentValue = target[prop];\n\n    to = resolve([cfg.to, to, currentValue, cfg.from]);\n    const from = resolve([cfg.from, currentValue, to]);\n\n    this._active = true;\n    this._fn = cfg.fn || interpolators[cfg.type || typeof from];\n    this._easing = effects[cfg.easing] || effects.linear;\n    this._start = Math.floor(Date.now() + (cfg.delay || 0));\n    this._duration = this._total = Math.floor(cfg.duration);\n    this._loop = !!cfg.loop;\n    this._target = target;\n    this._prop = prop;\n    this._from = from;\n    this._to = to;\n    this._promises = undefined;\n  }\n\n  active() {\n    return this._active;\n  }\n\n  update(cfg, to, date) {\n    if (this._active) {\n      this._notify(false);\n\n      const currentValue = this._target[this._prop];\n      const elapsed = date - this._start;\n      const remain = this._duration - elapsed;\n      this._start = date;\n      this._duration = Math.floor(Math.max(remain, cfg.duration));\n      this._total += elapsed;\n      this._loop = !!cfg.loop;\n      this._to = resolve([cfg.to, to, currentValue, cfg.from]);\n      this._from = resolve([cfg.from, currentValue, to]);\n    }\n  }\n\n  cancel() {\n    if (this._active) {\n      // update current evaluated value, for smoother animations\n      this.tick(Date.now());\n      this._active = false;\n      this._notify(false);\n    }\n  }\n\n  tick(date) {\n    const elapsed = date - this._start;\n    const duration = this._duration;\n    const prop = this._prop;\n    const from = this._from;\n    const loop = this._loop;\n    const to = this._to;\n    let factor;\n\n    this._active = from !== to && (loop || (elapsed < duration));\n\n    if (!this._active) {\n      this._target[prop] = to;\n      this._notify(true);\n      return;\n    }\n\n    if (elapsed < 0) {\n      this._target[prop] = from;\n      return;\n    }\n\n    factor = (elapsed / duration) % 2;\n    factor = loop && factor > 1 ? 2 - factor : factor;\n    factor = this._easing(Math.min(1, Math.max(0, factor)));\n\n    this._target[prop] = this._fn(from, to, factor);\n  }\n\n  wait() {\n    const promises = this._promises || (this._promises = []);\n    return new Promise((res, rej) => {\n      promises.push({res, rej});\n    });\n  }\n\n  _notify(resolved) {\n    const method = resolved ? 'res' : 'rej';\n    const promises = this._promises || [];\n    for (let i = 0; i < promises.length; i++) {\n      promises[i][method]();\n    }\n  }\n}\n","import animator from './core.animator.js';\nimport Animation from './core.animation.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isObject} from '../helpers/helpers.core.js';\n\nexport default class Animations {\n  constructor(chart, config) {\n    this._chart = chart;\n    this._properties = new Map();\n    this.configure(config);\n  }\n\n  configure(config) {\n    if (!isObject(config)) {\n      return;\n    }\n\n    const animationOptions = Object.keys(defaults.animation);\n    const animatedProps = this._properties;\n\n    Object.getOwnPropertyNames(config).forEach(key => {\n      const cfg = config[key];\n      if (!isObject(cfg)) {\n        return;\n      }\n      const resolved = {};\n      for (const option of animationOptions) {\n        resolved[option] = cfg[option];\n      }\n\n      (isArray(cfg.properties) && cfg.properties || [key]).forEach((prop) => {\n        if (prop === key || !animatedProps.has(prop)) {\n          animatedProps.set(prop, resolved);\n        }\n      });\n    });\n  }\n\n  /**\n\t * Utility to handle animation of `options`.\n\t * @private\n\t */\n  _animateOptions(target, values) {\n    const newOptions = values.options;\n    const options = resolveTargetOptions(target, newOptions);\n    if (!options) {\n      return [];\n    }\n\n    const animations = this._createAnimations(options, newOptions);\n    if (newOptions.$shared) {\n      // Going to shared options:\n      // After all animations are done, assign the shared options object to the element\n      // So any new updates to the shared options are observed\n      awaitAll(target.options.$animations, newOptions).then(() => {\n        target.options = newOptions;\n      }, () => {\n        // rejected, noop\n      });\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @private\n\t */\n  _createAnimations(target, values) {\n    const animatedProps = this._properties;\n    const animations = [];\n    const running = target.$animations || (target.$animations = {});\n    const props = Object.keys(values);\n    const date = Date.now();\n    let i;\n\n    for (i = props.length - 1; i >= 0; --i) {\n      const prop = props[i];\n      if (prop.charAt(0) === '$') {\n        continue;\n      }\n\n      if (prop === 'options') {\n        animations.push(...this._animateOptions(target, values));\n        continue;\n      }\n      const value = values[prop];\n      let animation = running[prop];\n      const cfg = animatedProps.get(prop);\n\n      if (animation) {\n        if (cfg && animation.active()) {\n          // There is an existing active animation, let's update that\n          animation.update(cfg, value, date);\n          continue;\n        } else {\n          animation.cancel();\n        }\n      }\n      if (!cfg || !cfg.duration) {\n        // not animated, set directly to new value\n        target[prop] = value;\n        continue;\n      }\n\n      running[prop] = animation = new Animation(cfg, target, prop, value);\n      animations.push(animation);\n    }\n    return animations;\n  }\n\n\n  /**\n\t * Update `target` properties to new values, using configured animations\n\t * @param {object} target - object to update\n\t * @param {object} values - new target properties\n\t * @returns {boolean|undefined} - `true` if animations were started\n\t **/\n  update(target, values) {\n    if (this._properties.size === 0) {\n      // Nothing is animated, just apply the new values.\n      Object.assign(target, values);\n      return;\n    }\n\n    const animations = this._createAnimations(target, values);\n\n    if (animations.length) {\n      animator.add(this._chart, animations);\n      return true;\n    }\n  }\n}\n\nfunction awaitAll(animations, properties) {\n  const running = [];\n  const keys = Object.keys(properties);\n  for (let i = 0; i < keys.length; i++) {\n    const anim = animations[keys[i]];\n    if (anim && anim.active()) {\n      running.push(anim.wait());\n    }\n  }\n  // @ts-ignore\n  return Promise.all(running);\n}\n\nfunction resolveTargetOptions(target, newOptions) {\n  if (!newOptions) {\n    return;\n  }\n  let options = target.options;\n  if (!options) {\n    target.options = newOptions;\n    return;\n  }\n  if (options.$shared) {\n    // Going from shared options to distinct one:\n    // Create new options object containing the old shared values and start updating that.\n    target.options = options = Object.assign({}, options, {$shared: false, $animations: {}});\n  }\n  return options;\n}\n","import Animations from './core.animations.js';\nimport defaults from './core.defaults.js';\nimport {isArray, isFinite, isObject, valueOrDefault, resolveObjectKey, defined} from '../helpers/helpers.core.js';\nimport {listenArrayEvents, unlistenArrayEvents} from '../helpers/helpers.collection.js';\nimport {createContext, sign} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('./core.scale.js').default } Scale\n */\n\nfunction scaleClip(scale, allowedOverflow) {\n  const opts = scale && scale.options || {};\n  const reverse = opts.reverse;\n  const min = opts.min === undefined ? allowedOverflow : 0;\n  const max = opts.max === undefined ? allowedOverflow : 0;\n  return {\n    start: reverse ? max : min,\n    end: reverse ? min : max\n  };\n}\n\nfunction defaultClip(xScale, yScale, allowedOverflow) {\n  if (allowedOverflow === false) {\n    return false;\n  }\n  const x = scaleClip(xScale, allowedOverflow);\n  const y = scaleClip(yScale, allowedOverflow);\n\n  return {\n    top: y.end,\n    right: x.end,\n    bottom: y.start,\n    left: x.start\n  };\n}\n\nfunction toClip(value) {\n  let t, r, b, l;\n\n  if (isObject(value)) {\n    t = value.top;\n    r = value.right;\n    b = value.bottom;\n    l = value.left;\n  } else {\n    t = r = b = l = value;\n  }\n\n  return {\n    top: t,\n    right: r,\n    bottom: b,\n    left: l,\n    disabled: value === false\n  };\n}\n\nfunction getSortedDatasetIndices(chart, filterVisible) {\n  const keys = [];\n  const metasets = chart._getSortedDatasetMetas(filterVisible);\n  let i, ilen;\n\n  for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n    keys.push(metasets[i].index);\n  }\n  return keys;\n}\n\nfunction applyStack(stack, value, dsIndex, options = {}) {\n  const keys = stack.keys;\n  const singleMode = options.mode === 'single';\n  let i, ilen, datasetIndex, otherValue;\n\n  if (value === null) {\n    return;\n  }\n\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    datasetIndex = +keys[i];\n    if (datasetIndex === dsIndex) {\n      if (options.all) {\n        continue;\n      }\n      break;\n    }\n    otherValue = stack.values[datasetIndex];\n    if (isFinite(otherValue) && (singleMode || (value === 0 || sign(value) === sign(otherValue)))) {\n      value += otherValue;\n    }\n  }\n  return value;\n}\n\nfunction convertObjectDataToArray(data) {\n  const keys = Object.keys(data);\n  const adata = new Array(keys.length);\n  let i, ilen, key;\n  for (i = 0, ilen = keys.length; i < ilen; ++i) {\n    key = keys[i];\n    adata[i] = {\n      x: key,\n      y: data[key]\n    };\n  }\n  return adata;\n}\n\nfunction isStacked(scale, meta) {\n  const stacked = scale && scale.options.stacked;\n  return stacked || (stacked === undefined && meta.stack !== undefined);\n}\n\nfunction getStackKey(indexScale, valueScale, meta) {\n  return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;\n}\n\nfunction getUserBounds(scale) {\n  const {min, max, minDefined, maxDefined} = scale.getUserBounds();\n  return {\n    min: minDefined ? min : Number.NEGATIVE_INFINITY,\n    max: maxDefined ? max : Number.POSITIVE_INFINITY\n  };\n}\n\nfunction getOrCreateStack(stacks, stackKey, indexValue) {\n  const subStack = stacks[stackKey] || (stacks[stackKey] = {});\n  return subStack[indexValue] || (subStack[indexValue] = {});\n}\n\nfunction getLastIndexInStack(stack, vScale, positive, type) {\n  for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {\n    const value = stack[meta.index];\n    if ((positive && value > 0) || (!positive && value < 0)) {\n      return meta.index;\n    }\n  }\n\n  return null;\n}\n\nfunction updateStacks(controller, parsed) {\n  const {chart, _cachedMeta: meta} = controller;\n  const stacks = chart._stacks || (chart._stacks = {}); // map structure is {stackKey: {datasetIndex: value}}\n  const {iScale, vScale, index: datasetIndex} = meta;\n  const iAxis = iScale.axis;\n  const vAxis = vScale.axis;\n  const key = getStackKey(iScale, vScale, meta);\n  const ilen = parsed.length;\n  let stack;\n\n  for (let i = 0; i < ilen; ++i) {\n    const item = parsed[i];\n    const {[iAxis]: index, [vAxis]: value} = item;\n    const itemStacks = item._stacks || (item._stacks = {});\n    stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);\n    stack[datasetIndex] = value;\n\n    stack._top = getLastIndexInStack(stack, vScale, true, meta.type);\n    stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);\n\n    const visualValues = stack._visualValues || (stack._visualValues = {});\n    visualValues[datasetIndex] = value;\n  }\n}\n\nfunction getFirstScaleId(chart, axis) {\n  const scales = chart.scales;\n  return Object.keys(scales).filter(key => scales[key].axis === axis).shift();\n}\n\nfunction createDatasetContext(parent, index) {\n  return createContext(parent,\n    {\n      active: false,\n      dataset: undefined,\n      datasetIndex: index,\n      index,\n      mode: 'default',\n      type: 'dataset'\n    }\n  );\n}\n\nfunction createDataContext(parent, index, element) {\n  return createContext(parent, {\n    active: false,\n    dataIndex: index,\n    parsed: undefined,\n    raw: undefined,\n    element,\n    index,\n    mode: 'default',\n    type: 'data'\n  });\n}\n\nfunction clearStacks(meta, items) {\n  // Not using meta.index here, because it might be already updated if the dataset changed location\n  const datasetIndex = meta.controller.index;\n  const axis = meta.vScale && meta.vScale.axis;\n  if (!axis) {\n    return;\n  }\n\n  items = items || meta._parsed;\n  for (const parsed of items) {\n    const stacks = parsed._stacks;\n    if (!stacks || stacks[axis] === undefined || stacks[axis][datasetIndex] === undefined) {\n      return;\n    }\n    delete stacks[axis][datasetIndex];\n    if (stacks[axis]._visualValues !== undefined && stacks[axis]._visualValues[datasetIndex] !== undefined) {\n      delete stacks[axis]._visualValues[datasetIndex];\n    }\n  }\n}\n\nconst isDirectUpdateMode = (mode) => mode === 'reset' || mode === 'none';\nconst cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);\nconst createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked\n  && {keys: getSortedDatasetIndices(chart, true), values: null};\n\nexport default class DatasetController {\n\n  /**\n   * @type {any}\n   */\n  static defaults = {};\n\n  /**\n   * Element type used to generate a meta dataset (e.g. Chart.element.LineElement).\n   */\n  static datasetElementType = null;\n\n  /**\n   * Element type used to generate a meta data (e.g. Chart.element.PointElement).\n   */\n  static dataElementType = null;\n\n  /**\n\t * @param {Chart} chart\n\t * @param {number} datasetIndex\n\t */\n  constructor(chart, datasetIndex) {\n    this.chart = chart;\n    this._ctx = chart.ctx;\n    this.index = datasetIndex;\n    this._cachedDataOpts = {};\n    this._cachedMeta = this.getMeta();\n    this._type = this._cachedMeta.type;\n    this.options = undefined;\n    /** @type {boolean | object} */\n    this._parsing = false;\n    this._data = undefined;\n    this._objectData = undefined;\n    this._sharedOptions = undefined;\n    this._drawStart = undefined;\n    this._drawCount = undefined;\n    this.enableOptionSharing = false;\n    this.supportsDecimation = false;\n    this.$context = undefined;\n    this._syncList = [];\n    this.datasetElementType = new.target.datasetElementType;\n    this.dataElementType = new.target.dataElementType;\n\n    this.initialize();\n  }\n\n  initialize() {\n    const meta = this._cachedMeta;\n    this.configure();\n    this.linkScales();\n    meta._stacked = isStacked(meta.vScale, meta);\n    this.addElements();\n\n    if (this.options.fill && !this.chart.isPluginEnabled('filler')) {\n      console.warn(\"Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options\");\n    }\n  }\n\n  updateIndex(datasetIndex) {\n    if (this.index !== datasetIndex) {\n      clearStacks(this._cachedMeta);\n    }\n    this.index = datasetIndex;\n  }\n\n  linkScales() {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n\n    const chooseId = (axis, x, y, r) => axis === 'x' ? x : axis === 'r' ? r : y;\n\n    const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, 'x'));\n    const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, 'y'));\n    const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, 'r'));\n    const indexAxis = meta.indexAxis;\n    const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);\n    const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);\n    meta.xScale = this.getScaleForId(xid);\n    meta.yScale = this.getScaleForId(yid);\n    meta.rScale = this.getScaleForId(rid);\n    meta.iScale = this.getScaleForId(iid);\n    meta.vScale = this.getScaleForId(vid);\n  }\n\n  getDataset() {\n    return this.chart.data.datasets[this.index];\n  }\n\n  getMeta() {\n    return this.chart.getDatasetMeta(this.index);\n  }\n\n  /**\n\t * @param {string} scaleID\n\t * @return {Scale}\n\t */\n  getScaleForId(scaleID) {\n    return this.chart.scales[scaleID];\n  }\n\n  /**\n\t * @private\n\t */\n  _getOtherScale(scale) {\n    const meta = this._cachedMeta;\n    return scale === meta.iScale\n      ? meta.vScale\n      : meta.iScale;\n  }\n\n  reset() {\n    this._update('reset');\n  }\n\n  /**\n\t * @private\n\t */\n  _destroy() {\n    const meta = this._cachedMeta;\n    if (this._data) {\n      unlistenArrayEvents(this._data, this);\n    }\n    if (meta._stacked) {\n      clearStacks(meta);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _dataCheck() {\n    const dataset = this.getDataset();\n    const data = dataset.data || (dataset.data = []);\n    const _data = this._data;\n\n    // In order to correctly handle data addition/deletion animation (and thus simulate\n    // real-time charts), we need to monitor these data modifications and synchronize\n    // the internal metadata accordingly.\n\n    if (isObject(data)) {\n      this._data = convertObjectDataToArray(data);\n    } else if (_data !== data) {\n      if (_data) {\n        // This case happens when the user replaced the data array instance.\n        unlistenArrayEvents(_data, this);\n        // Discard old parsed data and stacks\n        const meta = this._cachedMeta;\n        clearStacks(meta);\n        meta._parsed = [];\n      }\n      if (data && Object.isExtensible(data)) {\n        listenArrayEvents(data, this);\n      }\n      this._syncList = [];\n      this._data = data;\n    }\n  }\n\n  addElements() {\n    const meta = this._cachedMeta;\n\n    this._dataCheck();\n\n    if (this.datasetElementType) {\n      meta.dataset = new this.datasetElementType();\n    }\n  }\n\n  buildOrUpdateElements(resetNewElements) {\n    const meta = this._cachedMeta;\n    const dataset = this.getDataset();\n    let stackChanged = false;\n\n    this._dataCheck();\n\n    // make sure cached _stacked status is current\n    const oldStacked = meta._stacked;\n    meta._stacked = isStacked(meta.vScale, meta);\n\n    // detect change in stack option\n    if (meta.stack !== dataset.stack) {\n      stackChanged = true;\n      // remove values from old stack\n      clearStacks(meta);\n      meta.stack = dataset.stack;\n    }\n\n    // Re-sync meta data in case the user replaced the data array or if we missed\n    // any updates and so make sure that we handle number of datapoints changing.\n    this._resyncElements(resetNewElements);\n\n    // if stack changed, update stack values for the whole dataset\n    if (stackChanged || oldStacked !== meta._stacked) {\n      updateStacks(this, meta._parsed);\n    }\n  }\n\n  /**\n\t * Merges user-supplied and default dataset-level options\n\t * @private\n\t */\n  configure() {\n    const config = this.chart.config;\n    const scopeKeys = config.datasetScopeKeys(this._type);\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);\n    this.options = config.createResolver(scopes, this.getContext());\n    this._parsing = this.options.parsing;\n    this._cachedDataOpts = {};\n  }\n\n  /**\n\t * @param {number} start\n\t * @param {number} count\n\t */\n  parse(start, count) {\n    const {_cachedMeta: meta, _data: data} = this;\n    const {iScale, _stacked} = meta;\n    const iAxis = iScale.axis;\n\n    let sorted = start === 0 && count === data.length ? true : meta._sorted;\n    let prev = start > 0 && meta._parsed[start - 1];\n    let i, cur, parsed;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n      meta._sorted = true;\n      parsed = data;\n    } else {\n      if (isArray(data[start])) {\n        parsed = this.parseArrayData(meta, data, start, count);\n      } else if (isObject(data[start])) {\n        parsed = this.parseObjectData(meta, data, start, count);\n      } else {\n        parsed = this.parsePrimitiveData(meta, data, start, count);\n      }\n\n      const isNotInOrderComparedToPrev = () => cur[iAxis] === null || (prev && cur[iAxis] < prev[iAxis]);\n      for (i = 0; i < count; ++i) {\n        meta._parsed[i + start] = cur = parsed[i];\n        if (sorted) {\n          if (isNotInOrderComparedToPrev()) {\n            sorted = false;\n          }\n          prev = cur;\n        }\n      }\n      meta._sorted = sorted;\n    }\n\n    if (_stacked) {\n      updateStacks(this, parsed);\n    }\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [1,3,4]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {xScale0: 0, yScale0: 1}\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const labels = iScale.getLabels();\n    const singleScale = iScale === vScale;\n    const parsed = new Array(count);\n    let i, ilen, index;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      parsed[i] = {\n        [iAxis]: singleScale || iScale.parse(labels[index], index),\n        [vAxis]: vScale.parse(data[index], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [[1,2],[3,4]]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id.\n\t * Example: {x: 0, y: 1}\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(item[0], index),\n        y: yScale.parse(item[1], index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @param {object} meta - dataset meta\n\t * @param {array} data - data array. Example [{x:1, y:5}, {x:2, y:10}]\n\t * @param {number} start - start index\n\t * @param {number} count - number of items to parse\n\t * @returns {object} parsed item - item containing index and a parsed value\n\t * for each scale id. _custom is optional\n\t * Example: {xScale0: 0, yScale0: 1, _custom: {r: 10, foo: 'bar'}}\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {xScale, yScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const parsed = new Array(count);\n    let i, ilen, index, item;\n\n    for (i = 0, ilen = count; i < ilen; ++i) {\n      index = i + start;\n      item = data[index];\n      parsed[i] = {\n        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),\n        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)\n      };\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getParsed(index) {\n    return this._cachedMeta._parsed[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataElement(index) {\n    return this._cachedMeta.data[index];\n  }\n\n  /**\n\t * @protected\n\t */\n  applyStack(scale, parsed, mode) {\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const value = parsed[scale.axis];\n    const stack = {\n      keys: getSortedDatasetIndices(chart, true),\n      values: parsed._stacks[scale.axis]._visualValues\n    };\n    return applyStack(stack, value, meta.index, {mode});\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    const parsedValue = parsed[scale.axis];\n    let value = parsedValue === null ? NaN : parsedValue;\n    const values = stack && parsed._stacks[scale.axis];\n    if (stack && values) {\n      stack.values = values;\n      value = applyStack(stack, parsedValue, this._cachedMeta.index);\n    }\n    range.min = Math.min(range.min, value);\n    range.max = Math.max(range.max, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMinMax(scale, canStack) {\n    const meta = this._cachedMeta;\n    const _parsed = meta._parsed;\n    const sorted = meta._sorted && scale === meta.iScale;\n    const ilen = _parsed.length;\n    const otherScale = this._getOtherScale(scale);\n    const stack = createStack(canStack, meta, this.chart);\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n    const {min: otherMin, max: otherMax} = getUserBounds(otherScale);\n    let i, parsed;\n\n    function _skip() {\n      parsed = _parsed[i];\n      const otherValue = parsed[otherScale.axis];\n      return !isFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;\n    }\n\n    for (i = 0; i < ilen; ++i) {\n      if (_skip()) {\n        continue;\n      }\n      this.updateRangeFromParsed(range, scale, parsed, stack);\n      if (sorted) {\n        // if the data is sorted, we don't need to check further from this end of array\n        break;\n      }\n    }\n    if (sorted) {\n      // in the sorted case, find first non-skipped value from other end of array\n      for (i = ilen - 1; i >= 0; --i) {\n        if (_skip()) {\n          continue;\n        }\n        this.updateRangeFromParsed(range, scale, parsed, stack);\n        break;\n      }\n    }\n    return range;\n  }\n\n  getAllParsedValues(scale) {\n    const parsed = this._cachedMeta._parsed;\n    const values = [];\n    let i, ilen, value;\n\n    for (i = 0, ilen = parsed.length; i < ilen; ++i) {\n      value = parsed[i][scale.axis];\n      if (isFinite(value)) {\n        values.push(value);\n      }\n    }\n    return values;\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return false;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const vScale = meta.vScale;\n    const parsed = this.getParsed(index);\n    return {\n      label: iScale ? '' + iScale.getLabelForValue(parsed[iScale.axis]) : '',\n      value: vScale ? '' + vScale.getLabelForValue(parsed[vScale.axis]) : ''\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _update(mode) {\n    const meta = this._cachedMeta;\n    this.update(mode || 'default');\n    meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {} // eslint-disable-line no-unused-vars\n\n  draw() {\n    const ctx = this._ctx;\n    const chart = this.chart;\n    const meta = this._cachedMeta;\n    const elements = meta.data || [];\n    const area = chart.chartArea;\n    const active = [];\n    const start = this._drawStart || 0;\n    const count = this._drawCount || (elements.length - start);\n    const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;\n    let i;\n\n    if (meta.dataset) {\n      meta.dataset.draw(ctx, area, start, count);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const element = elements[i];\n      if (element.hidden) {\n        continue;\n      }\n      if (element.active && drawActiveElementsOnTop) {\n        active.push(element);\n      } else {\n        element.draw(ctx, area);\n      }\n    }\n\n    for (i = 0; i < active.length; ++i) {\n      active[i].draw(ctx, area);\n    }\n  }\n\n  /**\n\t * Returns a set of predefined style properties that should be used to represent the dataset\n\t * or the data if the index is specified\n\t * @param {number} index - data index\n\t * @param {boolean} [active] - true if hover\n\t * @return {object} style object\n\t */\n  getStyle(index, active) {\n    const mode = active ? 'active' : 'default';\n    return index === undefined && this._cachedMeta.dataset\n      ? this.resolveDatasetElementOptions(mode)\n      : this.resolveDataElementOptions(index || 0, mode);\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index, active, mode) {\n    const dataset = this.getDataset();\n    let context;\n    if (index >= 0 && index < this._cachedMeta.data.length) {\n      const element = this._cachedMeta.data[index];\n      context = element.$context ||\n        (element.$context = createDataContext(this.getContext(), index, element));\n      context.parsed = this.getParsed(index);\n      context.raw = dataset.data[index];\n      context.index = context.dataIndex = index;\n    } else {\n      context = this.$context ||\n        (this.$context = createDatasetContext(this.chart.getContext(), this.index));\n      context.dataset = dataset;\n      context.index = context.datasetIndex = this.index;\n    }\n\n    context.active = !!active;\n    context.mode = mode;\n    return context;\n  }\n\n  /**\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDatasetElementOptions(mode) {\n    return this._resolveElementOptions(this.datasetElementType.id, mode);\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    return this._resolveElementOptions(this.dataElementType.id, mode, index);\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveElementOptions(elementType, mode = 'default', index) {\n    const active = mode === 'active';\n    const cache = this._cachedDataOpts;\n    const cacheKey = elementType + '-' + mode;\n    const cached = cache[cacheKey];\n    const sharing = this.enableOptionSharing && defined(index);\n    if (cached) {\n      return cloneIfNotShared(cached, sharing);\n    }\n    const config = this.chart.config;\n    const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);\n    const prefixes = active ? [`${elementType}Hover`, 'hover', elementType, ''] : [elementType, ''];\n    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n    const names = Object.keys(defaults.elements[elementType]);\n    // context is provided as a function, and is called only if needed,\n    // so we don't create a context for each element if not needed.\n    const context = () => this.getContext(index, active, mode);\n    const values = config.resolveNamedOptions(scopes, names, context, prefixes);\n\n    if (values.$shared) {\n      // `$shared` indicates this set of options can be shared between multiple elements.\n      // Sharing is used to reduce number of properties to change during animation.\n      values.$shared = sharing;\n\n      // We cache options by `mode`, which can be 'active' for example. This enables us\n      // to have the 'active' element options and 'default' options to switch between\n      // when interacting.\n      cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));\n    }\n\n    return values;\n  }\n\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations(index, transition, active) {\n    const chart = this.chart;\n    const cache = this._cachedDataOpts;\n    const cacheKey = `animation-${transition}`;\n    const cached = cache[cacheKey];\n    if (cached) {\n      return cached;\n    }\n    let options;\n    if (chart.options.animation !== false) {\n      const config = this.chart.config;\n      const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);\n      const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);\n      options = config.createResolver(scopes, this.getContext(index, active, transition));\n    }\n    const animations = new Animations(chart, options && options.animations);\n    if (options && options._cacheable) {\n      cache[cacheKey] = Object.freeze(animations);\n    }\n    return animations;\n  }\n\n  /**\n\t * Utility for getting the options object shared between elements\n\t * @protected\n\t */\n  getSharedOptions(options) {\n    if (!options.$shared) {\n      return;\n    }\n    return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));\n  }\n\n  /**\n\t * Utility for determining if `options` should be included in the updated properties\n\t * @protected\n\t */\n  includeOptions(mode, sharedOptions) {\n    return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;\n  }\n\n  /**\n   * @todo v4, rename to getSharedOptions and remove excess functions\n   */\n  _getSharedOptions(start, mode) {\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const previouslySharedOptions = this._sharedOptions;\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions) || (sharedOptions !== previouslySharedOptions);\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n    return {sharedOptions, includeOptions};\n  }\n\n  /**\n\t * Utility for updating an element with new properties, using animations when appropriate.\n\t * @protected\n\t */\n  updateElement(element, index, properties, mode) {\n    if (isDirectUpdateMode(mode)) {\n      Object.assign(element, properties);\n    } else {\n      this._resolveAnimations(index, mode).update(element, properties);\n    }\n  }\n\n  /**\n\t * Utility to animate the shared options, that are potentially affecting multiple elements.\n\t * @protected\n\t */\n  updateSharedOptions(sharedOptions, mode, newOptions) {\n    if (sharedOptions && !isDirectUpdateMode(mode)) {\n      this._resolveAnimations(undefined, mode).update(sharedOptions, newOptions);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setStyle(element, index, mode, active) {\n    element.active = active;\n    const options = this.getStyle(index, active);\n    this._resolveAnimations(index, mode, active).update(element, {\n      // When going from active to inactive, we need to update to the shared options.\n      // This way the once hovered element will end up with the same original shared options instance, after animation.\n      options: (!active && this.getSharedOptions(options)) || options\n    });\n  }\n\n  removeHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', false);\n  }\n\n  setHoverStyle(element, datasetIndex, index) {\n    this._setStyle(element, index, 'active', true);\n  }\n\n  /**\n\t * @private\n\t */\n  _removeDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', false);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _setDatasetHoverStyle() {\n    const element = this._cachedMeta.dataset;\n\n    if (element) {\n      this._setStyle(element, undefined, 'active', true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _resyncElements(resetNewElements) {\n    const data = this._data;\n    const elements = this._cachedMeta.data;\n\n    // Apply changes detected through array listeners\n    for (const [method, arg1, arg2] of this._syncList) {\n      this[method](arg1, arg2);\n    }\n    this._syncList = [];\n\n    const numMeta = elements.length;\n    const numData = data.length;\n    const count = Math.min(numData, numMeta);\n\n    if (count) {\n      // TODO: It is not optimal to always parse the old data\n      // This is done because we are not detecting direct assignments:\n      // chart.data.datasets[0].data[5] = 10;\n      // chart.data.datasets[0].data[5].y = 10;\n      this.parse(0, count);\n    }\n\n    if (numData > numMeta) {\n      this._insertElements(numMeta, numData - numMeta, resetNewElements);\n    } else if (numData < numMeta) {\n      this._removeElements(numData, numMeta - numData);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _insertElements(start, count, resetNewElements = true) {\n    const meta = this._cachedMeta;\n    const data = meta.data;\n    const end = start + count;\n    let i;\n\n    const move = (arr) => {\n      arr.length += count;\n      for (i = arr.length - 1; i >= end; i--) {\n        arr[i] = arr[i - count];\n      }\n    };\n    move(data);\n\n    for (i = start; i < end; ++i) {\n      data[i] = new this.dataElementType();\n    }\n\n    if (this._parsing) {\n      move(meta._parsed);\n    }\n    this.parse(start, count);\n\n    if (resetNewElements) {\n      this.updateElements(data, start, count, 'reset');\n    }\n  }\n\n  updateElements(element, start, count, mode) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @private\n\t */\n  _removeElements(start, count) {\n    const meta = this._cachedMeta;\n    if (this._parsing) {\n      const removed = meta._parsed.splice(start, count);\n      if (meta._stacked) {\n        clearStacks(meta, removed);\n      }\n    }\n    meta.data.splice(start, count);\n  }\n\n  /**\n\t * @private\n   */\n  _sync(args) {\n    if (this._parsing) {\n      this._syncList.push(args);\n    } else {\n      const [method, arg1, arg2] = args;\n      this[method](arg1, arg2);\n    }\n    this.chart._dataChanges.push([this.index, ...args]);\n  }\n\n  _onDataPush() {\n    const count = arguments.length;\n    this._sync(['_insertElements', this.getDataset().data.length - count, count]);\n  }\n\n  _onDataPop() {\n    this._sync(['_removeElements', this._cachedMeta.data.length - 1, 1]);\n  }\n\n  _onDataShift() {\n    this._sync(['_removeElements', 0, 1]);\n  }\n\n  _onDataSplice(start, count) {\n    if (count) {\n      this._sync(['_removeElements', start, count]);\n    }\n    const newCount = arguments.length - 2;\n    if (newCount) {\n      this._sync(['_insertElements', start, newCount]);\n    }\n  }\n\n  _onDataUnshift() {\n    this._sync(['_insertElements', 0, arguments.length]);\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {\n  _arrayUnique, isArray, isNullOrUndef,\n  valueOrDefault, resolveObjectKey, sign, defined\n} from '../helpers/index.js';\n\nfunction getAllScaleValues(scale, type) {\n  if (!scale._cache.$bar) {\n    const visibleMetas = scale.getMatchingVisibleMetas(type);\n    let values = [];\n\n    for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) {\n      values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));\n    }\n    scale._cache.$bar = _arrayUnique(values.sort((a, b) => a - b));\n  }\n  return scale._cache.$bar;\n}\n\n/**\n * Computes the \"optimal\" sample size to maintain bars equally sized while preventing overlap.\n * @private\n */\nfunction computeMinSampleSize(meta) {\n  const scale = meta.iScale;\n  const values = getAllScaleValues(scale, meta.type);\n  let min = scale._length;\n  let i, ilen, curr, prev;\n  const updateMinAndPrev = () => {\n    if (curr === 32767 || curr === -32768) {\n      // Ignore truncated pixels\n      return;\n    }\n    if (defined(prev)) {\n      // curr - prev === 0 is ignored\n      min = Math.min(min, Math.abs(curr - prev) || min);\n    }\n    prev = curr;\n  };\n\n  for (i = 0, ilen = values.length; i < ilen; ++i) {\n    curr = scale.getPixelForValue(values[i]);\n    updateMinAndPrev();\n  }\n\n  prev = undefined;\n  for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {\n    curr = scale.getPixelForTick(i);\n    updateMinAndPrev();\n  }\n\n  return min;\n}\n\n/**\n * Computes an \"ideal\" category based on the absolute bar thickness or, if undefined or null,\n * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This\n * mode currently always generates bars equally sized (until we introduce scriptable options?).\n * @private\n */\nfunction computeFitCategoryTraits(index, ruler, options, stackCount) {\n  const thickness = options.barThickness;\n  let size, ratio;\n\n  if (isNullOrUndef(thickness)) {\n    size = ruler.min * options.categoryPercentage;\n    ratio = options.barPercentage;\n  } else {\n    // When bar thickness is enforced, category and bar percentages are ignored.\n    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')\n    // and deprecate barPercentage since this value is ignored when thickness is absolute.\n    size = thickness * stackCount;\n    ratio = 1;\n  }\n\n  return {\n    chunk: size / stackCount,\n    ratio,\n    start: ruler.pixels[index] - (size / 2)\n  };\n}\n\n/**\n * Computes an \"optimal\" category that globally arranges bars side by side (no gap when\n * percentage options are 1), based on the previous and following categories. This mode\n * generates bars with different widths when data are not evenly spaced.\n * @private\n */\nfunction computeFlexCategoryTraits(index, ruler, options, stackCount) {\n  const pixels = ruler.pixels;\n  const curr = pixels[index];\n  let prev = index > 0 ? pixels[index - 1] : null;\n  let next = index < pixels.length - 1 ? pixels[index + 1] : null;\n  const percent = options.categoryPercentage;\n\n  if (prev === null) {\n    // first data: its size is double based on the next point or,\n    // if it's also the last data, we use the scale size.\n    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);\n  }\n\n  if (next === null) {\n    // last data: its size is also double based on the previous point.\n    next = curr + curr - prev;\n  }\n\n  const start = curr - (curr - Math.min(prev, next)) / 2 * percent;\n  const size = Math.abs(next - prev) / 2 * percent;\n\n  return {\n    chunk: size / stackCount,\n    ratio: options.barPercentage,\n    start\n  };\n}\n\nfunction parseFloatBar(entry, item, vScale, i) {\n  const startValue = vScale.parse(entry[0], i);\n  const endValue = vScale.parse(entry[1], i);\n  const min = Math.min(startValue, endValue);\n  const max = Math.max(startValue, endValue);\n  let barStart = min;\n  let barEnd = max;\n\n  if (Math.abs(min) > Math.abs(max)) {\n    barStart = max;\n    barEnd = min;\n  }\n\n  // Store `barEnd` (furthest away from origin) as parsed value,\n  // to make stacking straight forward\n  item[vScale.axis] = barEnd;\n\n  item._custom = {\n    barStart,\n    barEnd,\n    start: startValue,\n    end: endValue,\n    min,\n    max\n  };\n}\n\nfunction parseValue(entry, item, vScale, i) {\n  if (isArray(entry)) {\n    parseFloatBar(entry, item, vScale, i);\n  } else {\n    item[vScale.axis] = vScale.parse(entry, i);\n  }\n  return item;\n}\n\nfunction parseArrayOrPrimitive(meta, data, start, count) {\n  const iScale = meta.iScale;\n  const vScale = meta.vScale;\n  const labels = iScale.getLabels();\n  const singleScale = iScale === vScale;\n  const parsed = [];\n  let i, ilen, item, entry;\n\n  for (i = start, ilen = start + count; i < ilen; ++i) {\n    entry = data[i];\n    item = {};\n    item[iScale.axis] = singleScale || iScale.parse(labels[i], i);\n    parsed.push(parseValue(entry, item, vScale, i));\n  }\n  return parsed;\n}\n\nfunction isFloatBar(custom) {\n  return custom && custom.barStart !== undefined && custom.barEnd !== undefined;\n}\n\nfunction barSign(size, vScale, actualBase) {\n  if (size !== 0) {\n    return sign(size);\n  }\n  return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);\n}\n\nfunction borderProps(properties) {\n  let reverse, start, end, top, bottom;\n  if (properties.horizontal) {\n    reverse = properties.base > properties.x;\n    start = 'left';\n    end = 'right';\n  } else {\n    reverse = properties.base < properties.y;\n    start = 'bottom';\n    end = 'top';\n  }\n  if (reverse) {\n    top = 'end';\n    bottom = 'start';\n  } else {\n    top = 'start';\n    bottom = 'end';\n  }\n  return {start, end, reverse, top, bottom};\n}\n\nfunction setBorderSkipped(properties, options, stack, index) {\n  let edge = options.borderSkipped;\n  const res = {};\n\n  if (!edge) {\n    properties.borderSkipped = res;\n    return;\n  }\n\n  if (edge === true) {\n    properties.borderSkipped = {top: true, right: true, bottom: true, left: true};\n    return;\n  }\n\n  const {start, end, reverse, top, bottom} = borderProps(properties);\n\n  if (edge === 'middle' && stack) {\n    properties.enableBorderRadius = true;\n    if ((stack._top || 0) === index) {\n      edge = top;\n    } else if ((stack._bottom || 0) === index) {\n      edge = bottom;\n    } else {\n      res[parseEdge(bottom, start, end, reverse)] = true;\n      edge = top;\n    }\n  }\n\n  res[parseEdge(edge, start, end, reverse)] = true;\n  properties.borderSkipped = res;\n}\n\nfunction parseEdge(edge, a, b, reverse) {\n  if (reverse) {\n    edge = swap(edge, a, b);\n    edge = startEnd(edge, b, a);\n  } else {\n    edge = startEnd(edge, a, b);\n  }\n  return edge;\n}\n\nfunction swap(orig, v1, v2) {\n  return orig === v1 ? v2 : orig === v2 ? v1 : orig;\n}\n\nfunction startEnd(v, start, end) {\n  return v === 'start' ? start : v === 'end' ? end : v;\n}\n\nfunction setInflateAmount(properties, {inflateAmount}, ratio) {\n  properties.inflateAmount = inflateAmount === 'auto'\n    ? ratio === 1 ? 0.33 : 0\n    : inflateAmount;\n}\n\nexport default class BarController extends DatasetController {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'bar',\n\n    categoryPercentage: 0.8,\n    barPercentage: 0.9,\n    grouped: true,\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'base', 'width', 'height']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n        offset: true,\n        grid: {\n          offset: true\n        }\n      },\n      _value_: {\n        type: 'linear',\n        beginAtZero: true,\n      }\n    }\n  };\n\n\n  /**\n\t * Overriding primitive data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding array data parsing since we support mixed primitive/array\n\t * data for float bars\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    return parseArrayOrPrimitive(meta, data, start, count);\n  }\n\n  /**\n\t * Overriding object data parsing since we support mixed primitive/array\n\t * value-scale data for float bars\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const {iScale, vScale} = meta;\n    const {xAxisKey = 'x', yAxisKey = 'y'} = this._parsing;\n    const iAxisKey = iScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const vAxisKey = vScale.axis === 'x' ? xAxisKey : yAxisKey;\n    const parsed = [];\n    let i, ilen, item, obj;\n    for (i = start, ilen = start + count; i < ilen; ++i) {\n      obj = data[i];\n      item = {};\n      item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);\n      parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  updateRangeFromParsed(range, scale, parsed, stack) {\n    super.updateRangeFromParsed(range, scale, parsed, stack);\n    const custom = parsed._custom;\n    if (custom && scale === this._cachedMeta.vScale) {\n      // float bar: only one end of the bar is considered by `super`\n      range.min = Math.min(range.min, custom.min);\n      range.max = Math.max(range.max, custom.max);\n    }\n  }\n\n  /**\n\t * @return {number|boolean}\n\t * @protected\n\t */\n  getMaxOverflow() {\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const {iScale, vScale} = meta;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const value = isFloatBar(custom)\n      ? '[' + custom.start + ', ' + custom.end + ']'\n      : '' + vScale.getLabelForValue(parsed[vScale.axis]);\n\n    return {\n      label: '' + iScale.getLabelForValue(parsed[iScale.axis]),\n      value\n    };\n  }\n\n  initialize() {\n    this.enableOptionSharing = true;\n\n    super.initialize();\n\n    const meta = this._cachedMeta;\n    meta.stack = this.getDataset().stack;\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    this.updateElements(meta.data, 0, meta.data.length, mode);\n  }\n\n  updateElements(bars, start, count, mode) {\n    const reset = mode === 'reset';\n    const {index, _cachedMeta: {vScale}} = this;\n    const base = vScale.getBasePixel();\n    const horizontal = vScale.isHorizontal();\n    const ruler = this._getRuler();\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n\n    for (let i = start; i < start + count; i++) {\n      const parsed = this.getParsed(i);\n      const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {base, head: base} : this._calculateBarValuePixels(i);\n      const ipixels = this._calculateBarIndexPixels(i, ruler);\n      const stack = (parsed._stacks || {})[vScale.axis];\n\n      const properties = {\n        horizontal,\n        base: vpixels.base,\n        enableBorderRadius: !stack || isFloatBar(parsed._custom) || (index === stack._top || index === stack._bottom),\n        x: horizontal ? vpixels.head : ipixels.center,\n        y: horizontal ? ipixels.center : vpixels.head,\n        height: horizontal ? ipixels.size : Math.abs(vpixels.size),\n        width: horizontal ? Math.abs(vpixels.size) : ipixels.size\n      };\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? 'active' : mode);\n      }\n      const options = properties.options || bars[i].options;\n      setBorderSkipped(properties, options, stack, index);\n      setInflateAmount(properties, options, ruler.ratio);\n      this.updateElement(bars[i], i, properties, mode);\n    }\n  }\n\n  /**\n\t * Returns the stacks based on groups and bar visibility.\n\t * @param {number} [last] - The dataset index\n\t * @param {number} [dataIndex] - The data index of the ruler\n\t * @returns {string[]} The list of stack IDs\n\t * @private\n\t */\n  _getStacks(last, dataIndex) {\n    const {iScale} = this._cachedMeta;\n    const metasets = iScale.getMatchingVisibleMetas(this._type)\n      .filter(meta => meta.controller.options.grouped);\n    const stacked = iScale.options.stacked;\n    const stacks = [];\n\n    const skipNull = (meta) => {\n      const parsed = meta.controller.getParsed(dataIndex);\n      const val = parsed && parsed[meta.vScale.axis];\n\n      if (isNullOrUndef(val) || isNaN(val)) {\n        return true;\n      }\n    };\n\n    for (const meta of metasets) {\n      if (dataIndex !== undefined && skipNull(meta)) {\n        continue;\n      }\n\n      // stacked   | meta.stack\n      //           | found | not found | undefined\n      // false     |   x   |     x     |     x\n      // true      |       |     x     |\n      // undefined |       |     x     |     x\n      if (stacked === false || stacks.indexOf(meta.stack) === -1 ||\n\t\t\t\t(stacked === undefined && meta.stack === undefined)) {\n        stacks.push(meta.stack);\n      }\n      if (meta.index === last) {\n        break;\n      }\n    }\n\n    // No stacks? that means there is no visible data. Let's still initialize an `undefined`\n    // stack where possible invisible bars will be located.\n    // https://github.com/chartjs/Chart.js/issues/6368\n    if (!stacks.length) {\n      stacks.push(undefined);\n    }\n\n    return stacks;\n  }\n\n  /**\n\t * Returns the effective number of stacks based on groups and bar visibility.\n\t * @private\n\t */\n  _getStackCount(index) {\n    return this._getStacks(undefined, index).length;\n  }\n\n  /**\n\t * Returns the stack index for the given dataset based on groups and bar visibility.\n\t * @param {number} [datasetIndex] - The dataset index\n\t * @param {string} [name] - The stack name to find\n   * @param {number} [dataIndex]\n\t * @returns {number} The stack index\n\t * @private\n\t */\n  _getStackIndex(datasetIndex, name, dataIndex) {\n    const stacks = this._getStacks(datasetIndex, dataIndex);\n    const index = (name !== undefined)\n      ? stacks.indexOf(name)\n      : -1; // indexOf returns -1 if element is not present\n\n    return (index === -1)\n      ? stacks.length - 1\n      : index;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRuler() {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const iScale = meta.iScale;\n    const pixels = [];\n    let i, ilen;\n\n    for (i = 0, ilen = meta.data.length; i < ilen; ++i) {\n      pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));\n    }\n\n    const barThickness = opts.barThickness;\n    const min = barThickness || computeMinSampleSize(meta);\n\n    return {\n      min,\n      pixels,\n      start: iScale._startPixel,\n      end: iScale._endPixel,\n      stackCount: this._getStackCount(),\n      scale: iScale,\n      grouped: opts.grouped,\n      // bar thickness ratio used for non-grouped bars\n      ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage\n    };\n  }\n\n  /**\n\t * Note: pixel values are not clamped to the scale area.\n\t * @private\n\t */\n  _calculateBarValuePixels(index) {\n    const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;\n    const actualBase = baseValue || 0;\n    const parsed = this.getParsed(index);\n    const custom = parsed._custom;\n    const floating = isFloatBar(custom);\n    let value = parsed[vScale.axis];\n    let start = 0;\n    let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;\n    let head, size;\n\n    if (length !== value) {\n      start = length - value;\n      length = value;\n    }\n\n    if (floating) {\n      value = custom.barStart;\n      length = custom.barEnd - custom.barStart;\n      // bars crossing origin are not stacked\n      if (value !== 0 && sign(value) !== sign(custom.barEnd)) {\n        start = 0;\n      }\n      start += value;\n    }\n\n    const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;\n    let base = vScale.getPixelForValue(startValue);\n\n    if (this.chart.getDataVisibility(index)) {\n      head = vScale.getPixelForValue(start + length);\n    } else {\n      // When not visible, no height\n      head = base;\n    }\n\n    size = head - base;\n\n    if (Math.abs(size) < minBarLength) {\n      size = barSign(size, vScale, actualBase) * minBarLength;\n      if (value === actualBase) {\n        base -= size / 2;\n      }\n      const startPixel = vScale.getPixelForDecimal(0);\n      const endPixel = vScale.getPixelForDecimal(1);\n      const min = Math.min(startPixel, endPixel);\n      const max = Math.max(startPixel, endPixel);\n      base = Math.max(Math.min(base, max), min);\n      head = base + size;\n\n      if (_stacked && !floating) {\n        // visual data coordinates after applying minBarLength\n        parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);\n      }\n    }\n\n    if (base === vScale.getPixelForValue(actualBase)) {\n      const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;\n      base += halfGrid;\n      size -= halfGrid;\n    }\n\n    return {\n      size,\n      base,\n      head,\n      center: head + size / 2\n    };\n  }\n\n  /**\n\t * @private\n\t */\n  _calculateBarIndexPixels(index, ruler) {\n    const scale = ruler.scale;\n    const options = this.options;\n    const skipNull = options.skipNull;\n    const maxBarThickness = valueOrDefault(options.maxBarThickness, Infinity);\n    let center, size;\n    if (ruler.grouped) {\n      const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;\n      const range = options.barThickness === 'flex'\n        ? computeFlexCategoryTraits(index, ruler, options, stackCount)\n        : computeFitCategoryTraits(index, ruler, options, stackCount);\n\n      const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : undefined);\n      center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);\n      size = Math.min(maxBarThickness, range.chunk * range.ratio);\n    } else {\n      // For non-grouped bar charts, exact pixel values are used\n      center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);\n      size = Math.min(maxBarThickness, ruler.min * ruler.ratio);\n    }\n\n    return {\n      base: center - size / 2,\n      head: center + size / 2,\n      center,\n      size\n    };\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    const vScale = meta.vScale;\n    const rects = meta.data;\n    const ilen = rects.length;\n    let i = 0;\n\n    for (; i < ilen; ++i) {\n      if (this.getParsed(i)[vScale.axis] !== null) {\n        rects[i].draw(this._ctx);\n      }\n    }\n  }\n\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {valueOrDefault} from '../helpers/helpers.core.js';\n\nexport default class BubbleController extends DatasetController {\n\n  static id = 'bubble';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'borderWidth', 'radius']\n      }\n    }\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    super.initialize();\n  }\n\n  /**\n\t * Parse array of primitive values\n\t * @protected\n\t */\n  parsePrimitiveData(meta, data, start, count) {\n    const parsed = super.parsePrimitiveData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of arrays\n\t * @protected\n\t */\n  parseArrayData(meta, data, start, count) {\n    const parsed = super.parseArrayData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * Parse array of objects\n\t * @protected\n\t */\n  parseObjectData(meta, data, start, count) {\n    const parsed = super.parseObjectData(meta, data, start, count);\n    for (let i = 0; i < parsed.length; i++) {\n      const item = data[start + i];\n      parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);\n    }\n    return parsed;\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const data = this._cachedMeta.data;\n\n    let max = 0;\n    for (let i = data.length - 1; i >= 0; --i) {\n      max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n    }\n    return max > 0 && max;\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n    const r = parsed._custom;\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + (r ? ', ' + r : '') + ')'\n    };\n  }\n\n  update(mode) {\n    const points = this._cachedMeta.data;\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const parsed = !reset && this.getParsed(i);\n      const properties = {};\n      const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(0.5) : iScale.getPixelForValue(parsed[iAxis]);\n      const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel);\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n\n        if (reset) {\n          properties.options.radius = 0;\n        }\n      }\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n\n  /**\n\t * @param {number} index\n\t * @param {string} [mode]\n\t * @protected\n\t */\n  resolveDataElementOptions(index, mode) {\n    const parsed = this.getParsed(index);\n    let values = super.resolveDataElementOptions(index, mode);\n\n    // In case values were cached (and thus frozen), we need to clone the values\n    if (values.$shared) {\n      values = Object.assign({}, values, {$shared: false});\n    }\n\n    // Custom radius resolution\n    const radius = values.radius;\n    if (mode !== 'active') {\n      values.radius = 0;\n    }\n    values.radius += valueOrDefault(parsed && parsed._custom, radius);\n\n    return values;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isObject, resolveObjectKey, toPercentage, toDimension, valueOrDefault} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {toRadians, PI, TAU, HALF_PI, _angleBetween} from '../helpers/helpers.math.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nfunction getRatioAndOffset(rotation, circumference, cutout) {\n  let ratioX = 1;\n  let ratioY = 1;\n  let offsetX = 0;\n  let offsetY = 0;\n  // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc\n  if (circumference < TAU) {\n    const startAngle = rotation;\n    const endAngle = startAngle + circumference;\n    const startX = Math.cos(startAngle);\n    const startY = Math.sin(startAngle);\n    const endX = Math.cos(endAngle);\n    const endY = Math.sin(endAngle);\n    const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);\n    const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);\n    const maxX = calcMax(0, startX, endX);\n    const maxY = calcMax(HALF_PI, startY, endY);\n    const minX = calcMin(PI, startX, endX);\n    const minY = calcMin(PI + HALF_PI, startY, endY);\n    ratioX = (maxX - minX) / 2;\n    ratioY = (maxY - minY) / 2;\n    offsetX = -(maxX + minX) / 2;\n    offsetY = -(maxY + minY) / 2;\n  }\n  return {ratioX, ratioY, offsetX, offsetY};\n}\n\nexport default class DoughnutController extends DatasetController {\n\n  static id = 'doughnut';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'arc',\n    animation: {\n      // Boolean - Whether we animate the rotation of the Doughnut\n      animateRotate: true,\n      // Boolean - Whether we animate scaling the Doughnut from the centre\n      animateScale: false\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['circumference', 'endAngle', 'innerRadius', 'outerRadius', 'startAngle', 'x', 'y', 'offset', 'borderWidth', 'spacing']\n      },\n    },\n    // The percentage of the chart that we cut out of the middle.\n    cutout: '50%',\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%',\n\n    // Spacing between arcs\n    spacing: 0,\n\n    indexAxis: 'r',\n  };\n\n  static descriptors = {\n    _scriptable: (name) => name !== 'spacing',\n    _indexable: (name) => name !== 'spacing' && !name.startsWith('borderDash') && !name.startsWith('hoverBorderDash'),\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    // Need to override these to give a nice default\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.enableOptionSharing = true;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.offsetX = undefined;\n    this.offsetY = undefined;\n  }\n\n  linkScales() {}\n\n  /**\n\t * Override data parsing, since we are not using scales\n\t */\n  parse(start, count) {\n    const data = this.getDataset().data;\n    const meta = this._cachedMeta;\n\n    if (this._parsing === false) {\n      meta._parsed = data;\n    } else {\n      let getter = (i) => +data[i];\n\n      if (isObject(data[start])) {\n        const {key = 'value'} = this._parsing;\n        getter = (i) => +resolveObjectKey(data[i], key);\n      }\n\n      let i, ilen;\n      for (i = start, ilen = start + count; i < ilen; ++i) {\n        meta._parsed[i] = getter(i);\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _getRotation() {\n    return toRadians(this.options.rotation - 90);\n  }\n\n  /**\n\t * @private\n\t */\n  _getCircumference() {\n    return toRadians(this.options.circumference);\n  }\n\n  /**\n\t * Get the maximal rotation & circumference extents\n\t * across all visible datasets.\n\t */\n  _getRotationExtents() {\n    let min = TAU;\n    let max = -TAU;\n\n    for (let i = 0; i < this.chart.data.datasets.length; ++i) {\n      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {\n        const controller = this.chart.getDatasetMeta(i).controller;\n        const rotation = controller._getRotation();\n        const circumference = controller._getCircumference();\n\n        min = Math.min(min, rotation);\n        max = Math.max(max, rotation + circumference);\n      }\n    }\n\n    return {\n      rotation: min,\n      circumference: max - min,\n    };\n  }\n\n  /**\n\t * @param {string} mode\n\t */\n  update(mode) {\n    const chart = this.chart;\n    const {chartArea} = chart;\n    const meta = this._cachedMeta;\n    const arcs = meta.data;\n    const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;\n    const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);\n    const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);\n    const chartWeight = this._getRingWeight(this.index);\n\n    // Compute the maximal rotation & circumference limits.\n    // If we only consider our dataset, this can cause problems when two datasets\n    // are both less than a circle with different rotations (starting angles)\n    const {circumference, rotation} = this._getRotationExtents();\n    const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);\n    const maxWidth = (chartArea.width - spacing) / ratioX;\n    const maxHeight = (chartArea.height - spacing) / ratioY;\n    const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);\n    const outerRadius = toDimension(this.options.radius, maxRadius);\n    const innerRadius = Math.max(outerRadius * cutout, 0);\n    const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();\n    this.offsetX = offsetX * outerRadius;\n    this.offsetY = offsetY * outerRadius;\n\n    meta.total = this.calculateTotal();\n\n    this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);\n    this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);\n\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @private\n   */\n  _circumference(i, reset) {\n    const opts = this.options;\n    const meta = this._cachedMeta;\n    const circumference = this._getCircumference();\n    if ((reset && opts.animation.animateRotate) || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) {\n      return 0;\n    }\n    return this.calculateCircumference(meta._parsed[i] * circumference / TAU);\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const centerX = (chartArea.left + chartArea.right) / 2;\n    const centerY = (chartArea.top + chartArea.bottom) / 2;\n    const animateScale = reset && animationOpts.animateScale;\n    const innerRadius = animateScale ? 0 : this.innerRadius;\n    const outerRadius = animateScale ? 0 : this.outerRadius;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    let startAngle = this._getRotation();\n    let i;\n\n    for (i = 0; i < start; ++i) {\n      startAngle += this._circumference(i, reset);\n    }\n\n    for (i = start; i < start + count; ++i) {\n      const circumference = this._circumference(i, reset);\n      const arc = arcs[i];\n      const properties = {\n        x: centerX + this.offsetX,\n        y: centerY + this.offsetY,\n        startAngle,\n        endAngle: startAngle + circumference,\n        circumference,\n        outerRadius,\n        innerRadius\n      };\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? 'active' : mode);\n      }\n      startAngle += circumference;\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  calculateTotal() {\n    const meta = this._cachedMeta;\n    const metaData = meta.data;\n    let total = 0;\n    let i;\n\n    for (i = 0; i < metaData.length; i++) {\n      const value = meta._parsed[i];\n      if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) {\n        total += Math.abs(value);\n      }\n    }\n\n    return total;\n  }\n\n  calculateCircumference(value) {\n    const total = this._cachedMeta.total;\n    if (total > 0 && !isNaN(value)) {\n      return TAU * (Math.abs(value) / total);\n    }\n    return 0;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index], chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  getMaxBorderWidth(arcs) {\n    let max = 0;\n    const chart = this.chart;\n    let i, ilen, meta, controller, options;\n\n    if (!arcs) {\n      // Find the outmost visible dataset\n      for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {\n        if (chart.isDatasetVisible(i)) {\n          meta = chart.getDatasetMeta(i);\n          arcs = meta.data;\n          controller = meta.controller;\n          break;\n        }\n      }\n    }\n\n    if (!arcs) {\n      return 0;\n    }\n\n    for (i = 0, ilen = arcs.length; i < ilen; ++i) {\n      options = controller.resolveDataElementOptions(i);\n      if (options.borderAlign !== 'inner') {\n        max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);\n      }\n    }\n    return max;\n  }\n\n  getMaxOffset(arcs) {\n    let max = 0;\n\n    for (let i = 0, ilen = arcs.length; i < ilen; ++i) {\n      const options = this.resolveDataElementOptions(i);\n      max = Math.max(max, options.offset || 0, options.hoverOffset || 0);\n    }\n    return max;\n  }\n\n  /**\n\t * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly\n\t * @private\n\t */\n  _getRingWeightOffset(datasetIndex) {\n    let ringWeightOffset = 0;\n\n    for (let i = 0; i < datasetIndex; ++i) {\n      if (this.chart.isDatasetVisible(i)) {\n        ringWeightOffset += this._getRingWeight(i);\n      }\n    }\n\n    return ringWeightOffset;\n  }\n\n  /**\n\t * @private\n\t */\n  _getRingWeight(datasetIndex) {\n    return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);\n  }\n\n  /**\n\t * Returns the sum of all visible data set weights.\n\t * @private\n\t */\n  _getVisibleDatasetWeightTotal() {\n    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class LineController extends DatasetController {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n\n    showLine: true,\n    spanGaps: false,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    scales: {\n      _index_: {\n        type: 'category',\n      },\n      _value_: {\n        type: 'linear',\n      },\n    }\n  };\n\n  initialize() {\n    this.enableOptionSharing = true;\n    this.supportsDecimation = true;\n    super.initialize();\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {dataset: line, data: points = [], _dataset} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    // Update Line\n    line._chart = this.chart;\n    line._datasetIndex = this.index;\n    line._decimated = !!_dataset._decimated;\n    line.points = points;\n\n    const options = this.resolveDatasetElementOptions(mode);\n    if (!this.options.showLine) {\n      options.borderWidth = 0;\n    }\n    options.segment = this.options.segment;\n    this.updateElement(line, undefined, {\n      animated: !animationsDisabled,\n      options\n    }, mode);\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    const end = start + count;\n    const pointsCount = points.length;\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = 0; i < pointsCount; ++i) {\n      const point = points[i];\n      const properties = directUpdate ? point : {};\n\n      if (i < start || i >= end) {\n        properties.skip = true;\n        continue;\n      }\n\n      const parsed = this.getParsed(i);\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n    const data = meta.data || [];\n    if (!data.length) {\n      return border;\n    }\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n\n  draw() {\n    const meta = this._cachedMeta;\n    meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);\n    super.draw();\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {toRadians, PI, formatNumber, _parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class PolarAreaController extends DatasetController {\n\n  static id = 'polarArea';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    dataElementType: 'arc',\n    animation: {\n      animateRotate: true,\n      animateScale: true\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'startAngle', 'endAngle', 'innerRadius', 'outerRadius']\n      },\n    },\n    indexAxis: 'r',\n    startAngle: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    plugins: {\n      legend: {\n        labels: {\n          generateLabels(chart) {\n            const data = chart.data;\n            if (data.labels.length && data.datasets.length) {\n              const {labels: {pointStyle, color}} = chart.legend.options;\n\n              return data.labels.map((label, i) => {\n                const meta = chart.getDatasetMeta(0);\n                const style = meta.controller.getStyle(i);\n\n                return {\n                  text: label,\n                  fillStyle: style.backgroundColor,\n                  strokeStyle: style.borderColor,\n                  fontColor: color,\n                  lineWidth: style.borderWidth,\n                  pointStyle: pointStyle,\n                  hidden: !chart.getDataVisibility(i),\n\n                  // Extra data used for toggling the correct item\n                  index: i\n                };\n              });\n            }\n            return [];\n          }\n        },\n\n        onClick(e, legendItem, legend) {\n          legend.chart.toggleDataVisibility(legendItem.index);\n          legend.chart.update();\n        }\n      }\n    },\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n        angleLines: {\n          display: false\n        },\n        beginAtZero: true,\n        grid: {\n          circular: true\n        },\n        pointLabels: {\n          display: false\n        },\n        startAngle: 0\n      }\n    }\n  };\n\n  constructor(chart, datasetIndex) {\n    super(chart, datasetIndex);\n\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n  }\n\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const chart = this.chart;\n    const labels = chart.data.labels || [];\n    const value = formatNumber(meta._parsed[index].r, chart.options.locale);\n\n    return {\n      label: labels[index] || '',\n      value,\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const arcs = this._cachedMeta.data;\n\n    this._updateRadius();\n    this.updateElements(arcs, 0, arcs.length, mode);\n  }\n\n  /**\n   * @protected\n   */\n  getMinMax() {\n    const meta = this._cachedMeta;\n    const range = {min: Number.POSITIVE_INFINITY, max: Number.NEGATIVE_INFINITY};\n\n    meta.data.forEach((element, index) => {\n      const parsed = this.getParsed(index).r;\n\n      if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {\n        if (parsed < range.min) {\n          range.min = parsed;\n        }\n\n        if (parsed > range.max) {\n          range.max = parsed;\n        }\n      }\n    });\n\n    return range;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateRadius() {\n    const chart = this.chart;\n    const chartArea = chart.chartArea;\n    const opts = chart.options;\n    const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);\n\n    const outerRadius = Math.max(minSize / 2, 0);\n    const innerRadius = Math.max(opts.cutoutPercentage ? (outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);\n    const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();\n\n    this.outerRadius = outerRadius - (radiusLength * this.index);\n    this.innerRadius = this.outerRadius - radiusLength;\n  }\n\n  updateElements(arcs, start, count, mode) {\n    const reset = mode === 'reset';\n    const chart = this.chart;\n    const opts = chart.options;\n    const animationOpts = opts.animation;\n    const scale = this._cachedMeta.rScale;\n    const centerX = scale.xCenter;\n    const centerY = scale.yCenter;\n    const datasetStartAngle = scale.getIndexAngle(0) - 0.5 * PI;\n    let angle = datasetStartAngle;\n    let i;\n\n    const defaultAngle = 360 / this.countVisibleElements();\n\n    for (i = 0; i < start; ++i) {\n      angle += this._computeAngle(i, mode, defaultAngle);\n    }\n    for (i = start; i < start + count; i++) {\n      const arc = arcs[i];\n      let startAngle = angle;\n      let endAngle = angle + this._computeAngle(i, mode, defaultAngle);\n      let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;\n      angle = endAngle;\n\n      if (reset) {\n        if (animationOpts.animateScale) {\n          outerRadius = 0;\n        }\n        if (animationOpts.animateRotate) {\n          startAngle = endAngle = datasetStartAngle;\n        }\n      }\n\n      const properties = {\n        x: centerX,\n        y: centerY,\n        innerRadius: 0,\n        outerRadius,\n        startAngle,\n        endAngle,\n        options: this.resolveDataElementOptions(i, arc.active ? 'active' : mode)\n      };\n\n      this.updateElement(arc, i, properties, mode);\n    }\n  }\n\n  countVisibleElements() {\n    const meta = this._cachedMeta;\n    let count = 0;\n\n    meta.data.forEach((element, index) => {\n      if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) {\n        count++;\n      }\n    });\n\n    return count;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeAngle(index, mode, defaultAngle) {\n    return this.chart.getDataVisibility(index)\n      ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle)\n      : 0;\n  }\n}\n","import DoughnutController from './controller.doughnut.js';\n\n// Pie charts are Doughnut chart with different defaults\nexport default class PieController extends DoughnutController {\n\n  static id = 'pie';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    // The percentage of the chart that we cut out of the middle.\n    cutout: 0,\n\n    // The rotation of the chart, where the first data arc begins.\n    rotation: 0,\n\n    // The total circumference of the chart.\n    circumference: 360,\n\n    // The outer radius of the chart\n    radius: '100%'\n  };\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {_parseObjectDataRadialScale} from '../helpers/index.js';\n\nexport default class RadarController extends DatasetController {\n\n  static id = 'radar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: 'line',\n    dataElementType: 'point',\n    indexAxis: 'r',\n    showLine: true,\n    elements: {\n      line: {\n        fill: 'start'\n      }\n    },\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n    aspectRatio: 1,\n\n    scales: {\n      r: {\n        type: 'radialLinear',\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const vScale = this._cachedMeta.vScale;\n    const parsed = this.getParsed(index);\n\n    return {\n      label: vScale.getLabels()[index],\n      value: '' + vScale.getLabelForValue(parsed[vScale.axis])\n    };\n  }\n\n  parseObjectData(meta, data, start, count) {\n    return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const line = meta.dataset;\n    const points = meta.data || [];\n    const labels = meta.iScale.getLabels();\n\n    // Update Line\n    line.points = points;\n    // In resize mode only point locations change, so no need to set the points or options.\n    if (mode !== 'resize') {\n      const options = this.resolveDatasetElementOptions(mode);\n      if (!this.options.showLine) {\n        options.borderWidth = 0;\n      }\n\n      const properties = {\n        _loop: true,\n        _fullLoop: labels.length === points.length,\n        options\n      };\n\n      this.updateElement(line, undefined, properties, mode);\n    }\n\n    // Update Points\n    this.updateElements(points, 0, points.length, mode);\n  }\n\n  updateElements(points, start, count, mode) {\n    const scale = this._cachedMeta.rScale;\n    const reset = mode === 'reset';\n\n    for (let i = start; i < start + count; i++) {\n      const point = points[i];\n      const options = this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);\n\n      const x = reset ? scale.xCenter : pointPosition.x;\n      const y = reset ? scale.yCenter : pointPosition.y;\n\n      const properties = {\n        x,\n        y,\n        angle: pointPosition.angle,\n        skip: isNaN(x) || isNaN(y),\n        options\n      };\n\n      this.updateElement(point, i, properties, mode);\n    }\n  }\n}\n","import DatasetController from '../core/core.datasetController.js';\nimport {isNullOrUndef} from '../helpers/index.js';\nimport {isNumber} from '../helpers/helpers.math.js';\nimport {_getStartAndCountOfVisiblePoints, _scaleRangesChanged} from '../helpers/helpers.extras.js';\n\nexport default class ScatterController extends DatasetController {\n\n  static id = 'scatter';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    datasetElementType: false,\n    dataElementType: 'point',\n    showLine: false,\n    fill: false\n  };\n\n  /**\n   * @type {any}\n   */\n  static overrides = {\n\n    interaction: {\n      mode: 'point'\n    },\n\n    scales: {\n      x: {\n        type: 'linear'\n      },\n      y: {\n        type: 'linear'\n      }\n    }\n  };\n\n  /**\n\t * @protected\n\t */\n  getLabelAndValue(index) {\n    const meta = this._cachedMeta;\n    const labels = this.chart.data.labels || [];\n    const {xScale, yScale} = meta;\n    const parsed = this.getParsed(index);\n    const x = xScale.getLabelForValue(parsed.x);\n    const y = yScale.getLabelForValue(parsed.y);\n\n    return {\n      label: labels[index] || '',\n      value: '(' + x + ', ' + y + ')'\n    };\n  }\n\n  update(mode) {\n    const meta = this._cachedMeta;\n    const {data: points = []} = meta;\n    // @ts-ignore\n    const animationsDisabled = this.chart._animationsDisabled;\n    let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);\n\n    this._drawStart = start;\n    this._drawCount = count;\n\n    if (_scaleRangesChanged(meta)) {\n      start = 0;\n      count = points.length;\n    }\n\n    if (this.options.showLine) {\n\n      // https://github.com/chartjs/Chart.js/issues/11333\n      if (!this.datasetElementType) {\n        this.addElements();\n      }\n      const {dataset: line, _dataset} = meta;\n\n      // Update Line\n      line._chart = this.chart;\n      line._datasetIndex = this.index;\n      line._decimated = !!_dataset._decimated;\n      line.points = points;\n\n      const options = this.resolveDatasetElementOptions(mode);\n      options.segment = this.options.segment;\n      this.updateElement(line, undefined, {\n        animated: !animationsDisabled,\n        options\n      }, mode);\n    } else if (this.datasetElementType) {\n      // https://github.com/chartjs/Chart.js/issues/11333\n      delete meta.dataset;\n      this.datasetElementType = false;\n    }\n\n    // Update Points\n    this.updateElements(points, start, count, mode);\n  }\n\n  addElements() {\n    const {showLine} = this.options;\n\n    if (!this.datasetElementType && showLine) {\n      this.datasetElementType = this.chart.registry.getElement('line');\n    }\n\n    super.addElements();\n  }\n\n  updateElements(points, start, count, mode) {\n    const reset = mode === 'reset';\n    const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;\n    const firstOpts = this.resolveDataElementOptions(start, mode);\n    const sharedOptions = this.getSharedOptions(firstOpts);\n    const includeOptions = this.includeOptions(mode, sharedOptions);\n    const iAxis = iScale.axis;\n    const vAxis = vScale.axis;\n    const {spanGaps, segment} = this.options;\n    const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;\n    const directUpdate = this.chart._animationsDisabled || reset || mode === 'none';\n    let prevParsed = start > 0 && this.getParsed(start - 1);\n\n    for (let i = start; i < start + count; ++i) {\n      const point = points[i];\n      const parsed = this.getParsed(i);\n      const properties = directUpdate ? point : {};\n      const nullData = isNullOrUndef(parsed[vAxis]);\n      const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);\n      const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);\n\n      properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;\n      properties.stop = i > 0 && (Math.abs(parsed[iAxis] - prevParsed[iAxis])) > maxGapLength;\n      if (segment) {\n        properties.parsed = parsed;\n        properties.raw = _dataset.data[i];\n      }\n\n      if (includeOptions) {\n        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? 'active' : mode);\n      }\n\n      if (!directUpdate) {\n        this.updateElement(point, i, properties, mode);\n      }\n\n      prevParsed = parsed;\n    }\n\n    this.updateSharedOptions(sharedOptions, mode, firstOpts);\n  }\n\n  /**\n\t * @protected\n\t */\n  getMaxOverflow() {\n    const meta = this._cachedMeta;\n    const data = meta.data || [];\n\n    if (!this.options.showLine) {\n      let max = 0;\n      for (let i = data.length - 1; i >= 0; --i) {\n        max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);\n      }\n      return max > 0 && max;\n    }\n\n    const dataset = meta.dataset;\n    const border = dataset.options && dataset.options.borderWidth || 0;\n\n    if (!data.length) {\n      return border;\n    }\n\n    const firstPoint = data[0].size(this.resolveDataElementOptions(0));\n    const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));\n    return Math.max(border, firstPoint, lastPoint) / 2;\n  }\n}\n","/**\n * @namespace Chart._adapters\n * @since 2.8.0\n * @private\n */\n\nimport type {AnyObject} from '../types/basic.js';\nimport type {ChartOptions} from '../types/index.js';\n\nexport type TimeUnit = 'millisecond' | 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'quarter' | 'year';\n\nexport interface DateAdapter<T extends AnyObject = AnyObject> {\n  readonly options: T;\n  /**\n   * Will called with chart options after adapter creation.\n   */\n  init(this: DateAdapter<T>, chartOptions: ChartOptions): void;\n  /**\n   * Returns a map of time formats for the supported formatting units defined\n   * in Unit as well as 'datetime' representing a detailed date/time string.\n   */\n  formats(this: DateAdapter<T>): Record<string, string>;\n  /**\n   * Parses the given `value` and return the associated timestamp.\n   * @param value - the value to parse (usually comes from the data)\n   * @param [format] - the expected data format\n   */\n  parse(this: DateAdapter<T>, value: unknown, format?: TimeUnit): number | null;\n  /**\n   * Returns the formatted date in the specified `format` for a given `timestamp`.\n   * @param timestamp - the timestamp to format\n   * @param format - the date/time token\n   */\n  format(this: DateAdapter<T>, timestamp: number, format: TimeUnit): string;\n  /**\n   * Adds the specified `amount` of `unit` to the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param amount - the amount to add\n   * @param unit - the unit as string\n   */\n  add(this: DateAdapter<T>, timestamp: number, amount: number, unit: TimeUnit): number;\n  /**\n   * Returns the number of `unit` between the given timestamps.\n   * @param a - the input timestamp (reference)\n   * @param b - the timestamp to subtract\n   * @param unit - the unit as string\n   */\n  diff(this: DateAdapter<T>, a: number, b: number, unit: TimeUnit): number;\n  /**\n   * Returns start of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   * @param [weekday] - the ISO day of the week with 1 being Monday\n   * and 7 being Sunday (only needed if param *unit* is `isoWeek`).\n   */\n  startOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek', weekday?: number): number;\n  /**\n   * Returns end of `unit` for the given `timestamp`.\n   * @param timestamp - the input timestamp\n   * @param unit - the unit as string\n   */\n  endOf(this: DateAdapter<T>, timestamp: number, unit: TimeUnit | 'isoWeek'): number;\n}\n\nfunction abstract<T = void>(): T {\n  throw new Error('This method is not implemented: Check that a complete date adapter is provided.');\n}\n\n/**\n * Date adapter (current used by the time scale)\n * @namespace Chart._adapters._date\n * @memberof Chart._adapters\n * @private\n */\nclass DateAdapterBase implements DateAdapter {\n\n  /**\n   * Override default date adapter methods.\n   * Accepts type parameter to define options type.\n   * @example\n   * Chart._adapters._date.override<{myAdapterOption: string}>({\n   *   init() {\n   *     console.log(this.options.myAdapterOption);\n   *   }\n   * })\n   */\n  static override<T extends AnyObject = AnyObject>(\n    members: Partial<Omit<DateAdapter<T>, 'options'>>\n  ) {\n    Object.assign(DateAdapterBase.prototype, members);\n  }\n\n  readonly options: AnyObject;\n\n  constructor(options: AnyObject) {\n    this.options = options || {};\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n  init() {}\n\n  formats(): Record<string, string> {\n    return abstract();\n  }\n\n  parse(): number | null {\n    return abstract();\n  }\n\n  format(): string {\n    return abstract();\n  }\n\n  add(): number {\n    return abstract();\n  }\n\n  diff(): number {\n    return abstract();\n  }\n\n  startOf(): number {\n    return abstract();\n  }\n\n  endOf(): number {\n    return abstract();\n  }\n}\n\nexport default {\n  _date: DateAdapterBase\n};\n","import {_lookupByKey, _rlookupByKey} from '../helpers/helpers.collection.js';\nimport {getRelativePosition} from '../helpers/helpers.dom.js';\nimport {_angleBetween, getAngleFromPoint} from '../helpers/helpers.math.js';\nimport {_isPointInArea} from '../helpers/index.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef {{axis?: string, intersect?: boolean, includeInvisible?: boolean}} InteractionOptions\n * @typedef {{datasetIndex: number, index: number, element: import('./core.element.js').default}} InteractionItem\n * @typedef { import('../types/index.js').Point } Point\n */\n\n/**\n * Helper function to do binary search when possible\n * @param {object} metaset - the dataset meta\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {number} value - the value to find\n * @param {boolean} [intersect] - should the element intersect\n * @returns {{lo:number, hi:number}} indices to search data array between\n */\nfunction binarySearch(metaset, axis, value, intersect) {\n  const {controller, data, _sorted} = metaset;\n  const iScale = controller._cachedMeta.iScale;\n  if (iScale && axis === iScale.axis && axis !== 'r' && _sorted && data.length) {\n    const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;\n    if (!intersect) {\n      return lookupMethod(data, axis, value);\n    } else if (controller._sharedOptions) {\n      // _sharedOptions indicates that each element has equal options -> equal proportions\n      // So we can do a ranged binary search based on the range of first element and\n      // be confident to get the full range of indices that can intersect with the value.\n      const el = data[0];\n      const range = typeof el.getRange === 'function' && el.getRange(axis);\n      if (range) {\n        const start = lookupMethod(data, axis, value - range);\n        const end = lookupMethod(data, axis, value + range);\n        return {lo: start.lo, hi: end.hi};\n      }\n    }\n  }\n  // Default to all elements, when binary search can not be used.\n  return {lo: 0, hi: data.length - 1};\n}\n\n/**\n * Helper function to select candidate elements for interaction\n * @param {Chart} chart - the chart\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {function} handler - the callback to execute for each visible item\n * @param {boolean} [intersect] - consider intersecting items\n */\nfunction evaluateInteractionItems(chart, axis, position, handler, intersect) {\n  const metasets = chart.getSortedVisibleDatasetMetas();\n  const value = position[axis];\n  for (let i = 0, ilen = metasets.length; i < ilen; ++i) {\n    const {index, data} = metasets[i];\n    const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);\n    for (let j = lo; j <= hi; ++j) {\n      const element = data[j];\n      if (!element.skip) {\n        handler(element, index, j);\n      }\n    }\n  }\n}\n\n/**\n * Get a distance metric function for two points based on the\n * axis mode setting\n * @param {string} axis - the axis mode. x|y|xy|r\n */\nfunction getDistanceMetricForAxis(axis) {\n  const useX = axis.indexOf('x') !== -1;\n  const useY = axis.indexOf('y') !== -1;\n\n  return function(pt1, pt2) {\n    const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;\n    const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;\n    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));\n  };\n}\n\n/**\n * Helper function to get the items that intersect the event position\n * @param {Chart} chart - the chart\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis mode. x|y|xy|r\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {\n  const items = [];\n\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return items;\n  }\n\n  const evaluationFunc = function(element, datasetIndex, index) {\n    if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) {\n      return;\n    }\n    if (element.inRange(position.x, position.y, useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n    }\n  };\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc, true);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a radial chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestRadialItems(chart, position, axis, useFinalPosition) {\n  let items = [];\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const {startAngle, endAngle} = element.getProps(['startAngle', 'endAngle'], useFinalPosition);\n    const {angle} = getAngleFromPoint(element, {x: position.x, y: position.y});\n\n    if (_angleBetween(angle, startAngle, endAngle)) {\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position for a cartesian chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  let items = [];\n  const distanceMetric = getDistanceMetricForAxis(axis);\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  function evaluationFunc(element, datasetIndex, index) {\n    const inRange = element.inRange(position.x, position.y, useFinalPosition);\n    if (intersect && !inRange) {\n      return;\n    }\n\n    const center = element.getCenterPoint(useFinalPosition);\n    const pointInArea = !!includeInvisible || chart.isPointInArea(center);\n    if (!pointInArea && !inRange) {\n      return;\n    }\n\n    const distance = distanceMetric(position, center);\n    if (distance < minDistance) {\n      items = [{element, datasetIndex, index}];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      items.push({element, datasetIndex, index});\n    }\n  }\n\n  evaluateInteractionItems(chart, axis, position, evaluationFunc);\n  return items;\n}\n\n/**\n * Helper function to get the items nearest to the event position considering all visible items in the chart\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axes along which to measure distance\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @param {boolean} [includeInvisible] - include invisible points that are outside of the chart area\n * @return {InteractionItem[]} the nearest items\n */\nfunction getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {\n  if (!includeInvisible && !chart.isPointInArea(position)) {\n    return [];\n  }\n\n  return axis === 'r' && !intersect\n    ? getNearestRadialItems(chart, position, axis, useFinalPosition)\n    : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);\n}\n\n/**\n * Helper function to get the items matching along the given X or Y axis\n * @param {Chart} chart - the chart to look at elements from\n * @param {Point} position - the point to be nearest to, in relative coordinates\n * @param {string} axis - the axis to match\n * @param {boolean} [intersect] - if true, only consider items that intersect the position\n * @param {boolean} [useFinalPosition] - use the element's animation target instead of current position\n * @return {InteractionItem[]} the nearest items\n */\nfunction getAxisItems(chart, position, axis, intersect, useFinalPosition) {\n  const items = [];\n  const rangeMethod = axis === 'x' ? 'inXRange' : 'inYRange';\n  let intersectsItem = false;\n\n  evaluateInteractionItems(chart, axis, position, (element, datasetIndex, index) => {\n    if (element[rangeMethod](position[axis], useFinalPosition)) {\n      items.push({element, datasetIndex, index});\n      intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);\n    }\n  });\n\n  // If we want to trigger on an intersect and we don't have any items\n  // that intersect the position, return nothing\n  if (intersect && !intersectsItem) {\n    return [];\n  }\n  return items;\n}\n\n/**\n * Contains interaction related functions\n * @namespace Chart.Interaction\n */\nexport default {\n  // Part of the public API to facilitate developers creating their own modes\n  evaluateInteractionItems,\n\n  // Helper function for different modes\n  modes: {\n    /**\n\t\t * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item\n\t\t * @function Chart.Interaction.modes.index\n\t\t * @since v2.4.0\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    index(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      // Default axis for index mode is 'x' to match old behaviour\n      const axis = options.axis || 'x';\n      const includeInvisible = options.includeInvisible || false;\n      const items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible)\n        : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n      const elements = [];\n\n      if (!items.length) {\n        return [];\n      }\n\n      chart.getSortedVisibleDatasetMetas().forEach((meta) => {\n        const index = items[0].index;\n        const element = meta.data[index];\n\n        // don't count items that are skipped (null data)\n        if (element && !element.skip) {\n          elements.push({element, datasetIndex: meta.index, index});\n        }\n      });\n\n      return elements;\n    },\n\n    /**\n\t\t * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something\n\t\t * If the options.intersect is false, we find the nearest item and return the items in that dataset\n\t\t * @function Chart.Interaction.modes.dataset\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    dataset(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      let items = options.intersect\n        ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) :\n        getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);\n\n      if (items.length > 0) {\n        const datasetIndex = items[0].datasetIndex;\n        const data = chart.getDatasetMeta(datasetIndex).data;\n        items = [];\n        for (let i = 0; i < data.length; ++i) {\n          items.push({element: data[i], datasetIndex, index: i});\n        }\n      }\n\n      return items;\n    },\n\n    /**\n\t\t * Point mode returns all elements that hit test based on the event position\n\t\t * of the event\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    point(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * nearest mode returns the element closest to the point\n\t\t * @function Chart.Interaction.modes.intersect\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    nearest(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      const axis = options.axis || 'xy';\n      const includeInvisible = options.includeInvisible || false;\n      return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);\n    },\n\n    /**\n\t\t * x mode returns the elements that hit-test at the current x coordinate\n\t\t * @function Chart.Interaction.modes.x\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    x(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'x', options.intersect, useFinalPosition);\n    },\n\n    /**\n\t\t * y mode returns the elements that hit-test at the current y coordinate\n\t\t * @function Chart.Interaction.modes.y\n\t\t * @param {Chart} chart - the chart we are returning items from\n\t\t * @param {Event} e - the event we are find things at\n\t\t * @param {InteractionOptions} options - options to use\n\t\t * @param {boolean} [useFinalPosition] - use final element position (animation target)\n\t\t * @return {InteractionItem[]} - items that are found\n\t\t */\n    y(chart, e, options, useFinalPosition) {\n      const position = getRelativePosition(e, chart);\n      return getAxisItems(chart, position, 'y', options.intersect, useFinalPosition);\n    }\n  }\n};\n","import {defined, each, isObject} from '../helpers/helpers.core.js';\nimport {toPadding} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n */\n\nconst STATIC_POSITIONS = ['left', 'top', 'right', 'bottom'];\n\nfunction filterByPosition(array, position) {\n  return array.filter(v => v.pos === position);\n}\n\nfunction filterDynamicPositionByAxis(array, axis) {\n  return array.filter(v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis);\n}\n\nfunction sortByWeight(array, reverse) {\n  return array.sort((a, b) => {\n    const v0 = reverse ? b : a;\n    const v1 = reverse ? a : b;\n    return v0.weight === v1.weight ?\n      v0.index - v1.index :\n      v0.weight - v1.weight;\n  });\n}\n\nfunction wrapBoxes(boxes) {\n  const layoutBoxes = [];\n  let i, ilen, box, pos, stack, stackWeight;\n\n  for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {\n    box = boxes[i];\n    ({position: pos, options: {stack, stackWeight = 1}} = box);\n    layoutBoxes.push({\n      index: i,\n      box,\n      pos,\n      horizontal: box.isHorizontal(),\n      weight: box.weight,\n      stack: stack && (pos + stack),\n      stackWeight\n    });\n  }\n  return layoutBoxes;\n}\n\nfunction buildStacks(layouts) {\n  const stacks = {};\n  for (const wrap of layouts) {\n    const {stack, pos, stackWeight} = wrap;\n    if (!stack || !STATIC_POSITIONS.includes(pos)) {\n      continue;\n    }\n    const _stack = stacks[stack] || (stacks[stack] = {count: 0, placed: 0, weight: 0, size: 0});\n    _stack.count++;\n    _stack.weight += stackWeight;\n  }\n  return stacks;\n}\n\n/**\n * store dimensions used instead of available chartArea in fitBoxes\n **/\nfunction setLayoutDims(layouts, params) {\n  const stacks = buildStacks(layouts);\n  const {vBoxMaxWidth, hBoxMaxHeight} = params;\n  let i, ilen, layout;\n  for (i = 0, ilen = layouts.length; i < ilen; ++i) {\n    layout = layouts[i];\n    const {fullSize} = layout.box;\n    const stack = stacks[layout.stack];\n    const factor = stack && layout.stackWeight / stack.weight;\n    if (layout.horizontal) {\n      layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;\n      layout.height = hBoxMaxHeight;\n    } else {\n      layout.width = vBoxMaxWidth;\n      layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;\n    }\n  }\n  return stacks;\n}\n\nfunction buildLayoutBoxes(boxes) {\n  const layoutBoxes = wrapBoxes(boxes);\n  const fullSize = sortByWeight(layoutBoxes.filter(wrap => wrap.box.fullSize), true);\n  const left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);\n  const right = sortByWeight(filterByPosition(layoutBoxes, 'right'));\n  const top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);\n  const bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));\n  const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, 'x');\n  const centerVertical = filterDynamicPositionByAxis(layoutBoxes, 'y');\n\n  return {\n    fullSize,\n    leftAndTop: left.concat(top),\n    rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),\n    chartArea: filterByPosition(layoutBoxes, 'chartArea'),\n    vertical: left.concat(right).concat(centerVertical),\n    horizontal: top.concat(bottom).concat(centerHorizontal)\n  };\n}\n\nfunction getCombinedMax(maxPadding, chartArea, a, b) {\n  return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);\n}\n\nfunction updateMaxPadding(maxPadding, boxPadding) {\n  maxPadding.top = Math.max(maxPadding.top, boxPadding.top);\n  maxPadding.left = Math.max(maxPadding.left, boxPadding.left);\n  maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);\n  maxPadding.right = Math.max(maxPadding.right, boxPadding.right);\n}\n\nfunction updateDims(chartArea, params, layout, stacks) {\n  const {pos, box} = layout;\n  const maxPadding = chartArea.maxPadding;\n\n  // dynamically placed boxes size is not considered\n  if (!isObject(pos)) {\n    if (layout.size) {\n      // this layout was already counted for, lets first reduce old size\n      chartArea[pos] -= layout.size;\n    }\n    const stack = stacks[layout.stack] || {size: 0, count: 1};\n    stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);\n    layout.size = stack.size / stack.count;\n    chartArea[pos] += layout.size;\n  }\n\n  if (box.getPadding) {\n    updateMaxPadding(maxPadding, box.getPadding());\n  }\n\n  const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right'));\n  const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom'));\n  const widthChanged = newWidth !== chartArea.w;\n  const heightChanged = newHeight !== chartArea.h;\n  chartArea.w = newWidth;\n  chartArea.h = newHeight;\n\n  // return booleans on the changes per direction\n  return layout.horizontal\n    ? {same: widthChanged, other: heightChanged}\n    : {same: heightChanged, other: widthChanged};\n}\n\nfunction handleMaxPadding(chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function updatePos(pos) {\n    const change = Math.max(maxPadding[pos] - chartArea[pos], 0);\n    chartArea[pos] += change;\n    return change;\n  }\n  chartArea.y += updatePos('top');\n  chartArea.x += updatePos('left');\n  updatePos('right');\n  updatePos('bottom');\n}\n\nfunction getMargins(horizontal, chartArea) {\n  const maxPadding = chartArea.maxPadding;\n\n  function marginForPositions(positions) {\n    const margin = {left: 0, top: 0, right: 0, bottom: 0};\n    positions.forEach((pos) => {\n      margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);\n    });\n    return margin;\n  }\n\n  return horizontal\n    ? marginForPositions(['left', 'right'])\n    : marginForPositions(['top', 'bottom']);\n}\n\nfunction fitBoxes(boxes, chartArea, params, stacks) {\n  const refitBoxes = [];\n  let i, ilen, layout, box, refit, changed;\n\n  for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {\n    layout = boxes[i];\n    box = layout.box;\n\n    box.update(\n      layout.width || chartArea.w,\n      layout.height || chartArea.h,\n      getMargins(layout.horizontal, chartArea)\n    );\n    const {same, other} = updateDims(chartArea, params, layout, stacks);\n\n    // Dimensions changed and there were non full width boxes before this\n    // -> we have to refit those\n    refit |= same && refitBoxes.length;\n\n    // Chart area changed in the opposite direction\n    changed = changed || other;\n\n    if (!box.fullSize) { // fullSize boxes don't need to be re-fitted in any case\n      refitBoxes.push(layout);\n    }\n  }\n\n  return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;\n}\n\nfunction setBoxDims(box, left, top, width, height) {\n  box.top = top;\n  box.left = left;\n  box.right = left + width;\n  box.bottom = top + height;\n  box.width = width;\n  box.height = height;\n}\n\nfunction placeBoxes(boxes, chartArea, params, stacks) {\n  const userPadding = params.padding;\n  let {x, y} = chartArea;\n\n  for (const layout of boxes) {\n    const box = layout.box;\n    const stack = stacks[layout.stack] || {count: 1, placed: 0, weight: 1};\n    const weight = (layout.stackWeight / stack.weight) || 1;\n    if (layout.horizontal) {\n      const width = chartArea.w * weight;\n      const height = stack.size || box.height;\n      if (defined(stack.start)) {\n        y = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height);\n      } else {\n        setBoxDims(box, chartArea.left + stack.placed, y, width, height);\n      }\n      stack.start = y;\n      stack.placed += width;\n      y = box.bottom;\n    } else {\n      const height = chartArea.h * weight;\n      const width = stack.size || box.width;\n      if (defined(stack.start)) {\n        x = stack.start;\n      }\n      if (box.fullSize) {\n        setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top);\n      } else {\n        setBoxDims(box, x, chartArea.top + stack.placed, width, height);\n      }\n      stack.start = x;\n      stack.placed += height;\n      x = box.right;\n    }\n  }\n\n  chartArea.x = x;\n  chartArea.y = y;\n}\n\n/**\n * @interface LayoutItem\n * @typedef {object} LayoutItem\n * @prop {string} position - The position of the item in the chart layout. Possible values are\n * 'left', 'top', 'right', 'bottom', and 'chartArea'\n * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n * @prop {boolean} fullSize - if true, and the item is horizontal, then push vertical boxes down\n * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n * @prop {function} update - Takes two parameters: width and height. Returns size of item\n * @prop {function} draw - Draws the element\n * @prop {function} [getPadding] -  Returns an object with padding on the edges\n * @prop {number} width - Width of item. Must be valid after update()\n * @prop {number} height - Height of item. Must be valid after update()\n * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update\n * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update\n * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update\n * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n */\n\n// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n// It is this service's responsibility of carrying out that layout.\nexport default {\n\n  /**\n\t * Register a box to a chart.\n\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t * @param {Chart} chart - the chart to use\n\t * @param {LayoutItem} item - the item to add to be laid out\n\t */\n  addBox(chart, item) {\n    if (!chart.boxes) {\n      chart.boxes = [];\n    }\n\n    // initialize item with default values\n    item.fullSize = item.fullSize || false;\n    item.position = item.position || 'top';\n    item.weight = item.weight || 0;\n    // @ts-ignore\n    item._layers = item._layers || function() {\n      return [{\n        z: 0,\n        draw(chartArea) {\n          item.draw(chartArea);\n        }\n      }];\n    };\n\n    chart.boxes.push(item);\n  },\n\n  /**\n\t * Remove a layoutItem from a chart\n\t * @param {Chart} chart - the chart to remove the box from\n\t * @param {LayoutItem} layoutItem - the item to remove from the layout\n\t */\n  removeBox(chart, layoutItem) {\n    const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n    if (index !== -1) {\n      chart.boxes.splice(index, 1);\n    }\n  },\n\n  /**\n\t * Sets (or updates) options on the given `item`.\n\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t * @param {LayoutItem} item - the item to configure with the given options\n\t * @param {object} options - the new item options.\n\t */\n  configure(chart, item, options) {\n    item.fullSize = options.fullSize;\n    item.position = options.position;\n    item.weight = options.weight;\n  },\n\n  /**\n\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t * then running a fitting algorithm\n\t * @param {Chart} chart - the chart\n\t * @param {number} width - the width to fit into\n\t * @param {number} height - the height to fit into\n   * @param {number} minPadding - minimum padding required for each side of chart area\n\t */\n  update(chart, width, height, minPadding) {\n    if (!chart) {\n      return;\n    }\n\n    const padding = toPadding(chart.options.layout.padding);\n    const availableWidth = Math.max(width - padding.width, 0);\n    const availableHeight = Math.max(height - padding.height, 0);\n    const boxes = buildLayoutBoxes(chart.boxes);\n    const verticalBoxes = boxes.vertical;\n    const horizontalBoxes = boxes.horizontal;\n\n    // Before any changes are made, notify boxes that an update is about to being\n    // This is used to clear any cached data (e.g. scale limits)\n    each(chart.boxes, box => {\n      if (typeof box.beforeLayout === 'function') {\n        box.beforeLayout();\n      }\n    });\n\n    // Essentially we now have any number of boxes on each of the 4 sides.\n    // Our canvas looks like the following.\n    // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n    // B1 is the bottom axis\n    // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n    // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n    // an error will be thrown.\n    //\n    // |----------------------------------------------------|\n    // |                  T1 (Full Width)                   |\n    // |----------------------------------------------------|\n    // |    |    |                 T2                  |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    | C1 |                           | C2 |    |\n    // |    |    |----|                           |----|    |\n    // |    |    |                                     |    |\n    // | L1 | L2 |           ChartArea (C0)            | R1 |\n    // |    |    |                                     |    |\n    // |    |    |----|                           |----|    |\n    // |    |    | C3 |                           | C4 |    |\n    // |    |----|-------------------------------------|----|\n    // |    |    |                 B1                  |    |\n    // |----------------------------------------------------|\n    // |                  B2 (Full Width)                   |\n    // |----------------------------------------------------|\n    //\n\n    const visibleVerticalBoxCount = verticalBoxes.reduce((total, wrap) =>\n      wrap.box.options && wrap.box.options.display === false ? total : total + 1, 0) || 1;\n\n    const params = Object.freeze({\n      outerWidth: width,\n      outerHeight: height,\n      padding,\n      availableWidth,\n      availableHeight,\n      vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,\n      hBoxMaxHeight: availableHeight / 2\n    });\n    const maxPadding = Object.assign({}, padding);\n    updateMaxPadding(maxPadding, toPadding(minPadding));\n    const chartArea = Object.assign({\n      maxPadding,\n      w: availableWidth,\n      h: availableHeight,\n      x: padding.left,\n      y: padding.top\n    }, padding);\n\n    const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);\n\n    // First fit the fullSize boxes, to reduce probability of re-fitting.\n    fitBoxes(boxes.fullSize, chartArea, params, stacks);\n\n    // Then fit vertical boxes\n    fitBoxes(verticalBoxes, chartArea, params, stacks);\n\n    // Then fit horizontal boxes\n    if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) {\n      // if the area changed, re-fit vertical boxes\n      fitBoxes(verticalBoxes, chartArea, params, stacks);\n    }\n\n    handleMaxPadding(chartArea);\n\n    // Finally place the boxes to correct coordinates\n    placeBoxes(boxes.leftAndTop, chartArea, params, stacks);\n\n    // Move to opposite side of chart\n    chartArea.x += chartArea.w;\n    chartArea.y += chartArea.h;\n\n    placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);\n\n    chart.chartArea = {\n      left: chartArea.left,\n      top: chartArea.top,\n      right: chartArea.left + chartArea.w,\n      bottom: chartArea.top + chartArea.h,\n      height: chartArea.h,\n      width: chartArea.w,\n    };\n\n    // Finally update boxes in chartArea (radial scale for example)\n    each(boxes.chartArea, (layout) => {\n      const box = layout.box;\n      Object.assign(box, chart.chartArea);\n      box.update(chartArea.w, chartArea.h, {left: 0, top: 0, right: 0, bottom: 0});\n    });\n  }\n};\n","\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\n/**\n * Abstract class that allows abstracting platform dependencies away from the chart.\n */\nexport default class BasePlatform {\n  /**\n\t * Called at chart construction time, returns a context2d instance implementing\n\t * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.\n\t * @param {HTMLCanvasElement} canvas - The canvas from which to acquire context (platform specific)\n\t * @param {number} [aspectRatio] - The chart options\n\t */\n  acquireContext(canvas, aspectRatio) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Called at chart destruction time, releases any resources associated to the context\n\t * previously returned by the acquireContext() method.\n\t * @param {CanvasRenderingContext2D} context - The context2d instance\n\t * @returns {boolean} true if the method succeeded, else false\n\t */\n  releaseContext(context) { // eslint-disable-line no-unused-vars\n    return false;\n  }\n\n  /**\n\t * Registers the specified listener on the given chart.\n\t * @param {Chart} chart - Chart from which to listen for event\n\t * @param {string} type - The ({@link ChartEvent}) type to listen for\n\t * @param {function} listener - Receives a notification (an object that implements\n\t * the {@link ChartEvent} interface) when an event of the specified type occurs.\n\t */\n  addEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Removes the specified listener previously registered with addEventListener.\n\t * @param {Chart} chart - Chart from which to remove the listener\n\t * @param {string} type - The ({@link ChartEvent}) type to remove\n\t * @param {function} listener - The listener function to remove from the event target.\n\t */\n  removeEventListener(chart, type, listener) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * @returns {number} the current devicePixelRatio of the device this platform is connected to.\n\t */\n  getDevicePixelRatio() {\n    return 1;\n  }\n\n  /**\n\t * Returns the maximum size in pixels of given canvas element.\n\t * @param {HTMLCanvasElement} element\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(element, width, height, aspectRatio) {\n    width = Math.max(0, width || element.width);\n    height = height || element.height;\n    return {\n      width,\n      height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)\n    };\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @returns {boolean} true if the canvas is attached to the platform, false if not.\n\t */\n  isAttached(canvas) { // eslint-disable-line no-unused-vars\n    return true;\n  }\n\n  /**\n   * Updates config with platform specific requirements\n   * @param {import('../core/core.config.js').default} config\n   */\n  updateConfig(config) { // eslint-disable-line no-unused-vars\n    // no-op\n  }\n}\n","/**\n * Platform fallback implementation (minimal).\n * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939\n */\n\nimport BasePlatform from './platform.base.js';\n\n/**\n * Platform class for charts without access to the DOM or to many element properties\n * This platform is used by default for any chart passed an OffscreenCanvas.\n * @extends BasePlatform\n */\nexport default class BasicPlatform extends BasePlatform {\n  acquireContext(item) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    return item && item.getContext && item.getContext('2d') || null;\n  }\n  updateConfig(config) {\n    config.options.animation = false;\n  }\n}\n","/**\n * Chart.Platform implementation for targeting a web browser\n */\n\nimport BasePlatform from './platform.base.js';\nimport {_getParentNode, getRelativePosition, supportsEventListenerOptions, readUsedSize, getMaximumSize} from '../helpers/helpers.dom.js';\nimport {throttled} from '../helpers/helpers.extras.js';\nimport {isNullOrUndef} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('../core/core.controller.js').default } Chart\n */\n\nconst EXPANDO_KEY = '$chartjs';\n\n/**\n * DOM event types -> Chart.js event types.\n * Note: only events with different types are mapped.\n * @see https://developer.mozilla.org/en-US/docs/Web/Events\n */\nconst EVENT_TYPES = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup',\n  pointerenter: 'mouseenter',\n  pointerdown: 'mousedown',\n  pointermove: 'mousemove',\n  pointerup: 'mouseup',\n  pointerleave: 'mouseout',\n  pointerout: 'mouseout'\n};\n\nconst isNullOrEmpty = value => value === null || value === '';\n/**\n * Initializes the canvas style and render size without modifying the canvas display size,\n * since responsiveness is handled by the controller.resize() method. The config is used\n * to determine the aspect ratio to apply in case no explicit height has been specified.\n * @param {HTMLCanvasElement} canvas\n * @param {number} [aspectRatio]\n */\nfunction initCanvas(canvas, aspectRatio) {\n  const style = canvas.style;\n\n  // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it\n  // returns null or '' if no explicit value has been set to the canvas attribute.\n  const renderHeight = canvas.getAttribute('height');\n  const renderWidth = canvas.getAttribute('width');\n\n  // Chart.js modifies some canvas values that we want to restore on destroy\n  canvas[EXPANDO_KEY] = {\n    initial: {\n      height: renderHeight,\n      width: renderWidth,\n      style: {\n        display: style.display,\n        height: style.height,\n        width: style.width\n      }\n    }\n  };\n\n  // Force canvas to display as block to avoid extra space caused by inline\n  // elements, which would interfere with the responsive resize process.\n  // https://github.com/chartjs/Chart.js/issues/2538\n  style.display = style.display || 'block';\n  // Include possible borders in the size\n  style.boxSizing = style.boxSizing || 'border-box';\n\n  if (isNullOrEmpty(renderWidth)) {\n    const displayWidth = readUsedSize(canvas, 'width');\n    if (displayWidth !== undefined) {\n      canvas.width = displayWidth;\n    }\n  }\n\n  if (isNullOrEmpty(renderHeight)) {\n    if (canvas.style.height === '') {\n      // If no explicit render height and style height, let's apply the aspect ratio,\n      // which one can be specified by the user but also by charts as default option\n      // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.\n      canvas.height = canvas.width / (aspectRatio || 2);\n    } else {\n      const displayHeight = readUsedSize(canvas, 'height');\n      if (displayHeight !== undefined) {\n        canvas.height = displayHeight;\n      }\n    }\n  }\n\n  return canvas;\n}\n\n// Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\nconst eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;\n\nfunction addListener(node, type, listener) {\n  node.addEventListener(type, listener, eventListenerOptions);\n}\n\nfunction removeListener(chart, type, listener) {\n  chart.canvas.removeEventListener(type, listener, eventListenerOptions);\n}\n\nfunction fromNativeEvent(event, chart) {\n  const type = EVENT_TYPES[event.type] || event.type;\n  const {x, y} = getRelativePosition(event, chart);\n  return {\n    type,\n    chart,\n    native: event,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null,\n  };\n}\n\nfunction nodeListContains(nodeList, canvas) {\n  for (const node of nodeList) {\n    if (node === canvas || node.contains(canvas)) {\n      return true;\n    }\n  }\n}\n\nfunction createAttachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.addedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.removedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nfunction createDetachObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const observer = new MutationObserver(entries => {\n    let trigger = false;\n    for (const entry of entries) {\n      trigger = trigger || nodeListContains(entry.removedNodes, canvas);\n      trigger = trigger && !nodeListContains(entry.addedNodes, canvas);\n    }\n    if (trigger) {\n      listener();\n    }\n  });\n  observer.observe(document, {childList: true, subtree: true});\n  return observer;\n}\n\nconst drpListeningCharts = new Map();\nlet oldDevicePixelRatio = 0;\n\nfunction onWindowResize() {\n  const dpr = window.devicePixelRatio;\n  if (dpr === oldDevicePixelRatio) {\n    return;\n  }\n  oldDevicePixelRatio = dpr;\n  drpListeningCharts.forEach((resize, chart) => {\n    if (chart.currentDevicePixelRatio !== dpr) {\n      resize();\n    }\n  });\n}\n\nfunction listenDevicePixelRatioChanges(chart, resize) {\n  if (!drpListeningCharts.size) {\n    window.addEventListener('resize', onWindowResize);\n  }\n  drpListeningCharts.set(chart, resize);\n}\n\nfunction unlistenDevicePixelRatioChanges(chart) {\n  drpListeningCharts.delete(chart);\n  if (!drpListeningCharts.size) {\n    window.removeEventListener('resize', onWindowResize);\n  }\n}\n\nfunction createResizeObserver(chart, type, listener) {\n  const canvas = chart.canvas;\n  const container = canvas && _getParentNode(canvas);\n  if (!container) {\n    return;\n  }\n  const resize = throttled((width, height) => {\n    const w = container.clientWidth;\n    listener(width, height);\n    if (w < container.clientWidth) {\n      // If the container size shrank during chart resize, let's assume\n      // scrollbar appeared. So we resize again with the scrollbar visible -\n      // effectively making chart smaller and the scrollbar hidden again.\n      // Because we are inside `throttled`, and currently `ticking`, scroll\n      // events are ignored during this whole 2 resize process.\n      // If we assumed wrong and something else happened, we are resizing\n      // twice in a frame (potential performance issue)\n      listener();\n    }\n  }, window);\n\n  // @ts-ignore until https://github.com/microsoft/TypeScript/issues/37861 implemented\n  const observer = new ResizeObserver(entries => {\n    const entry = entries[0];\n    const width = entry.contentRect.width;\n    const height = entry.contentRect.height;\n    // When its container's display is set to 'none' the callback will be called with a\n    // size of (0, 0), which will cause the chart to lose its original height, so skip\n    // resizing in such case.\n    if (width === 0 && height === 0) {\n      return;\n    }\n    resize(width, height);\n  });\n  observer.observe(container);\n  listenDevicePixelRatioChanges(chart, resize);\n\n  return observer;\n}\n\nfunction releaseObserver(chart, type, observer) {\n  if (observer) {\n    observer.disconnect();\n  }\n  if (type === 'resize') {\n    unlistenDevicePixelRatioChanges(chart);\n  }\n}\n\nfunction createProxyAndListen(chart, type, listener) {\n  const canvas = chart.canvas;\n  const proxy = throttled((event) => {\n    // This case can occur if the chart is destroyed while waiting\n    // for the throttled function to occur. We prevent crashes by checking\n    // for a destroyed chart\n    if (chart.ctx !== null) {\n      listener(fromNativeEvent(event, chart));\n    }\n  }, chart);\n\n  addListener(canvas, type, proxy);\n\n  return proxy;\n}\n\n/**\n * Platform class for charts that can access the DOM and global window/document properties\n * @extends BasePlatform\n */\nexport default class DomPlatform extends BasePlatform {\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [aspectRatio]\n\t * @return {CanvasRenderingContext2D|null}\n\t */\n  acquireContext(canvas, aspectRatio) {\n    // To prevent canvas fingerprinting, some add-ons undefine the getContext\n    // method, for example: https://github.com/kkapsner/CanvasBlocker\n    // https://github.com/chartjs/Chart.js/issues/2807\n    const context = canvas && canvas.getContext && canvas.getContext('2d');\n\n    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the canvas is\n    // inside an iframe or when running in a protected environment. We could guess the\n    // types from their toString() value but let's keep things flexible and assume it's\n    // a sufficient condition if the canvas has a context2D which has canvas as `canvas`.\n    // https://github.com/chartjs/Chart.js/issues/3887\n    // https://github.com/chartjs/Chart.js/issues/4102\n    // https://github.com/chartjs/Chart.js/issues/4152\n    if (context && context.canvas === canvas) {\n      // Load platform resources on first chart creation, to make it possible to\n      // import the library before setting platform options.\n      initCanvas(canvas, aspectRatio);\n      return context;\n    }\n\n    return null;\n  }\n\n  /**\n\t * @param {CanvasRenderingContext2D} context\n\t */\n  releaseContext(context) {\n    const canvas = context.canvas;\n    if (!canvas[EXPANDO_KEY]) {\n      return false;\n    }\n\n    const initial = canvas[EXPANDO_KEY].initial;\n    ['height', 'width'].forEach((prop) => {\n      const value = initial[prop];\n      if (isNullOrUndef(value)) {\n        canvas.removeAttribute(prop);\n      } else {\n        canvas.setAttribute(prop, value);\n      }\n    });\n\n    const style = initial.style || {};\n    Object.keys(style).forEach((key) => {\n      canvas.style[key] = style[key];\n    });\n\n    // The canvas render size might have been changed (and thus the state stack discarded),\n    // we can't use save() and restore() to restore the initial state. So make sure that at\n    // least the canvas context is reset to the default state by setting the canvas width.\n    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html\n    // eslint-disable-next-line no-self-assign\n    canvas.width = canvas.width;\n\n    delete canvas[EXPANDO_KEY];\n    return true;\n  }\n\n  /**\n\t *\n\t * @param {Chart} chart\n\t * @param {string} type\n\t * @param {function} listener\n\t */\n  addEventListener(chart, type, listener) {\n    // Can have only one listener per type, so make sure previous is removed\n    this.removeEventListener(chart, type);\n\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const handlers = {\n      attach: createAttachObserver,\n      detach: createDetachObserver,\n      resize: createResizeObserver\n    };\n    const handler = handlers[type] || createProxyAndListen;\n    proxies[type] = handler(chart, type, listener);\n  }\n\n\n  /**\n\t * @param {Chart} chart\n\t * @param {string} type\n\t */\n  removeEventListener(chart, type) {\n    const proxies = chart.$proxies || (chart.$proxies = {});\n    const proxy = proxies[type];\n\n    if (!proxy) {\n      return;\n    }\n\n    const handlers = {\n      attach: releaseObserver,\n      detach: releaseObserver,\n      resize: releaseObserver\n    };\n    const handler = handlers[type] || removeListener;\n    handler(chart, type, proxy);\n    proxies[type] = undefined;\n  }\n\n  getDevicePixelRatio() {\n    return window.devicePixelRatio;\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t * @param {number} [width] - content width of parent element\n\t * @param {number} [height] - content height of parent element\n\t * @param {number} [aspectRatio] - aspect ratio to maintain\n\t */\n  getMaximumSize(canvas, width, height, aspectRatio) {\n    return getMaximumSize(canvas, width, height, aspectRatio);\n  }\n\n  /**\n\t * @param {HTMLCanvasElement} canvas\n\t */\n  isAttached(canvas) {\n    const container = _getParentNode(canvas);\n    return !!(container && container.isConnected);\n  }\n}\n","import type {AnyObject} from '../types/basic.js';\nimport type {Point} from '../types/geometric.js';\nimport type {Animation} from '../types/animation.js';\nimport {isNumber} from '../helpers/helpers.math.js';\n\nexport default class Element<T = AnyObject, O = AnyObject> {\n\n  static defaults = {};\n  static defaultRoutes = undefined;\n\n  x: number;\n  y: number;\n  active = false;\n  options: O;\n  $animations: Record<keyof T, Animation>;\n\n  tooltipPosition(useFinalPosition: boolean): Point {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y} as Point;\n  }\n\n  hasValue() {\n    return isNumber(this.x) && isNumber(this.y);\n  }\n\n  /**\n   * Gets the current or final value of each prop. Can return extra properties (whole object).\n   * @param props - properties to get\n   * @param [final] - get the final value (animation target)\n   */\n  getProps<P extends (keyof T)[]>(props: P, final?: boolean): Pick<T, P[number]>;\n  getProps<P extends string>(props: P[], final?: boolean): Partial<Record<P, unknown>>;\n  getProps(props: string[], final?: boolean): Partial<Record<string, unknown>> {\n    const anims = this.$animations;\n    if (!final || !anims) {\n      // let's not create an object, if not needed\n      return this as Record<string, unknown>;\n    }\n    const ret: Record<string, unknown> = {};\n    props.forEach((prop) => {\n      ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop as string];\n    });\n    return ret;\n  }\n}\n","import {isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\nimport {_factorize} from '../helpers/helpers.math.js';\n\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a subset of ticks to be plotted to avoid overlapping labels.\n * @param {import('./core.scale.js').default} scale\n * @param {Tick[]} ticks\n * @return {Tick[]}\n * @private\n */\nexport function autoSkip(scale, ticks) {\n  const tickOpts = scale.options.ticks;\n  const determinedMaxTicks = determineMaxTicks(scale);\n  const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);\n  const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];\n  const numMajorIndices = majorIndices.length;\n  const first = majorIndices[0];\n  const last = majorIndices[numMajorIndices - 1];\n  const newTicks = [];\n\n  // If there are too many major ticks to display them all\n  if (numMajorIndices > ticksLimit) {\n    skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);\n    return newTicks;\n  }\n\n  const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);\n\n  if (numMajorIndices > 0) {\n    let i, ilen;\n    const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;\n    skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);\n    for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {\n      skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);\n    }\n    skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);\n    return newTicks;\n  }\n  skip(ticks, newTicks, spacing);\n  return newTicks;\n}\n\nfunction determineMaxTicks(scale) {\n  const offset = scale.options.offset;\n  const tickLength = scale._tickSize();\n  const maxScale = scale._length / tickLength + (offset ? 0 : 1);\n  const maxChart = scale._maxLength / tickLength;\n  return Math.floor(Math.min(maxScale, maxChart));\n}\n\n/**\n * @param {number[]} majorIndices\n * @param {Tick[]} ticks\n * @param {number} ticksLimit\n */\nfunction calculateSpacing(majorIndices, ticks, ticksLimit) {\n  const evenMajorSpacing = getEvenSpacing(majorIndices);\n  const spacing = ticks.length / ticksLimit;\n\n  // If the major ticks are evenly spaced apart, place the minor ticks\n  // so that they divide the major ticks into even chunks\n  if (!evenMajorSpacing) {\n    return Math.max(spacing, 1);\n  }\n\n  const factors = _factorize(evenMajorSpacing);\n  for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {\n    const factor = factors[i];\n    if (factor > spacing) {\n      return factor;\n    }\n  }\n  return Math.max(spacing, 1);\n}\n\n/**\n * @param {Tick[]} ticks\n */\nfunction getMajorIndices(ticks) {\n  const result = [];\n  let i, ilen;\n  for (i = 0, ilen = ticks.length; i < ilen; i++) {\n    if (ticks[i].major) {\n      result.push(i);\n    }\n  }\n  return result;\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number[]} majorIndices\n * @param {number} spacing\n */\nfunction skipMajors(ticks, newTicks, majorIndices, spacing) {\n  let count = 0;\n  let next = majorIndices[0];\n  let i;\n\n  spacing = Math.ceil(spacing);\n  for (i = 0; i < ticks.length; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = majorIndices[count * spacing];\n    }\n  }\n}\n\n/**\n * @param {Tick[]} ticks\n * @param {Tick[]} newTicks\n * @param {number} spacing\n * @param {number} [majorStart]\n * @param {number} [majorEnd]\n */\nfunction skip(ticks, newTicks, spacing, majorStart, majorEnd) {\n  const start = valueOrDefault(majorStart, 0);\n  const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);\n  let count = 0;\n  let length, i, next;\n\n  spacing = Math.ceil(spacing);\n  if (majorEnd) {\n    length = majorEnd - majorStart;\n    spacing = length / Math.floor(length / spacing);\n  }\n\n  next = start;\n\n  while (next < 0) {\n    count++;\n    next = Math.round(start + count * spacing);\n  }\n\n  for (i = Math.max(start, 0); i < end; i++) {\n    if (i === next) {\n      newTicks.push(ticks[i]);\n      count++;\n      next = Math.round(start + count * spacing);\n    }\n  }\n}\n\n\n/**\n * @param {number[]} arr\n */\nfunction getEvenSpacing(arr) {\n  const len = arr.length;\n  let i, diff;\n\n  if (len < 2) {\n    return false;\n  }\n\n  for (diff = arr[0], i = 1; i < len; ++i) {\n    if (arr[i] - arr[i - 1] !== diff) {\n      return false;\n    }\n  }\n  return diff;\n}\n","import Element from './core.element.js';\nimport {_alignPixel, _measureText, renderText, clipArea, unclipArea} from '../helpers/helpers.canvas.js';\nimport {callback as call, each, finiteOrDefault, isArray, isFinite, isNullOrUndef, isObject, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toDegrees, toRadians, _int16Range, _limitValue, HALF_PI} from '../helpers/helpers.math.js';\nimport {_alignStartEnd, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {createContext, toFont, toPadding, _addGrace} from '../helpers/helpers.options.js';\nimport {autoSkip} from './core.scale.autoskip.js';\n\nconst reverseAlign = (align) => align === 'left' ? 'right' : align === 'right' ? 'left' : align;\nconst offsetFromEdge = (scale, edge, offset) => edge === 'top' || edge === 'left' ? scale[edge] + offset : scale[edge] - offset;\nconst getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);\n\n/**\n * @typedef { import('../types/index.js').Chart } Chart\n * @typedef {{value:number | string, label?:string, major?:boolean, $context?:any}} Tick\n */\n\n/**\n * Returns a new array containing numItems from arr\n * @param {any[]} arr\n * @param {number} numItems\n */\nfunction sample(arr, numItems) {\n  const result = [];\n  const increment = arr.length / numItems;\n  const len = arr.length;\n  let i = 0;\n\n  for (; i < len; i += increment) {\n    result.push(arr[Math.floor(i)]);\n  }\n  return result;\n}\n\n/**\n * @param {Scale} scale\n * @param {number} index\n * @param {boolean} offsetGridLines\n */\nfunction getPixelForGridLine(scale, index, offsetGridLines) {\n  const length = scale.ticks.length;\n  const validIndex = Math.min(index, length - 1);\n  const start = scale._startPixel;\n  const end = scale._endPixel;\n  const epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.\n  let lineValue = scale.getPixelForTick(validIndex);\n  let offset;\n\n  if (offsetGridLines) {\n    if (length === 1) {\n      offset = Math.max(lineValue - start, end - lineValue);\n    } else if (index === 0) {\n      offset = (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;\n    }\n    lineValue += validIndex < index ? offset : -offset;\n\n    // Return undefined if the pixel is out of the range\n    if (lineValue < start - epsilon || lineValue > end + epsilon) {\n      return;\n    }\n  }\n  return lineValue;\n}\n\n/**\n * @param {object} caches\n * @param {number} length\n */\nfunction garbageCollect(caches, length) {\n  each(caches, (cache) => {\n    const gc = cache.gc;\n    const gcLen = gc.length / 2;\n    let i;\n    if (gcLen > length) {\n      for (i = 0; i < gcLen; ++i) {\n        delete cache.data[gc[i]];\n      }\n      gc.splice(0, gcLen);\n    }\n  });\n}\n\n/**\n * @param {object} options\n */\nfunction getTickMarkLength(options) {\n  return options.drawTicks ? options.tickLength : 0;\n}\n\n/**\n * @param {object} options\n */\nfunction getTitleHeight(options, fallback) {\n  if (!options.display) {\n    return 0;\n  }\n\n  const font = toFont(options.font, fallback);\n  const padding = toPadding(options.padding);\n  const lines = isArray(options.text) ? options.text.length : 1;\n\n  return (lines * font.lineHeight) + padding.height;\n}\n\nfunction createScaleContext(parent, scale) {\n  return createContext(parent, {\n    scale,\n    type: 'scale'\n  });\n}\n\nfunction createTickContext(parent, index, tick) {\n  return createContext(parent, {\n    tick,\n    index,\n    type: 'tick'\n  });\n}\n\nfunction titleAlign(align, position, reverse) {\n  /** @type {CanvasTextAlign} */\n  let ret = _toLeftRightCenter(align);\n  if ((reverse && position !== 'right') || (!reverse && position === 'right')) {\n    ret = reverseAlign(ret);\n  }\n  return ret;\n}\n\nfunction titleArgs(scale, offset, position, align) {\n  const {top, left, bottom, right, chart} = scale;\n  const {chartArea, scales} = chart;\n  let rotation = 0;\n  let maxWidth, titleX, titleY;\n  const height = bottom - top;\n  const width = right - left;\n\n  if (scale.isHorizontal()) {\n    titleX = _alignStartEnd(align, left, right);\n\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;\n    } else if (position === 'center') {\n      titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset;\n    } else {\n      titleY = offsetFromEdge(scale, position, offset);\n    }\n    maxWidth = right - left;\n  } else {\n    if (isObject(position)) {\n      const positionAxisID = Object.keys(position)[0];\n      const value = position[positionAxisID];\n      titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;\n    } else if (position === 'center') {\n      titleX = (chartArea.left + chartArea.right) / 2 - width + offset;\n    } else {\n      titleX = offsetFromEdge(scale, position, offset);\n    }\n    titleY = _alignStartEnd(align, bottom, top);\n    rotation = position === 'left' ? -HALF_PI : HALF_PI;\n  }\n  return {titleX, titleY, maxWidth, rotation};\n}\n\nexport default class Scale extends Element {\n\n  // eslint-disable-next-line max-statements\n  constructor(cfg) {\n    super();\n\n    /** @type {string} */\n    this.id = cfg.id;\n    /** @type {string} */\n    this.type = cfg.type;\n    /** @type {any} */\n    this.options = undefined;\n    /** @type {CanvasRenderingContext2D} */\n    this.ctx = cfg.ctx;\n    /** @type {Chart} */\n    this.chart = cfg.chart;\n\n    // implements box\n    /** @type {number} */\n    this.top = undefined;\n    /** @type {number} */\n    this.bottom = undefined;\n    /** @type {number} */\n    this.left = undefined;\n    /** @type {number} */\n    this.right = undefined;\n    /** @type {number} */\n    this.width = undefined;\n    /** @type {number} */\n    this.height = undefined;\n    this._margins = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    };\n    /** @type {number} */\n    this.maxWidth = undefined;\n    /** @type {number} */\n    this.maxHeight = undefined;\n    /** @type {number} */\n    this.paddingTop = undefined;\n    /** @type {number} */\n    this.paddingBottom = undefined;\n    /** @type {number} */\n    this.paddingLeft = undefined;\n    /** @type {number} */\n    this.paddingRight = undefined;\n\n    // scale-specific properties\n    /** @type {string=} */\n    this.axis = undefined;\n    /** @type {number=} */\n    this.labelRotation = undefined;\n    this.min = undefined;\n    this.max = undefined;\n    this._range = undefined;\n    /** @type {Tick[]} */\n    this.ticks = [];\n    /** @type {object[]|null} */\n    this._gridLineItems = null;\n    /** @type {object[]|null} */\n    this._labelItems = null;\n    /** @type {object|null} */\n    this._labelSizes = null;\n    this._length = 0;\n    this._maxLength = 0;\n    this._longestTextCache = {};\n    /** @type {number} */\n    this._startPixel = undefined;\n    /** @type {number} */\n    this._endPixel = undefined;\n    this._reversePixels = false;\n    this._userMax = undefined;\n    this._userMin = undefined;\n    this._suggestedMax = undefined;\n    this._suggestedMin = undefined;\n    this._ticksLength = 0;\n    this._borderValue = 0;\n    this._cache = {};\n    this._dataLimitsCached = false;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @param {any} options\n\t * @since 3.0\n\t */\n  init(options) {\n    this.options = options.setContext(this.getContext());\n\n    this.axis = options.axis;\n\n    // parse min/max value, so we can properly determine min/max for other scales\n    this._userMin = this.parse(options.min);\n    this._userMax = this.parse(options.max);\n    this._suggestedMin = this.parse(options.suggestedMin);\n    this._suggestedMax = this.parse(options.suggestedMax);\n  }\n\n  /**\n\t * Parse a supported input value to internal representation.\n\t * @param {*} raw\n\t * @param {number} [index]\n\t * @since 3.0\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    return raw;\n  }\n\n  /**\n\t * @return {{min: number, max: number, minDefined: boolean, maxDefined: boolean}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getUserBounds() {\n    let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;\n    _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);\n    _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);\n    _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);\n    _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);\n    return {\n      min: finiteOrDefault(_userMin, _suggestedMin),\n      max: finiteOrDefault(_userMax, _suggestedMax),\n      minDefined: isFinite(_userMin),\n      maxDefined: isFinite(_userMax)\n    };\n  }\n\n  /**\n\t * @param {boolean} canStack\n\t * @return {{min: number, max: number}}\n\t * @protected\n\t * @since 3.0\n\t */\n  getMinMax(canStack) {\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n    let range;\n\n    if (minDefined && maxDefined) {\n      return {min, max};\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n    for (let i = 0, ilen = metas.length; i < ilen; ++i) {\n      range = metas[i].controller.getMinMax(this, canStack);\n      if (!minDefined) {\n        min = Math.min(min, range.min);\n      }\n      if (!maxDefined) {\n        max = Math.max(max, range.max);\n      }\n    }\n\n    // Make sure min <= max when only min or max is defined by user and the data is outside that range\n    min = maxDefined && min > max ? max : min;\n    max = minDefined && min > max ? min : max;\n\n    return {\n      min: finiteOrDefault(min, finiteOrDefault(max, min)),\n      max: finiteOrDefault(max, finiteOrDefault(min, max))\n    };\n  }\n\n  /**\n\t * Get the padding needed for the scale\n\t * @return {{top: number, left: number, bottom: number, right: number}} the necessary padding\n\t * @private\n\t */\n  getPadding() {\n    return {\n      left: this.paddingLeft || 0,\n      top: this.paddingTop || 0,\n      right: this.paddingRight || 0,\n      bottom: this.paddingBottom || 0\n    };\n  }\n\n  /**\n\t * Returns the scale tick objects\n\t * @return {Tick[]}\n\t * @since 2.7\n\t */\n  getTicks() {\n    return this.ticks;\n  }\n\n  /**\n\t * @return {string[]}\n\t */\n  getLabels() {\n    const data = this.chart.data;\n    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];\n  }\n\n  /**\n   * @return {import('../types.js').LabelItem[]}\n   */\n  getLabelItems(chartArea = this.chart.chartArea) {\n    const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));\n    return items;\n  }\n\n  // When a new layout is created, reset the data limits cache\n  beforeLayout() {\n    this._cache = {};\n    this._dataLimitsCached = false;\n  }\n\n  // These methods are ordered by lifecycle. Utilities then follow.\n  // Any function defined here is inherited by all scale types.\n  // Any function can be extended by the scale type\n\n  beforeUpdate() {\n    call(this.options.beforeUpdate, [this]);\n  }\n\n  /**\n\t * @param {number} maxWidth - the max width in pixels\n\t * @param {number} maxHeight - the max height in pixels\n\t * @param {{top: number, left: number, bottom: number, right: number}} margins - the space between the edge of the other scales and edge of the chart\n\t *   This space comes from two sources:\n\t *     - padding - space that's required to show the labels at the edges of the scale\n\t *     - thickness of scales or legends in another orientation\n\t */\n  update(maxWidth, maxHeight, margins) {\n    const {beginAtZero, grace, ticks: tickOpts} = this.options;\n    const sampleSize = tickOpts.sampleSize;\n\n    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n    this.beforeUpdate();\n\n    // Absorb the master measurements\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins = Object.assign({\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    }, margins);\n\n    this.ticks = null;\n    this._labelSizes = null;\n    this._gridLineItems = null;\n    this._labelItems = null;\n\n    // Dimensions\n    this.beforeSetDimensions();\n    this.setDimensions();\n    this.afterSetDimensions();\n\n    this._maxLength = this.isHorizontal()\n      ? this.width + margins.left + margins.right\n      : this.height + margins.top + margins.bottom;\n\n    // Data min/max\n    if (!this._dataLimitsCached) {\n      this.beforeDataLimits();\n      this.determineDataLimits();\n      this.afterDataLimits();\n      this._range = _addGrace(this, grace, beginAtZero);\n      this._dataLimitsCached = true;\n    }\n\n    this.beforeBuildTicks();\n\n    this.ticks = this.buildTicks() || [];\n\n    // Allow modification of ticks in callback.\n    this.afterBuildTicks();\n\n    // Compute tick rotation and fit using a sampled subset of labels\n    // We generally don't need to compute the size of every single label for determining scale size\n    const samplingEnabled = sampleSize < this.ticks.length;\n    this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);\n\n    // configure is called twice, once here, once from core.controller.updateLayout.\n    // Here we haven't been positioned yet, but dimensions are correct.\n    // Variables set in configure are needed for calculateLabelRotation, and\n    // it's ok that coordinates are not correct there, only dimensions matter.\n    this.configure();\n\n    // Tick Rotation\n    this.beforeCalculateLabelRotation();\n    this.calculateLabelRotation(); // Preconditions: number of ticks and sizes of largest labels must be calculated beforehand\n    this.afterCalculateLabelRotation();\n\n    // Auto-skip\n    if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto')) {\n      this.ticks = autoSkip(this, this.ticks);\n      this._labelSizes = null;\n      this.afterAutoSkip();\n    }\n\n    if (samplingEnabled) {\n      // Generate labels using all non-skipped ticks\n      this._convertTicksToLabels(this.ticks);\n    }\n\n    this.beforeFit();\n    this.fit(); // Preconditions: label rotation and label sizes must be calculated beforehand\n    this.afterFit();\n\n    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!\n\n    this.afterUpdate();\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    let reversePixels = this.options.reverse;\n    let startPixel, endPixel;\n\n    if (this.isHorizontal()) {\n      startPixel = this.left;\n      endPixel = this.right;\n    } else {\n      startPixel = this.top;\n      endPixel = this.bottom;\n      // by default vertical scales are from bottom to top, so pixels are reversed\n      reversePixels = !reversePixels;\n    }\n    this._startPixel = startPixel;\n    this._endPixel = endPixel;\n    this._reversePixels = reversePixels;\n    this._length = endPixel - startPixel;\n    this._alignToPixels = this.options.alignToPixels;\n  }\n\n  afterUpdate() {\n    call(this.options.afterUpdate, [this]);\n  }\n\n  //\n\n  beforeSetDimensions() {\n    call(this.options.beforeSetDimensions, [this]);\n  }\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    if (this.isHorizontal()) {\n      // Reset position before calculating rotation\n      this.width = this.maxWidth;\n      this.left = 0;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n\n      // Reset position before calculating rotation\n      this.top = 0;\n      this.bottom = this.height;\n    }\n\n    // Reset padding\n    this.paddingLeft = 0;\n    this.paddingTop = 0;\n    this.paddingRight = 0;\n    this.paddingBottom = 0;\n  }\n  afterSetDimensions() {\n    call(this.options.afterSetDimensions, [this]);\n  }\n\n  _callHooks(name) {\n    this.chart.notifyPlugins(name, this.getContext());\n    call(this.options[name], [this]);\n  }\n\n  // Data limits\n  beforeDataLimits() {\n    this._callHooks('beforeDataLimits');\n  }\n  determineDataLimits() {}\n  afterDataLimits() {\n    this._callHooks('afterDataLimits');\n  }\n\n  //\n  beforeBuildTicks() {\n    this._callHooks('beforeBuildTicks');\n  }\n  /**\n\t * @return {object[]} the ticks\n\t */\n  buildTicks() {\n    return [];\n  }\n  afterBuildTicks() {\n    this._callHooks('afterBuildTicks');\n  }\n\n  beforeTickToLabelConversion() {\n    call(this.options.beforeTickToLabelConversion, [this]);\n  }\n  /**\n\t * Convert ticks to label strings\n\t * @param {Tick[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    const tickOpts = this.options.ticks;\n    let i, ilen, tick;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      tick = ticks[i];\n      tick.label = call(tickOpts.callback, [tick.value, i, ticks], this);\n    }\n  }\n  afterTickToLabelConversion() {\n    call(this.options.afterTickToLabelConversion, [this]);\n  }\n\n  //\n\n  beforeCalculateLabelRotation() {\n    call(this.options.beforeCalculateLabelRotation, [this]);\n  }\n  calculateLabelRotation() {\n    const options = this.options;\n    const tickOpts = options.ticks;\n    const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);\n    const minRotation = tickOpts.minRotation || 0;\n    const maxRotation = tickOpts.maxRotation;\n    let labelRotation = minRotation;\n    let tickWidth, maxHeight, maxLabelDiagonal;\n\n    if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {\n      this.labelRotation = minRotation;\n      return;\n    }\n\n    const labelSizes = this._getLabelSizes();\n    const maxLabelWidth = labelSizes.widest.width;\n    const maxLabelHeight = labelSizes.highest.height;\n\n    // Estimate the width of each grid based on the canvas width, the maximum\n    // label width and the number of tick intervals\n    const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);\n    tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);\n\n    // Allow 3 pixels x2 padding either side for label readability\n    if (maxLabelWidth + 6 > tickWidth) {\n      tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));\n      maxHeight = this.maxHeight - getTickMarkLength(options.grid)\n\t\t\t\t- tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);\n      maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);\n      labelRotation = toDegrees(Math.min(\n        Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)),\n        Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))\n      ));\n      labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));\n    }\n\n    this.labelRotation = labelRotation;\n  }\n  afterCalculateLabelRotation() {\n    call(this.options.afterCalculateLabelRotation, [this]);\n  }\n  afterAutoSkip() {}\n\n  //\n\n  beforeFit() {\n    call(this.options.beforeFit, [this]);\n  }\n  fit() {\n    // Reset\n    const minSize = {\n      width: 0,\n      height: 0\n    };\n\n    const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;\n    const display = this._isVisible();\n    const isHorizontal = this.isHorizontal();\n\n    if (display) {\n      const titleHeight = getTitleHeight(titleOpts, chart.options.font);\n      if (isHorizontal) {\n        minSize.width = this.maxWidth;\n        minSize.height = getTickMarkLength(gridOpts) + titleHeight;\n      } else {\n        minSize.height = this.maxHeight; // fill all the height\n        minSize.width = getTickMarkLength(gridOpts) + titleHeight;\n      }\n\n      // Don't bother fitting the ticks if we are not showing the labels\n      if (tickOpts.display && this.ticks.length) {\n        const {first, last, widest, highest} = this._getLabelSizes();\n        const tickPadding = tickOpts.padding * 2;\n        const angleRadians = toRadians(this.labelRotation);\n        const cos = Math.cos(angleRadians);\n        const sin = Math.sin(angleRadians);\n\n        if (isHorizontal) {\n        // A horizontal axis is more constrained by the height.\n          const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;\n          minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);\n        } else {\n        // A vertical axis is more constrained by the width. Labels are the\n        // dominant factor here, so get that length first and account for padding\n          const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;\n\n          minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);\n        }\n        this._calculatePadding(first, last, sin, cos);\n      }\n    }\n\n    this._handleMargins();\n\n    if (isHorizontal) {\n      this.width = this._length = chart.width - this._margins.left - this._margins.right;\n      this.height = minSize.height;\n    } else {\n      this.width = minSize.width;\n      this.height = this._length = chart.height - this._margins.top - this._margins.bottom;\n    }\n  }\n\n  _calculatePadding(first, last, sin, cos) {\n    const {ticks: {align, padding}, position} = this.options;\n    const isRotated = this.labelRotation !== 0;\n    const labelsBelowTicks = position !== 'top' && this.axis === 'x';\n\n    if (this.isHorizontal()) {\n      const offsetLeft = this.getPixelForTick(0) - this.left;\n      const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);\n      let paddingLeft = 0;\n      let paddingRight = 0;\n\n      // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n      // which means that the right padding is dominated by the font height\n      if (isRotated) {\n        if (labelsBelowTicks) {\n          paddingLeft = cos * first.width;\n          paddingRight = sin * last.height;\n        } else {\n          paddingLeft = sin * first.height;\n          paddingRight = cos * last.width;\n        }\n      } else if (align === 'start') {\n        paddingRight = last.width;\n      } else if (align === 'end') {\n        paddingLeft = first.width;\n      } else if (align !== 'inner') {\n        paddingLeft = first.width / 2;\n        paddingRight = last.width / 2;\n      }\n\n      // Adjust padding taking into account changes in offsets\n      this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);\n      this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);\n    } else {\n      let paddingTop = last.height / 2;\n      let paddingBottom = first.height / 2;\n\n      if (align === 'start') {\n        paddingTop = 0;\n        paddingBottom = first.height;\n      } else if (align === 'end') {\n        paddingTop = last.height;\n        paddingBottom = 0;\n      }\n\n      this.paddingTop = paddingTop + padding;\n      this.paddingBottom = paddingBottom + padding;\n    }\n  }\n\n  /**\n\t * Handle margins and padding interactions\n\t * @private\n\t */\n  _handleMargins() {\n    if (this._margins) {\n      this._margins.left = Math.max(this.paddingLeft, this._margins.left);\n      this._margins.top = Math.max(this.paddingTop, this._margins.top);\n      this._margins.right = Math.max(this.paddingRight, this._margins.right);\n      this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);\n    }\n  }\n\n  afterFit() {\n    call(this.options.afterFit, [this]);\n  }\n\n  // Shared Methods\n  /**\n\t * @return {boolean}\n\t */\n  isHorizontal() {\n    const {axis, position} = this.options;\n    return position === 'top' || position === 'bottom' || axis === 'x';\n  }\n  /**\n\t * @return {boolean}\n\t */\n  isFullSize() {\n    return this.options.fullSize;\n  }\n\n  /**\n\t * @param {Tick[]} ticks\n\t * @private\n\t */\n  _convertTicksToLabels(ticks) {\n    this.beforeTickToLabelConversion();\n\n    this.generateTickLabels(ticks);\n\n    // Ticks should be skipped when callback returns null or undef, so lets remove those.\n    let i, ilen;\n    for (i = 0, ilen = ticks.length; i < ilen; i++) {\n      if (isNullOrUndef(ticks[i].label)) {\n        ticks.splice(i, 1);\n        ilen--;\n        i--;\n      }\n    }\n\n    this.afterTickToLabelConversion();\n  }\n\n  /**\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _getLabelSizes() {\n    let labelSizes = this._labelSizes;\n\n    if (!labelSizes) {\n      const sampleSize = this.options.ticks.sampleSize;\n      let ticks = this.ticks;\n      if (sampleSize < ticks.length) {\n        ticks = sample(ticks, sampleSize);\n      }\n\n      this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);\n    }\n\n    return labelSizes;\n  }\n\n  /**\n\t * Returns {width, height, offset} objects for the first, last, widest, highest tick\n\t * labels where offset indicates the anchor point offset from the top in pixels.\n\t * @return {{ first: object, last: object, widest: object, highest: object, widths: Array, heights: array }}\n\t * @private\n\t */\n  _computeLabelSizes(ticks, length, maxTicksLimit) {\n    const {ctx, _longestTextCache: caches} = this;\n    const widths = [];\n    const heights = [];\n    const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));\n    let widestLabelSize = 0;\n    let highestLabelSize = 0;\n    let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;\n\n    for (i = 0; i < length; i += increment) {\n      label = ticks[i].label;\n      tickFont = this._resolveTickFontOptions(i);\n      ctx.font = fontString = tickFont.string;\n      cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};\n      lineHeight = tickFont.lineHeight;\n      width = height = 0;\n      // Undefined labels and arrays should not be measured\n      if (!isNullOrUndef(label) && !isArray(label)) {\n        width = _measureText(ctx, cache.data, cache.gc, width, label);\n        height = lineHeight;\n      } else if (isArray(label)) {\n        // if it is an array let's measure each element\n        for (j = 0, jlen = label.length; j < jlen; ++j) {\n          nestedLabel = /** @type {string} */ (label[j]);\n          // Undefined labels and arrays should not be measured\n          if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {\n            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);\n            height += lineHeight;\n          }\n        }\n      }\n      widths.push(width);\n      heights.push(height);\n      widestLabelSize = Math.max(width, widestLabelSize);\n      highestLabelSize = Math.max(height, highestLabelSize);\n    }\n    garbageCollect(caches, length);\n\n    const widest = widths.indexOf(widestLabelSize);\n    const highest = heights.indexOf(highestLabelSize);\n\n    const valueAt = (idx) => ({width: widths[idx] || 0, height: heights[idx] || 0});\n\n    return {\n      first: valueAt(0),\n      last: valueAt(length - 1),\n      widest: valueAt(widest),\n      highest: valueAt(highest),\n      widths,\n      heights,\n    };\n  }\n\n  /**\n\t * Used to get the label to display in the tooltip for the given value\n\t * @param {*} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value;\n  }\n\n  /**\n\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {*} value\n\t * @param {number} [index]\n\t * @return {number}\n\t */\n  getPixelForValue(value, index) { // eslint-disable-line no-unused-vars\n    return NaN;\n  }\n\n  /**\n\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} pixel\n\t * @return {*}\n\t */\n  getValueForPixel(pixel) {} // eslint-disable-line no-unused-vars\n\n  /**\n\t * Returns the location of the tick at the given index\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} index\n\t * @return {number}\n\t */\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  /**\n\t * Utility for getting the pixel location of a percentage of scale\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @param {number} decimal\n\t * @return {number}\n\t */\n  getPixelForDecimal(decimal) {\n    if (this._reversePixels) {\n      decimal = 1 - decimal;\n    }\n\n    const pixel = this._startPixel + decimal * this._length;\n    return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getDecimalForPixel(pixel) {\n    const decimal = (pixel - this._startPixel) / this._length;\n    return this._reversePixels ? 1 - decimal : decimal;\n  }\n\n  /**\n\t * Returns the pixel for the minimum chart value\n\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t * @return {number}\n\t */\n  getBasePixel() {\n    return this.getPixelForValue(this.getBaseValue());\n  }\n\n  /**\n\t * @return {number}\n\t */\n  getBaseValue() {\n    const {min, max} = this;\n\n    return min < 0 && max < 0 ? max :\n      min > 0 && max > 0 ? min :\n      0;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext(index) {\n    const ticks = this.ticks || [];\n\n    if (index >= 0 && index < ticks.length) {\n      const tick = ticks[index];\n      return tick.$context ||\n\t\t\t\t(tick.$context = createTickContext(this.getContext(), index, tick));\n    }\n    return this.$context ||\n\t\t\t(this.$context = createScaleContext(this.chart.getContext(), this));\n  }\n\n  /**\n\t * @return {number}\n\t * @private\n\t */\n  _tickSize() {\n    const optionTicks = this.options.ticks;\n\n    // Calculate space needed by label in axis direction.\n    const rot = toRadians(this.labelRotation);\n    const cos = Math.abs(Math.cos(rot));\n    const sin = Math.abs(Math.sin(rot));\n\n    const labelSizes = this._getLabelSizes();\n    const padding = optionTicks.autoSkipPadding || 0;\n    const w = labelSizes ? labelSizes.widest.width + padding : 0;\n    const h = labelSizes ? labelSizes.highest.height + padding : 0;\n\n    // Calculate space needed for 1 tick in axis direction.\n    return this.isHorizontal()\n      ? h * cos > w * sin ? w / cos : h / sin\n      : h * sin < w * cos ? h / cos : w / sin;\n  }\n\n  /**\n\t * @return {boolean}\n\t * @private\n\t */\n  _isVisible() {\n    const display = this.options.display;\n\n    if (display !== 'auto') {\n      return !!display;\n    }\n\n    return this.getMatchingVisibleMetas().length > 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeGridLineItems(chartArea) {\n    const axis = this.axis;\n    const chart = this.chart;\n    const options = this.options;\n    const {grid, position, border} = options;\n    const offset = grid.offset;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const ticksLength = ticks.length + (offset ? 1 : 0);\n    const tl = getTickMarkLength(grid);\n    const items = [];\n\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = borderOpts.display ? borderOpts.width : 0;\n    const axisHalfWidth = axisWidth / 2;\n    const alignBorderValue = function(pixel) {\n      return _alignPixel(chart, pixel, axisWidth);\n    };\n    let borderValue, i, lineValue, alignedLineValue;\n    let tx1, ty1, tx2, ty2, x1, y1, x2, y2;\n\n    if (position === 'top') {\n      borderValue = alignBorderValue(this.bottom);\n      ty1 = this.bottom - tl;\n      ty2 = borderValue - axisHalfWidth;\n      y1 = alignBorderValue(chartArea.top) + axisHalfWidth;\n      y2 = chartArea.bottom;\n    } else if (position === 'bottom') {\n      borderValue = alignBorderValue(this.top);\n      y1 = chartArea.top;\n      y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = this.top + tl;\n    } else if (position === 'left') {\n      borderValue = alignBorderValue(this.right);\n      tx1 = this.right - tl;\n      tx2 = borderValue - axisHalfWidth;\n      x1 = alignBorderValue(chartArea.left) + axisHalfWidth;\n      x2 = chartArea.right;\n    } else if (position === 'right') {\n      borderValue = alignBorderValue(this.left);\n      x1 = chartArea.left;\n      x2 = alignBorderValue(chartArea.right) - axisHalfWidth;\n      tx1 = borderValue + axisHalfWidth;\n      tx2 = this.left + tl;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + 0.5);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      y1 = chartArea.top;\n      y2 = chartArea.bottom;\n      ty1 = borderValue + axisHalfWidth;\n      ty2 = ty1 + tl;\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2);\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));\n      }\n\n      tx1 = borderValue - axisHalfWidth;\n      tx2 = tx1 - tl;\n      x1 = chartArea.left;\n      x2 = chartArea.right;\n    }\n\n    const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);\n    const step = Math.max(1, Math.ceil(ticksLength / limit));\n    for (i = 0; i < ticksLength; i += step) {\n      const context = this.getContext(i);\n      const optsAtIndex = grid.setContext(context);\n      const optsAtIndexBorder = border.setContext(context);\n\n      const lineWidth = optsAtIndex.lineWidth;\n      const lineColor = optsAtIndex.color;\n      const borderDash = optsAtIndexBorder.dash || [];\n      const borderDashOffset = optsAtIndexBorder.dashOffset;\n\n      const tickWidth = optsAtIndex.tickWidth;\n      const tickColor = optsAtIndex.tickColor;\n      const tickBorderDash = optsAtIndex.tickBorderDash || [];\n      const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;\n\n      lineValue = getPixelForGridLine(this, i, offset);\n\n      // Skip if the pixel is out of the range\n      if (lineValue === undefined) {\n        continue;\n      }\n\n      alignedLineValue = _alignPixel(chart, lineValue, lineWidth);\n\n      if (isHorizontal) {\n        tx1 = tx2 = x1 = x2 = alignedLineValue;\n      } else {\n        ty1 = ty2 = y1 = y2 = alignedLineValue;\n      }\n\n      items.push({\n        tx1,\n        ty1,\n        tx2,\n        ty2,\n        x1,\n        y1,\n        x2,\n        y2,\n        width: lineWidth,\n        color: lineColor,\n        borderDash,\n        borderDashOffset,\n        tickWidth,\n        tickColor,\n        tickBorderDash,\n        tickBorderDashOffset,\n      });\n    }\n\n    this._ticksLength = ticksLength;\n    this._borderValue = borderValue;\n\n    return items;\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelItems(chartArea) {\n    const axis = this.axis;\n    const options = this.options;\n    const {position, ticks: optionTicks} = options;\n    const isHorizontal = this.isHorizontal();\n    const ticks = this.ticks;\n    const {align, crossAlign, padding, mirror} = optionTicks;\n    const tl = getTickMarkLength(options.grid);\n    const tickAndPadding = tl + padding;\n    const hTickAndPadding = mirror ? -padding : tickAndPadding;\n    const rotation = -toRadians(this.labelRotation);\n    const items = [];\n    let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;\n    let textBaseline = 'middle';\n\n    if (position === 'top') {\n      y = this.bottom - hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'bottom') {\n      y = this.top + hTickAndPadding;\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (position === 'left') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (position === 'right') {\n      const ret = this._getYAxisLabelAlignment(tl);\n      textAlign = ret.textAlign;\n      x = ret.x;\n    } else if (axis === 'x') {\n      if (position === 'center') {\n        y = ((chartArea.top + chartArea.bottom) / 2) + tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;\n      }\n      textAlign = this._getXAxisLabelAlignment();\n    } else if (axis === 'y') {\n      if (position === 'center') {\n        x = ((chartArea.left + chartArea.right) / 2) - tickAndPadding;\n      } else if (isObject(position)) {\n        const positionAxisID = Object.keys(position)[0];\n        const value = position[positionAxisID];\n        x = this.chart.scales[positionAxisID].getPixelForValue(value);\n      }\n      textAlign = this._getYAxisLabelAlignment(tl).textAlign;\n    }\n\n    if (axis === 'y') {\n      if (align === 'start') {\n        textBaseline = 'top';\n      } else if (align === 'end') {\n        textBaseline = 'bottom';\n      }\n    }\n\n    const labelSizes = this._getLabelSizes();\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      label = tick.label;\n\n      const optsAtIndex = optionTicks.setContext(this.getContext(i));\n      pixel = this.getPixelForTick(i) + optionTicks.labelOffset;\n      font = this._resolveTickFontOptions(i);\n      lineHeight = font.lineHeight;\n      lineCount = isArray(label) ? label.length : 1;\n      const halfCount = lineCount / 2;\n      const color = optsAtIndex.color;\n      const strokeColor = optsAtIndex.textStrokeColor;\n      const strokeWidth = optsAtIndex.textStrokeWidth;\n      let tickTextAlign = textAlign;\n\n      if (isHorizontal) {\n        x = pixel;\n\n        if (textAlign === 'inner') {\n          if (i === ilen - 1) {\n            tickTextAlign = !this.options.reverse ? 'right' : 'left';\n          } else if (i === 0) {\n            tickTextAlign = !this.options.reverse ? 'left' : 'right';\n          } else {\n            tickTextAlign = 'center';\n          }\n        }\n\n        if (position === 'top') {\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = -lineCount * lineHeight + lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight;\n          } else {\n            textOffset = -labelSizes.highest.height + lineHeight / 2;\n          }\n        } else {\n          // eslint-disable-next-line no-lonely-if\n          if (crossAlign === 'near' || rotation !== 0) {\n            textOffset = lineHeight / 2;\n          } else if (crossAlign === 'center') {\n            textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight;\n          } else {\n            textOffset = labelSizes.highest.height - lineCount * lineHeight;\n          }\n        }\n        if (mirror) {\n          textOffset *= -1;\n        }\n        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) {\n          x += (lineHeight / 2) * Math.sin(rotation);\n        }\n      } else {\n        y = pixel;\n        textOffset = (1 - lineCount) * lineHeight / 2;\n      }\n\n      let backdrop;\n\n      if (optsAtIndex.showLabelBackdrop) {\n        const labelPadding = toPadding(optsAtIndex.backdropPadding);\n        const height = labelSizes.heights[i];\n        const width = labelSizes.widths[i];\n\n        let top = textOffset - labelPadding.top;\n        let left = 0 - labelPadding.left;\n\n        switch (textBaseline) {\n        case 'middle':\n          top -= height / 2;\n          break;\n        case 'bottom':\n          top -= height;\n          break;\n        default:\n          break;\n        }\n\n        switch (textAlign) {\n        case 'center':\n          left -= width / 2;\n          break;\n        case 'right':\n          left -= width;\n          break;\n        case 'inner':\n          if (i === ilen - 1) {\n            left -= width;\n          } else if (i > 0) {\n            left -= width / 2;\n          }\n          break;\n        default:\n          break;\n        }\n\n        backdrop = {\n          left,\n          top,\n          width: width + labelPadding.width,\n          height: height + labelPadding.height,\n\n          color: optsAtIndex.backdropColor,\n        };\n      }\n\n      items.push({\n        label,\n        font,\n        textOffset,\n        options: {\n          rotation,\n          color,\n          strokeColor,\n          strokeWidth,\n          textAlign: tickTextAlign,\n          textBaseline,\n          translation: [x, y],\n          backdrop,\n        }\n      });\n    }\n\n    return items;\n  }\n\n  _getXAxisLabelAlignment() {\n    const {position, ticks} = this.options;\n    const rotation = -toRadians(this.labelRotation);\n\n    if (rotation) {\n      return position === 'top' ? 'left' : 'right';\n    }\n\n    let align = 'center';\n\n    if (ticks.align === 'start') {\n      align = 'left';\n    } else if (ticks.align === 'end') {\n      align = 'right';\n    } else if (ticks.align === 'inner') {\n      align = 'inner';\n    }\n\n    return align;\n  }\n\n  _getYAxisLabelAlignment(tl) {\n    const {position, ticks: {crossAlign, mirror, padding}} = this.options;\n    const labelSizes = this._getLabelSizes();\n    const tickAndPadding = tl + padding;\n    const widest = labelSizes.widest.width;\n\n    let textAlign;\n    let x;\n\n    if (position === 'left') {\n      if (mirror) {\n        x = this.right + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += (widest / 2);\n        } else {\n          textAlign = 'right';\n          x += widest;\n        }\n      } else {\n        x = this.right - tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x = this.left;\n        }\n      }\n    } else if (position === 'right') {\n      if (mirror) {\n        x = this.left + padding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'right';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x -= (widest / 2);\n        } else {\n          textAlign = 'left';\n          x -= widest;\n        }\n      } else {\n        x = this.left + tickAndPadding;\n\n        if (crossAlign === 'near') {\n          textAlign = 'left';\n        } else if (crossAlign === 'center') {\n          textAlign = 'center';\n          x += widest / 2;\n        } else {\n          textAlign = 'right';\n          x = this.right;\n        }\n      }\n    } else {\n      textAlign = 'right';\n    }\n\n    return {textAlign, x};\n  }\n\n  /**\n\t * @private\n\t */\n  _computeLabelArea() {\n    if (this.options.ticks.mirror) {\n      return;\n    }\n\n    const chart = this.chart;\n    const position = this.options.position;\n\n    if (position === 'left' || position === 'right') {\n      return {top: 0, left: this.left, bottom: chart.height, right: this.right};\n    } if (position === 'top' || position === 'bottom') {\n      return {top: this.top, left: 0, bottom: this.bottom, right: chart.width};\n    }\n  }\n\n  /**\n   * @protected\n   */\n  drawBackground() {\n    const {ctx, options: {backgroundColor}, left, top, width, height} = this;\n    if (backgroundColor) {\n      ctx.save();\n      ctx.fillStyle = backgroundColor;\n      ctx.fillRect(left, top, width, height);\n      ctx.restore();\n    }\n  }\n\n  getLineWidthForValue(value) {\n    const grid = this.options.grid;\n    if (!this._isVisible() || !grid.display) {\n      return 0;\n    }\n    const ticks = this.ticks;\n    const index = ticks.findIndex(t => t.value === value);\n    if (index >= 0) {\n      const opts = grid.setContext(this.getContext(index));\n      return opts.lineWidth;\n    }\n    return 0;\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid(chartArea) {\n    const grid = this.options.grid;\n    const ctx = this.ctx;\n    const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));\n    let i, ilen;\n\n    const drawLine = (p1, p2, style) => {\n      if (!style.width || !style.color) {\n        return;\n      }\n      ctx.save();\n      ctx.lineWidth = style.width;\n      ctx.strokeStyle = style.color;\n      ctx.setLineDash(style.borderDash || []);\n      ctx.lineDashOffset = style.borderDashOffset;\n\n      ctx.beginPath();\n      ctx.moveTo(p1.x, p1.y);\n      ctx.lineTo(p2.x, p2.y);\n      ctx.stroke();\n      ctx.restore();\n    };\n\n    if (grid.display) {\n      for (i = 0, ilen = items.length; i < ilen; ++i) {\n        const item = items[i];\n\n        if (grid.drawOnChartArea) {\n          drawLine(\n            {x: item.x1, y: item.y1},\n            {x: item.x2, y: item.y2},\n            item\n          );\n        }\n\n        if (grid.drawTicks) {\n          drawLine(\n            {x: item.tx1, y: item.ty1},\n            {x: item.tx2, y: item.ty2},\n            {\n              color: item.tickColor,\n              width: item.tickWidth,\n              borderDash: item.tickBorderDash,\n              borderDashOffset: item.tickBorderDashOffset\n            }\n          );\n        }\n      }\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {\n    const {chart, ctx, options: {border, grid}} = this;\n    const borderOpts = border.setContext(this.getContext());\n    const axisWidth = border.display ? borderOpts.width : 0;\n    if (!axisWidth) {\n      return;\n    }\n    const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;\n    const borderValue = this._borderValue;\n    let x1, x2, y1, y2;\n\n    if (this.isHorizontal()) {\n      x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;\n      x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;\n      y1 = y2 = borderValue;\n    } else {\n      y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;\n      y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;\n      x1 = x2 = borderValue;\n    }\n    ctx.save();\n    ctx.lineWidth = borderOpts.width;\n    ctx.strokeStyle = borderOpts.color;\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    ctx.stroke();\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawLabels(chartArea) {\n    const optionTicks = this.options.ticks;\n\n    if (!optionTicks.display) {\n      return;\n    }\n\n    const ctx = this.ctx;\n\n    const area = this._computeLabelArea();\n    if (area) {\n      clipArea(ctx, area);\n    }\n\n    const items = this.getLabelItems(chartArea);\n    for (const item of items) {\n      const renderTextOptions = item.options;\n      const tickFont = item.font;\n      const label = item.label;\n      const y = item.textOffset;\n      renderText(ctx, label, 0, y, tickFont, renderTextOptions);\n    }\n\n    if (area) {\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const {ctx, options: {position, title, reverse}} = this;\n\n    if (!title.display) {\n      return;\n    }\n\n    const font = toFont(title.font);\n    const padding = toPadding(title.padding);\n    const align = title.align;\n    let offset = font.lineHeight / 2;\n\n    if (position === 'bottom' || position === 'center' || isObject(position)) {\n      offset += padding.bottom;\n      if (isArray(title.text)) {\n        offset += font.lineHeight * (title.text.length - 1);\n      }\n    } else {\n      offset += padding.top;\n    }\n\n    const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);\n\n    renderText(ctx, title.text, 0, 0, font, {\n      color: title.color,\n      maxWidth,\n      rotation,\n      textAlign: titleAlign(align, position, reverse),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n\n  draw(chartArea) {\n    if (!this._isVisible()) {\n      return;\n    }\n\n    this.drawBackground();\n    this.drawGrid(chartArea);\n    this.drawBorder();\n    this.drawTitle();\n    this.drawLabels(chartArea);\n  }\n\n  /**\n\t * @return {object[]}\n\t * @private\n\t */\n  _layers() {\n    const opts = this.options;\n    const tz = opts.ticks && opts.ticks.z || 0;\n    const gz = valueOrDefault(opts.grid && opts.grid.z, -1);\n    const bz = valueOrDefault(opts.border && opts.border.z, 0);\n\n    if (!this._isVisible() || this.draw !== Scale.prototype.draw) {\n      // backward compatibility: draw has been overridden by custom scale\n      return [{\n        z: tz,\n        draw: (chartArea) => {\n          this.draw(chartArea);\n        }\n      }];\n    }\n\n    return [{\n      z: gz,\n      draw: (chartArea) => {\n        this.drawBackground();\n        this.drawGrid(chartArea);\n        this.drawTitle();\n      }\n    }, {\n      z: bz,\n      draw: () => {\n        this.drawBorder();\n      }\n    }, {\n      z: tz,\n      draw: (chartArea) => {\n        this.drawLabels(chartArea);\n      }\n    }];\n  }\n\n  /**\n\t * Returns visible dataset metas that are attached to this scale\n\t * @param {string} [type] - if specified, also filter by dataset type\n\t * @return {object[]}\n\t */\n  getMatchingVisibleMetas(type) {\n    const metas = this.chart.getSortedVisibleDatasetMetas();\n    const axisID = this.axis + 'AxisID';\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      const meta = metas[i];\n      if (meta[axisID] === this.id && (!type || meta.type === type)) {\n        result.push(meta);\n      }\n    }\n    return result;\n  }\n\n  /**\n\t * @param {number} index\n\t * @return {object}\n\t * @protected\n \t */\n  _resolveTickFontOptions(index) {\n    const opts = this.options.ticks.setContext(this.getContext(index));\n    return toFont(opts.font);\n  }\n\n  /**\n   * @protected\n   */\n  _maxDigits() {\n    const fontSize = this._resolveTickFontOptions(0).lineHeight;\n    return (this.isHorizontal() ? this.width : this.height) / fontSize;\n  }\n}\n","import {merge} from '../helpers/index.js';\nimport defaults, {overrides} from './core.defaults.js';\n\n/**\n * @typedef {{id: string, defaults: any, overrides?: any, defaultRoutes: any}} IChartComponent\n */\n\nexport default class TypedRegistry {\n  constructor(type, scope, override) {\n    this.type = type;\n    this.scope = scope;\n    this.override = override;\n    this.items = Object.create(null);\n  }\n\n  isForType(type) {\n    return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t * @returns {string} The scope where items defaults were registered to.\n\t */\n  register(item) {\n    const proto = Object.getPrototypeOf(item);\n    let parentScope;\n\n    if (isIChartComponent(proto)) {\n      // Make sure the parent is registered and note the scope where its defaults are.\n      parentScope = this.register(proto);\n    }\n\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope + '.' + id;\n\n    if (!id) {\n      throw new Error('class does not have id: ' + item);\n    }\n\n    if (id in items) {\n      // already registered\n      return scope;\n    }\n\n    items[id] = item;\n    registerDefaults(item, scope, parentScope);\n    if (this.override) {\n      defaults.override(item.id, item.overrides);\n    }\n\n    return scope;\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object?}\n\t */\n  get(id) {\n    return this.items[id];\n  }\n\n  /**\n\t * @param {IChartComponent} item\n\t */\n  unregister(item) {\n    const items = this.items;\n    const id = item.id;\n    const scope = this.scope;\n\n    if (id in items) {\n      delete items[id];\n    }\n\n    if (scope && id in defaults[scope]) {\n      delete defaults[scope][id];\n      if (this.override) {\n        delete overrides[id];\n      }\n    }\n  }\n}\n\nfunction registerDefaults(item, scope, parentScope) {\n  // Inherit the parent's defaults and keep existing defaults\n  const itemDefaults = merge(Object.create(null), [\n    parentScope ? defaults.get(parentScope) : {},\n    defaults.get(scope),\n    item.defaults\n  ]);\n\n  defaults.set(scope, itemDefaults);\n\n  if (item.defaultRoutes) {\n    routeDefaults(scope, item.defaultRoutes);\n  }\n\n  if (item.descriptors) {\n    defaults.describe(scope, item.descriptors);\n  }\n}\n\nfunction routeDefaults(scope, routes) {\n  Object.keys(routes).forEach(property => {\n    const propertyParts = property.split('.');\n    const sourceName = propertyParts.pop();\n    const sourceScope = [scope].concat(propertyParts).join('.');\n    const parts = routes[property].split('.');\n    const targetName = parts.pop();\n    const targetScope = parts.join('.');\n    defaults.route(sourceScope, sourceName, targetScope, targetName);\n  });\n}\n\nfunction isIChartComponent(proto) {\n  return 'id' in proto && 'defaults' in proto;\n}\n","import DatasetController from './core.datasetController.js';\nimport Element from './core.element.js';\nimport Scale from './core.scale.js';\nimport TypedRegistry from './core.typedRegistry.js';\nimport {each, callback as call, _capitalize} from '../helpers/helpers.core.js';\n\n/**\n * Please use the module's default export which provides a singleton instance\n * Note: class is exported for typedoc\n */\nexport class Registry {\n  constructor() {\n    this.controllers = new TypedRegistry(DatasetController, 'datasets', true);\n    this.elements = new TypedRegistry(Element, 'elements');\n    this.plugins = new TypedRegistry(Object, 'plugins');\n    this.scales = new TypedRegistry(Scale, 'scales');\n    // Order is important, Scale has Element in prototype chain,\n    // so Scales must be before Elements. Plugins are a fallback, so not listed here.\n    this._typedRegistries = [this.controllers, this.scales, this.elements];\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  add(...args) {\n    this._each('register', args);\n  }\n\n  remove(...args) {\n    this._each('unregister', args);\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  addControllers(...args) {\n    this._each('register', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  addElements(...args) {\n    this._each('register', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  addPlugins(...args) {\n    this._each('register', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  addScales(...args) {\n    this._each('register', args, this.scales);\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof DatasetController}\n\t */\n  getController(id) {\n    return this._get(id, this.controllers, 'controller');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Element}\n\t */\n  getElement(id) {\n    return this._get(id, this.elements, 'element');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {object}\n\t */\n  getPlugin(id) {\n    return this._get(id, this.plugins, 'plugin');\n  }\n\n  /**\n\t * @param {string} id\n\t * @returns {typeof Scale}\n\t */\n  getScale(id) {\n    return this._get(id, this.scales, 'scale');\n  }\n\n  /**\n\t * @param  {...typeof DatasetController} args\n\t */\n  removeControllers(...args) {\n    this._each('unregister', args, this.controllers);\n  }\n\n  /**\n\t * @param  {...typeof Element} args\n\t */\n  removeElements(...args) {\n    this._each('unregister', args, this.elements);\n  }\n\n  /**\n\t * @param  {...any} args\n\t */\n  removePlugins(...args) {\n    this._each('unregister', args, this.plugins);\n  }\n\n  /**\n\t * @param  {...typeof Scale} args\n\t */\n  removeScales(...args) {\n    this._each('unregister', args, this.scales);\n  }\n\n  /**\n\t * @private\n\t */\n  _each(method, args, typedRegistry) {\n    [...args].forEach(arg => {\n      const reg = typedRegistry || this._getRegistryForType(arg);\n      if (typedRegistry || reg.isForType(arg) || (reg === this.plugins && arg.id)) {\n        this._exec(method, reg, arg);\n      } else {\n        // Handle loopable args\n        // Use case:\n        //  import * as plugins from './plugins.js';\n        //  Chart.register(plugins);\n        each(arg, item => {\n          // If there are mixed types in the loopable, make sure those are\n          // registered in correct registry\n          // Use case: (treemap exporting controller, elements etc)\n          //  import * as treemap from 'chartjs-chart-treemap.js';\n          //  Chart.register(treemap);\n\n          const itemReg = typedRegistry || this._getRegistryForType(item);\n          this._exec(method, itemReg, item);\n        });\n      }\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _exec(method, registry, component) {\n    const camelMethod = _capitalize(method);\n    call(component['before' + camelMethod], [], component); // beforeRegister / beforeUnregister\n    registry[method](component);\n    call(component['after' + camelMethod], [], component); // afterRegister / afterUnregister\n  }\n\n  /**\n\t * @private\n\t */\n  _getRegistryForType(type) {\n    for (let i = 0; i < this._typedRegistries.length; i++) {\n      const reg = this._typedRegistries[i];\n      if (reg.isForType(type)) {\n        return reg;\n      }\n    }\n    // plugins is the fallback registry\n    return this.plugins;\n  }\n\n  /**\n\t * @private\n\t */\n  _get(id, typedRegistry, type) {\n    const item = typedRegistry.get(id);\n    if (item === undefined) {\n      throw new Error('\"' + id + '\" is not a registered ' + type + '.');\n    }\n    return item;\n  }\n\n}\n\n// singleton instance\nexport default /* #__PURE__ */ new Registry();\n","import registry from './core.registry.js';\nimport {callback as callCallback, isNullOrUndef, valueOrDefault} from '../helpers/helpers.core.js';\n\n/**\n * @typedef { import('./core.controller.js').default } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../plugins/plugin.tooltip.js').default } Tooltip\n */\n\n/**\n * @callback filterCallback\n * @param {{plugin: object, options: object}} value\n * @param {number} [index]\n * @param {array} [array]\n * @param {object} [thisArg]\n * @return {boolean}\n */\n\n\nexport default class PluginService {\n  constructor() {\n    this._init = [];\n  }\n\n  /**\n\t * Calls enabled plugins for `chart` on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {Chart} chart - The chart instance for which plugins should be called.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {object} [args] - Extra arguments to apply to the hook call.\n   * @param {filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notify(chart, hook, args, filter) {\n    if (hook === 'beforeInit') {\n      this._init = this._createDescriptors(chart, true);\n      this._notify(this._init, chart, 'install');\n    }\n\n    const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);\n    const result = this._notify(descriptors, chart, hook, args);\n\n    if (hook === 'afterDestroy') {\n      this._notify(descriptors, chart, 'stop');\n      this._notify(this._init, chart, 'uninstall');\n    }\n    return result;\n  }\n\n  /**\n\t * @private\n\t */\n  _notify(descriptors, chart, hook, args) {\n    args = args || {};\n    for (const descriptor of descriptors) {\n      const plugin = descriptor.plugin;\n      const method = plugin[hook];\n      const params = [chart, args, descriptor.options];\n      if (callCallback(method, params, plugin) === false && args.cancelable) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  invalidate() {\n    // When plugins are registered, there is the possibility of a double\n    // invalidate situation. In this case, we only want to invalidate once.\n    // If we invalidate multiple times, the `_oldCache` is lost and all of the\n    // plugins are restarted without being correctly stopped.\n    // See https://github.com/chartjs/Chart.js/issues/8147\n    if (!isNullOrUndef(this._cache)) {\n      this._oldCache = this._cache;\n      this._cache = undefined;\n    }\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _descriptors(chart) {\n    if (this._cache) {\n      return this._cache;\n    }\n\n    const descriptors = this._cache = this._createDescriptors(chart);\n\n    this._notifyStateChanges(chart);\n\n    return descriptors;\n  }\n\n  _createDescriptors(chart, all) {\n    const config = chart && chart.config;\n    const options = valueOrDefault(config.options && config.options.plugins, {});\n    const plugins = allPlugins(config);\n    // options === false => all plugins are disabled\n    return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);\n  }\n\n  /**\n\t * @param {Chart} chart\n\t * @private\n\t */\n  _notifyStateChanges(chart) {\n    const previousDescriptors = this._oldCache || [];\n    const descriptors = this._cache;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.plugin.id === y.plugin.id));\n    this._notify(diff(previousDescriptors, descriptors), chart, 'stop');\n    this._notify(diff(descriptors, previousDescriptors), chart, 'start');\n  }\n}\n\n/**\n * @param {import('./core.config.js').default} config\n */\nfunction allPlugins(config) {\n  const localIds = {};\n  const plugins = [];\n  const keys = Object.keys(registry.plugins.items);\n  for (let i = 0; i < keys.length; i++) {\n    plugins.push(registry.getPlugin(keys[i]));\n  }\n\n  const local = config.plugins || [];\n  for (let i = 0; i < local.length; i++) {\n    const plugin = local[i];\n\n    if (plugins.indexOf(plugin) === -1) {\n      plugins.push(plugin);\n      localIds[plugin.id] = true;\n    }\n  }\n\n  return {plugins, localIds};\n}\n\nfunction getOpts(options, all) {\n  if (!all && options === false) {\n    return null;\n  }\n  if (options === true) {\n    return {};\n  }\n  return options;\n}\n\nfunction createDescriptors(chart, {plugins, localIds}, options, all) {\n  const result = [];\n  const context = chart.getContext();\n\n  for (const plugin of plugins) {\n    const id = plugin.id;\n    const opts = getOpts(options[id], all);\n    if (opts === null) {\n      continue;\n    }\n    result.push({\n      plugin,\n      options: pluginOpts(chart.config, {plugin, local: localIds[id]}, opts, context)\n    });\n  }\n\n  return result;\n}\n\nfunction pluginOpts(config, {plugin, local}, opts, context) {\n  const keys = config.pluginScopeKeys(plugin);\n  const scopes = config.getOptionScopes(opts, keys);\n  if (local && plugin.defaults) {\n    // make sure plugin defaults are in scopes for local (not registered) plugins\n    scopes.push(plugin.defaults);\n  }\n  return config.createResolver(scopes, context, [''], {\n    // These are just defaults that plugins can override\n    scriptable: false,\n    indexable: false,\n    allKeys: true\n  });\n}\n","import defaults, {overrides, descriptors} from './core.defaults.js';\nimport {mergeIf, resolveObjectKey, isArray, isFunction, valueOrDefault, isObject} from '../helpers/helpers.core.js';\nimport {_attachContext, _createResolver, _descriptors} from '../helpers/helpers.config.js';\n\nexport function getIndexAxis(type, options) {\n  const datasetDefaults = defaults.datasets[type] || {};\n  const datasetOptions = (options.datasets || {})[type] || {};\n  return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || 'x';\n}\n\nfunction getAxisFromDefaultScaleID(id, indexAxis) {\n  let axis = id;\n  if (id === '_index_') {\n    axis = indexAxis;\n  } else if (id === '_value_') {\n    axis = indexAxis === 'x' ? 'y' : 'x';\n  }\n  return axis;\n}\n\nfunction getDefaultScaleIDFromAxis(axis, indexAxis) {\n  return axis === indexAxis ? '_index_' : '_value_';\n}\n\nfunction idMatchesAxis(id) {\n  if (id === 'x' || id === 'y' || id === 'r') {\n    return id;\n  }\n}\n\nfunction axisFromPosition(position) {\n  if (position === 'top' || position === 'bottom') {\n    return 'x';\n  }\n  if (position === 'left' || position === 'right') {\n    return 'y';\n  }\n}\n\nexport function determineAxis(id, ...scaleOptions) {\n  if (idMatchesAxis(id)) {\n    return id;\n  }\n  for (const opts of scaleOptions) {\n    const axis = opts.axis\n      || axisFromPosition(opts.position)\n      || id.length > 1 && idMatchesAxis(id[0].toLowerCase());\n    if (axis) {\n      return axis;\n    }\n  }\n  throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);\n}\n\nfunction getAxisFromDataset(id, axis, dataset) {\n  if (dataset[axis + 'AxisID'] === id) {\n    return {axis};\n  }\n}\n\nfunction retrieveAxisFromDatasets(id, config) {\n  if (config.data && config.data.datasets) {\n    const boundDs = config.data.datasets.filter((d) => d.xAxisID === id || d.yAxisID === id);\n    if (boundDs.length) {\n      return getAxisFromDataset(id, 'x', boundDs[0]) || getAxisFromDataset(id, 'y', boundDs[0]);\n    }\n  }\n  return {};\n}\n\nfunction mergeScaleConfig(config, options) {\n  const chartDefaults = overrides[config.type] || {scales: {}};\n  const configScales = options.scales || {};\n  const chartIndexAxis = getIndexAxis(config.type, options);\n  const scales = Object.create(null);\n\n  // First figure out first scale id's per axis.\n  Object.keys(configScales).forEach(id => {\n    const scaleConf = configScales[id];\n    if (!isObject(scaleConf)) {\n      return console.error(`Invalid scale configuration for scale: ${id}`);\n    }\n    if (scaleConf._proxy) {\n      return console.warn(`Ignoring resolver passed as options for scale: ${id}`);\n    }\n    const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);\n    const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);\n    const defaultScaleOptions = chartDefaults.scales || {};\n    scales[id] = mergeIf(Object.create(null), [{axis}, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId]]);\n  });\n\n  // Then merge dataset defaults to scale configs\n  config.data.datasets.forEach(dataset => {\n    const type = dataset.type || config.type;\n    const indexAxis = dataset.indexAxis || getIndexAxis(type, options);\n    const datasetDefaults = overrides[type] || {};\n    const defaultScaleOptions = datasetDefaults.scales || {};\n    Object.keys(defaultScaleOptions).forEach(defaultID => {\n      const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);\n      const id = dataset[axis + 'AxisID'] || axis;\n      scales[id] = scales[id] || Object.create(null);\n      mergeIf(scales[id], [{axis}, configScales[id], defaultScaleOptions[defaultID]]);\n    });\n  });\n\n  // apply scale defaults, if not overridden by dataset defaults\n  Object.keys(scales).forEach(key => {\n    const scale = scales[key];\n    mergeIf(scale, [defaults.scales[scale.type], defaults.scale]);\n  });\n\n  return scales;\n}\n\nfunction initOptions(config) {\n  const options = config.options || (config.options = {});\n\n  options.plugins = valueOrDefault(options.plugins, {});\n  options.scales = mergeScaleConfig(config, options);\n}\n\nfunction initData(data) {\n  data = data || {};\n  data.datasets = data.datasets || [];\n  data.labels = data.labels || [];\n  return data;\n}\n\nfunction initConfig(config) {\n  config = config || {};\n  config.data = initData(config.data);\n\n  initOptions(config);\n\n  return config;\n}\n\nconst keyCache = new Map();\nconst keysCached = new Set();\n\nfunction cachedKeys(cacheKey, generate) {\n  let keys = keyCache.get(cacheKey);\n  if (!keys) {\n    keys = generate();\n    keyCache.set(cacheKey, keys);\n    keysCached.add(keys);\n  }\n  return keys;\n}\n\nconst addIfFound = (set, obj, key) => {\n  const opts = resolveObjectKey(obj, key);\n  if (opts !== undefined) {\n    set.add(opts);\n  }\n};\n\nexport default class Config {\n  constructor(config) {\n    this._config = initConfig(config);\n    this._scopeCache = new Map();\n    this._resolverCache = new Map();\n  }\n\n  get platform() {\n    return this._config.platform;\n  }\n\n  get type() {\n    return this._config.type;\n  }\n\n  set type(type) {\n    this._config.type = type;\n  }\n\n  get data() {\n    return this._config.data;\n  }\n\n  set data(data) {\n    this._config.data = initData(data);\n  }\n\n  get options() {\n    return this._config.options;\n  }\n\n  set options(options) {\n    this._config.options = options;\n  }\n\n  get plugins() {\n    return this._config.plugins;\n  }\n\n  update() {\n    const config = this._config;\n    this.clearCache();\n    initOptions(config);\n  }\n\n  clearCache() {\n    this._scopeCache.clear();\n    this._resolverCache.clear();\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @return {string[][]}\n   */\n  datasetScopeKeys(datasetType) {\n    return cachedKeys(datasetType,\n      () => [[\n        `datasets.${datasetType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the option scope keys for resolving dataset animation options.\n   * These keys do not include the dataset itself, because it is not under options.\n   * @param {string} datasetType\n   * @param {string} transition\n   * @return {string[][]}\n   */\n  datasetAnimationScopeKeys(datasetType, transition) {\n    return cachedKeys(`${datasetType}.transition.${transition}`,\n      () => [\n        [\n          `datasets.${datasetType}.transitions.${transition}`,\n          `transitions.${transition}`,\n        ],\n        // The following are used for looking up the `animations` and `animation` keys\n        [\n          `datasets.${datasetType}`,\n          ''\n        ]\n      ]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving element options that belong\n   * to an dataset. These keys do not include the dataset itself, because it\n   * is not under options.\n   * @param {string} datasetType\n   * @param {string} elementType\n   * @return {string[][]}\n   */\n  datasetElementScopeKeys(datasetType, elementType) {\n    return cachedKeys(`${datasetType}-${elementType}`,\n      () => [[\n        `datasets.${datasetType}.elements.${elementType}`,\n        `datasets.${datasetType}`,\n        `elements.${elementType}`,\n        ''\n      ]]);\n  }\n\n  /**\n   * Returns the options scope keys for resolving plugin options.\n   * @param {{id: string, additionalOptionScopes?: string[]}} plugin\n   * @return {string[][]}\n   */\n  pluginScopeKeys(plugin) {\n    const id = plugin.id;\n    const type = this.type;\n    return cachedKeys(`${type}-plugin-${id}`,\n      () => [[\n        `plugins.${id}`,\n        ...plugin.additionalOptionScopes || [],\n      ]]);\n  }\n\n  /**\n   * @private\n   */\n  _cachedScopes(mainScope, resetCache) {\n    const _scopeCache = this._scopeCache;\n    let cache = _scopeCache.get(mainScope);\n    if (!cache || resetCache) {\n      cache = new Map();\n      _scopeCache.set(mainScope, cache);\n    }\n    return cache;\n  }\n\n  /**\n   * Resolves the objects from options and defaults for option value resolution.\n   * @param {object} mainScope - The main scope object for options\n   * @param {string[][]} keyLists - The arrays of keys in resolution order\n   * @param {boolean} [resetCache] - reset the cache for this mainScope\n   */\n  getOptionScopes(mainScope, keyLists, resetCache) {\n    const {options, type} = this;\n    const cache = this._cachedScopes(mainScope, resetCache);\n    const cached = cache.get(keyLists);\n    if (cached) {\n      return cached;\n    }\n\n    const scopes = new Set();\n\n    keyLists.forEach(keys => {\n      if (mainScope) {\n        scopes.add(mainScope);\n        keys.forEach(key => addIfFound(scopes, mainScope, key));\n      }\n      keys.forEach(key => addIfFound(scopes, options, key));\n      keys.forEach(key => addIfFound(scopes, overrides[type] || {}, key));\n      keys.forEach(key => addIfFound(scopes, defaults, key));\n      keys.forEach(key => addIfFound(scopes, descriptors, key));\n    });\n\n    const array = Array.from(scopes);\n    if (array.length === 0) {\n      array.push(Object.create(null));\n    }\n    if (keysCached.has(keyLists)) {\n      cache.set(keyLists, array);\n    }\n    return array;\n  }\n\n  /**\n   * Returns the option scopes for resolving chart options\n   * @return {object[]}\n   */\n  chartOptionScopes() {\n    const {options, type} = this;\n\n    return [\n      options,\n      overrides[type] || {},\n      defaults.datasets[type] || {}, // https://github.com/chartjs/Chart.js/issues/8531\n      {type},\n      defaults,\n      descriptors\n    ];\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {string[]} names\n   * @param {function|object} context\n   * @param {string[]} [prefixes]\n   * @return {object}\n   */\n  resolveNamedOptions(scopes, names, context, prefixes = ['']) {\n    const result = {$shared: true};\n    const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);\n    let options = resolver;\n    if (needContext(resolver, names)) {\n      result.$shared = false;\n      context = isFunction(context) ? context() : context;\n      // subResolver is passed to scriptable options. It should not resolve to hover options.\n      const subResolver = this.createResolver(scopes, context, subPrefixes);\n      options = _attachContext(resolver, context, subResolver);\n    }\n\n    for (const prop of names) {\n      result[prop] = options[prop];\n    }\n    return result;\n  }\n\n  /**\n   * @param {object[]} scopes\n   * @param {object} [context]\n   * @param {string[]} [prefixes]\n   * @param {{scriptable: boolean, indexable: boolean, allKeys?: boolean}} [descriptorDefaults]\n   */\n  createResolver(scopes, context, prefixes = [''], descriptorDefaults) {\n    const {resolver} = getResolver(this._resolverCache, scopes, prefixes);\n    return isObject(context)\n      ? _attachContext(resolver, context, undefined, descriptorDefaults)\n      : resolver;\n  }\n}\n\nfunction getResolver(resolverCache, scopes, prefixes) {\n  let cache = resolverCache.get(scopes);\n  if (!cache) {\n    cache = new Map();\n    resolverCache.set(scopes, cache);\n  }\n  const cacheKey = prefixes.join();\n  let cached = cache.get(cacheKey);\n  if (!cached) {\n    const resolver = _createResolver(scopes, prefixes);\n    cached = {\n      resolver,\n      subPrefixes: prefixes.filter(p => !p.toLowerCase().includes('hover'))\n    };\n    cache.set(cacheKey, cached);\n  }\n  return cached;\n}\n\nconst hasFunction = value => isObject(value)\n  && Object.getOwnPropertyNames(value).some((key) => isFunction(value[key]));\n\nfunction needContext(proxy, names) {\n  const {isScriptable, isIndexable} = _descriptors(proxy);\n\n  for (const prop of names) {\n    const scriptable = isScriptable(prop);\n    const indexable = isIndexable(prop);\n    const value = (indexable || scriptable) && proxy[prop];\n    if ((scriptable && (isFunction(value) || hasFunction(value)))\n      || (indexable && isArray(value))) {\n      return true;\n    }\n  }\n  return false;\n}\n","import animator from './core.animator.js';\nimport defaults, {overrides} from './core.defaults.js';\nimport Interaction from './core.interaction.js';\nimport layouts from './core.layouts.js';\nimport {_detectPlatform} from '../platform/index.js';\nimport PluginService from './core.plugins.js';\nimport registry from './core.registry.js';\nimport Config, {determineAxis, getIndexAxis} from './core.config.js';\nimport {retinaScale, _isDomSupported} from '../helpers/helpers.dom.js';\nimport {each, callback as callCallback, uid, valueOrDefault, _elementsEqual, isNullOrUndef, setsEqual, defined, isFunction, _isClickEvent} from '../helpers/helpers.core.js';\nimport {clearCanvas, clipArea, createContext, unclipArea, _isPointInArea} from '../helpers/index.js';\n// @ts-ignore\nimport {version} from '../../package.json';\nimport {debounce} from '../helpers/helpers.extras.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').Point } Point\n */\n\nconst KNOWN_POSITIONS = ['top', 'bottom', 'left', 'right', 'chartArea'];\nfunction positionIsHorizontal(position, axis) {\n  return position === 'top' || position === 'bottom' || (KNOWN_POSITIONS.indexOf(position) === -1 && axis === 'x');\n}\n\nfunction compare2Level(l1, l2) {\n  return function(a, b) {\n    return a[l1] === b[l1]\n      ? a[l2] - b[l2]\n      : a[l1] - b[l1];\n  };\n}\n\nfunction onAnimationsComplete(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n\n  chart.notifyPlugins('afterRender');\n  callCallback(animationOptions && animationOptions.onComplete, [context], chart);\n}\n\nfunction onAnimationProgress(context) {\n  const chart = context.chart;\n  const animationOptions = chart.options.animation;\n  callCallback(animationOptions && animationOptions.onProgress, [context], chart);\n}\n\n/**\n * Chart.js can take a string id of a canvas element, a 2d context, or a canvas element itself.\n * Attempt to unwrap the item passed into the chart constructor so that it is a canvas element (if possible).\n */\nfunction getCanvas(item) {\n  if (_isDomSupported() && typeof item === 'string') {\n    item = document.getElementById(item);\n  } else if (item && item.length) {\n    // Support for array based queries (such as jQuery)\n    item = item[0];\n  }\n\n  if (item && item.canvas) {\n    // Support for any object associated to a canvas (including a context2d)\n    item = item.canvas;\n  }\n  return item;\n}\n\nconst instances = {};\nconst getChart = (key) => {\n  const canvas = getCanvas(key);\n  return Object.values(instances).filter((c) => c.canvas === canvas).pop();\n};\n\nfunction moveNumericKeys(obj, start, move) {\n  const keys = Object.keys(obj);\n  for (const key of keys) {\n    const intKey = +key;\n    if (intKey >= start) {\n      const value = obj[key];\n      delete obj[key];\n      if (move > 0 || intKey > start) {\n        obj[intKey + move] = value;\n      }\n    }\n  }\n}\n\n/**\n * @param {ChartEvent} e\n * @param {ChartEvent|null} lastEvent\n * @param {boolean} inChartArea\n * @param {boolean} isClick\n * @returns {ChartEvent|null}\n */\nfunction determineLastEvent(e, lastEvent, inChartArea, isClick) {\n  if (!inChartArea || e.type === 'mouseout') {\n    return null;\n  }\n  if (isClick) {\n    return lastEvent;\n  }\n  return e;\n}\n\nfunction getSizeForArea(scale, chartArea, field) {\n  return scale.options.clip ? scale[field] : chartArea[field];\n}\n\nfunction getDatasetArea(meta, chartArea) {\n  const {xScale, yScale} = meta;\n  if (xScale && yScale) {\n    return {\n      left: getSizeForArea(xScale, chartArea, 'left'),\n      right: getSizeForArea(xScale, chartArea, 'right'),\n      top: getSizeForArea(yScale, chartArea, 'top'),\n      bottom: getSizeForArea(yScale, chartArea, 'bottom')\n    };\n  }\n  return chartArea;\n}\n\nclass Chart {\n\n  static defaults = defaults;\n  static instances = instances;\n  static overrides = overrides;\n  static registry = registry;\n  static version = version;\n  static getChart = getChart;\n\n  static register(...items) {\n    registry.add(...items);\n    invalidatePlugins();\n  }\n\n  static unregister(...items) {\n    registry.remove(...items);\n    invalidatePlugins();\n  }\n\n  // eslint-disable-next-line max-statements\n  constructor(item, userConfig) {\n    const config = this.config = new Config(userConfig);\n    const initialCanvas = getCanvas(item);\n    const existingChart = getChart(initialCanvas);\n    if (existingChart) {\n      throw new Error(\n        'Canvas is already in use. Chart with ID \\'' + existingChart.id + '\\'' +\n\t\t\t\t' must be destroyed before the canvas with ID \\'' + existingChart.canvas.id + '\\' can be reused.'\n      );\n    }\n\n    const options = config.createResolver(config.chartOptionScopes(), this.getContext());\n\n    this.platform = new (config.platform || _detectPlatform(initialCanvas))();\n    this.platform.updateConfig(config);\n\n    const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);\n    const canvas = context && context.canvas;\n    const height = canvas && canvas.height;\n    const width = canvas && canvas.width;\n\n    this.id = uid();\n    this.ctx = context;\n    this.canvas = canvas;\n    this.width = width;\n    this.height = height;\n    this._options = options;\n    // Store the previously used aspect ratio to determine if a resize\n    // is needed during updates. Do this after _options is set since\n    // aspectRatio uses a getter\n    this._aspectRatio = this.aspectRatio;\n    this._layers = [];\n    this._metasets = [];\n    this._stacks = undefined;\n    this.boxes = [];\n    this.currentDevicePixelRatio = undefined;\n    this.chartArea = undefined;\n    this._active = [];\n    this._lastEvent = undefined;\n    this._listeners = {};\n    /** @type {?{attach?: function, detach?: function, resize?: function}} */\n    this._responsiveListeners = undefined;\n    this._sortedMetasets = [];\n    this.scales = {};\n    this._plugins = new PluginService();\n    this.$proxies = {};\n    this._hiddenIndices = {};\n    this.attached = false;\n    this._animationsDisabled = undefined;\n    this.$context = undefined;\n    this._doResize = debounce(mode => this.update(mode), options.resizeDelay || 0);\n    this._dataChanges = [];\n\n    // Add the chart instance to the global namespace\n    instances[this.id] = this;\n\n    if (!context || !canvas) {\n      // The given item is not a compatible context2d element, let's return before finalizing\n      // the chart initialization but after setting basic chart / controller properties that\n      // can help to figure out that the chart is not valid (e.g chart.canvas !== null);\n      // https://github.com/chartjs/Chart.js/issues/2807\n      console.error(\"Failed to create chart: can't acquire context from the given item\");\n      return;\n    }\n\n    animator.listen(this, 'complete', onAnimationsComplete);\n    animator.listen(this, 'progress', onAnimationProgress);\n\n    this._initialize();\n    if (this.attached) {\n      this.update();\n    }\n  }\n\n  get aspectRatio() {\n    const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;\n    if (!isNullOrUndef(aspectRatio)) {\n      // If aspectRatio is defined in options, use that.\n      return aspectRatio;\n    }\n\n    if (maintainAspectRatio && _aspectRatio) {\n      // If maintainAspectRatio is truthly and we had previously determined _aspectRatio, use that\n      return _aspectRatio;\n    }\n\n    // Calculate\n    return height ? width / height : null;\n  }\n\n  get data() {\n    return this.config.data;\n  }\n\n  set data(data) {\n    this.config.data = data;\n  }\n\n  get options() {\n    return this._options;\n  }\n\n  set options(options) {\n    this.config.options = options;\n  }\n\n  get registry() {\n    return registry;\n  }\n\n  /**\n\t * @private\n\t */\n  _initialize() {\n    // Before init plugin notification\n    this.notifyPlugins('beforeInit');\n\n    if (this.options.responsive) {\n      this.resize();\n    } else {\n      retinaScale(this, this.options.devicePixelRatio);\n    }\n\n    this.bindEvents();\n\n    // After init plugin notification\n    this.notifyPlugins('afterInit');\n\n    return this;\n  }\n\n  clear() {\n    clearCanvas(this.canvas, this.ctx);\n    return this;\n  }\n\n  stop() {\n    animator.stop(this);\n    return this;\n  }\n\n  /**\n\t * Resize the chart to its container or to explicit dimensions.\n\t * @param {number} [width]\n\t * @param {number} [height]\n\t */\n  resize(width, height) {\n    if (!animator.running(this)) {\n      this._resize(width, height);\n    } else {\n      this._resizeBeforeDraw = {width, height};\n    }\n  }\n\n  _resize(width, height) {\n    const options = this.options;\n    const canvas = this.canvas;\n    const aspectRatio = options.maintainAspectRatio && this.aspectRatio;\n    const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);\n    const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();\n    const mode = this.width ? 'resize' : 'attach';\n\n    this.width = newSize.width;\n    this.height = newSize.height;\n    this._aspectRatio = this.aspectRatio;\n    if (!retinaScale(this, newRatio, true)) {\n      return;\n    }\n\n    this.notifyPlugins('resize', {size: newSize});\n\n    callCallback(options.onResize, [this, newSize], this);\n\n    if (this.attached) {\n      if (this._doResize(mode)) {\n        // The resize update is delayed, only draw without updating.\n        this.render();\n      }\n    }\n  }\n\n  ensureScalesHaveIDs() {\n    const options = this.options;\n    const scalesOptions = options.scales || {};\n\n    each(scalesOptions, (axisOptions, axisID) => {\n      axisOptions.id = axisID;\n    });\n  }\n\n  /**\n\t * Builds a map of scale ID to scale object for future lookup.\n\t */\n  buildOrUpdateScales() {\n    const options = this.options;\n    const scaleOpts = options.scales;\n    const scales = this.scales;\n    const updated = Object.keys(scales).reduce((obj, id) => {\n      obj[id] = false;\n      return obj;\n    }, {});\n    let items = [];\n\n    if (scaleOpts) {\n      items = items.concat(\n        Object.keys(scaleOpts).map((id) => {\n          const scaleOptions = scaleOpts[id];\n          const axis = determineAxis(id, scaleOptions);\n          const isRadial = axis === 'r';\n          const isHorizontal = axis === 'x';\n          return {\n            options: scaleOptions,\n            dposition: isRadial ? 'chartArea' : isHorizontal ? 'bottom' : 'left',\n            dtype: isRadial ? 'radialLinear' : isHorizontal ? 'category' : 'linear'\n          };\n        })\n      );\n    }\n\n    each(items, (item) => {\n      const scaleOptions = item.options;\n      const id = scaleOptions.id;\n      const axis = determineAxis(id, scaleOptions);\n      const scaleType = valueOrDefault(scaleOptions.type, item.dtype);\n\n      if (scaleOptions.position === undefined || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) {\n        scaleOptions.position = item.dposition;\n      }\n\n      updated[id] = true;\n      let scale = null;\n      if (id in scales && scales[id].type === scaleType) {\n        scale = scales[id];\n      } else {\n        const scaleClass = registry.getScale(scaleType);\n        scale = new scaleClass({\n          id,\n          type: scaleType,\n          ctx: this.ctx,\n          chart: this\n        });\n        scales[scale.id] = scale;\n      }\n\n      scale.init(scaleOptions, options);\n    });\n    // clear up discarded scales\n    each(updated, (hasUpdated, id) => {\n      if (!hasUpdated) {\n        delete scales[id];\n      }\n    });\n\n    each(scales, (scale) => {\n      layouts.configure(this, scale, scale.options);\n      layouts.addBox(this, scale);\n    });\n  }\n\n  /**\n\t * @private\n\t */\n  _updateMetasets() {\n    const metasets = this._metasets;\n    const numData = this.data.datasets.length;\n    const numMeta = metasets.length;\n\n    metasets.sort((a, b) => a.index - b.index);\n    if (numMeta > numData) {\n      for (let i = numData; i < numMeta; ++i) {\n        this._destroyDatasetMeta(i);\n      }\n      metasets.splice(numData, numMeta - numData);\n    }\n    this._sortedMetasets = metasets.slice(0).sort(compare2Level('order', 'index'));\n  }\n\n  /**\n\t * @private\n\t */\n  _removeUnreferencedMetasets() {\n    const {_metasets: metasets, data: {datasets}} = this;\n    if (metasets.length > datasets.length) {\n      delete this._stacks;\n    }\n    metasets.forEach((meta, index) => {\n      if (datasets.filter(x => x === meta._dataset).length === 0) {\n        this._destroyDatasetMeta(index);\n      }\n    });\n  }\n\n  buildOrUpdateControllers() {\n    const newControllers = [];\n    const datasets = this.data.datasets;\n    let i, ilen;\n\n    this._removeUnreferencedMetasets();\n\n    for (i = 0, ilen = datasets.length; i < ilen; i++) {\n      const dataset = datasets[i];\n      let meta = this.getDatasetMeta(i);\n      const type = dataset.type || this.config.type;\n\n      if (meta.type && meta.type !== type) {\n        this._destroyDatasetMeta(i);\n        meta = this.getDatasetMeta(i);\n      }\n      meta.type = type;\n      meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);\n      meta.order = dataset.order || 0;\n      meta.index = i;\n      meta.label = '' + dataset.label;\n      meta.visible = this.isDatasetVisible(i);\n\n      if (meta.controller) {\n        meta.controller.updateIndex(i);\n        meta.controller.linkScales();\n      } else {\n        const ControllerClass = registry.getController(type);\n        const {datasetElementType, dataElementType} = defaults.datasets[type];\n        Object.assign(ControllerClass, {\n          dataElementType: registry.getElement(dataElementType),\n          datasetElementType: datasetElementType && registry.getElement(datasetElementType)\n        });\n        meta.controller = new ControllerClass(this, i);\n        newControllers.push(meta.controller);\n      }\n    }\n\n    this._updateMetasets();\n    return newControllers;\n  }\n\n  /**\n\t * Reset the elements of all datasets\n\t * @private\n\t */\n  _resetElements() {\n    each(this.data.datasets, (dataset, datasetIndex) => {\n      this.getDatasetMeta(datasetIndex).controller.reset();\n    }, this);\n  }\n\n  /**\n\t* Resets the chart back to its state before the initial animation\n\t*/\n  reset() {\n    this._resetElements();\n    this.notifyPlugins('reset');\n  }\n\n  update(mode) {\n    const config = this.config;\n\n    config.update();\n    const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());\n    const animsDisabled = this._animationsDisabled = !options.animation;\n\n    this._updateScales();\n    this._checkEventBindings();\n    this._updateHiddenIndices();\n\n    // plugins options references might have change, let's invalidate the cache\n    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167\n    this._plugins.invalidate();\n\n    if (this.notifyPlugins('beforeUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    // Make sure dataset controllers are updated and new controllers are reset\n    const newControllers = this.buildOrUpdateControllers();\n\n    this.notifyPlugins('beforeElementsUpdate');\n\n    // Make sure all dataset controllers have correct meta data counts\n    let minPadding = 0;\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {\n      const {controller} = this.getDatasetMeta(i);\n      const reset = !animsDisabled && newControllers.indexOf(controller) === -1;\n      // New controllers will be reset after the layout pass, so we only want to modify\n      // elements added to new datasets\n      controller.buildOrUpdateElements(reset);\n      minPadding = Math.max(+controller.getMaxOverflow(), minPadding);\n    }\n    minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;\n    this._updateLayout(minPadding);\n\n    // Only reset the controllers if we have animations\n    if (!animsDisabled) {\n      // Can only reset the new controllers after the scales have been updated\n      // Reset is done to get the starting point for the initial animation\n      each(newControllers, (controller) => {\n        controller.reset();\n      });\n    }\n\n    this._updateDatasets(mode);\n\n    // Do this before render so that any plugins that need final scale updates can use it\n    this.notifyPlugins('afterUpdate', {mode});\n\n    this._layers.sort(compare2Level('z', '_idx'));\n\n    // Replay last event from before update, or set hover styles on active elements\n    const {_active, _lastEvent} = this;\n    if (_lastEvent) {\n      this._eventHandler(_lastEvent, true);\n    } else if (_active.length) {\n      this._updateHoverStyles(_active, _active, true);\n    }\n\n    this.render();\n  }\n\n  /**\n   * @private\n   */\n  _updateScales() {\n    each(this.scales, (scale) => {\n      layouts.removeBox(this, scale);\n    });\n\n    this.ensureScalesHaveIDs();\n    this.buildOrUpdateScales();\n  }\n\n  /**\n   * @private\n   */\n  _checkEventBindings() {\n    const options = this.options;\n    const existingEvents = new Set(Object.keys(this._listeners));\n    const newEvents = new Set(options.events);\n\n    if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {\n      // The configured events have changed. Rebind.\n      this.unbindEvents();\n      this.bindEvents();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _updateHiddenIndices() {\n    const {_hiddenIndices} = this;\n    const changes = this._getUniformDataChanges() || [];\n    for (const {method, start, count} of changes) {\n      const move = method === '_removeElements' ? -count : count;\n      moveNumericKeys(_hiddenIndices, start, move);\n    }\n  }\n\n  /**\n   * @private\n   */\n  _getUniformDataChanges() {\n    const _dataChanges = this._dataChanges;\n    if (!_dataChanges || !_dataChanges.length) {\n      return;\n    }\n\n    this._dataChanges = [];\n    const datasetCount = this.data.datasets.length;\n    const makeSet = (idx) => new Set(\n      _dataChanges\n        .filter(c => c[0] === idx)\n        .map((c, i) => i + ',' + c.splice(1).join(','))\n    );\n\n    const changeSet = makeSet(0);\n    for (let i = 1; i < datasetCount; i++) {\n      if (!setsEqual(changeSet, makeSet(i))) {\n        return;\n      }\n    }\n    return Array.from(changeSet)\n      .map(c => c.split(','))\n      .map(a => ({method: a[1], start: +a[2], count: +a[3]}));\n  }\n\n  /**\n\t * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`\n\t * hook, in which case, plugins will not be called on `afterLayout`.\n\t * @private\n\t */\n  _updateLayout(minPadding) {\n    if (this.notifyPlugins('beforeLayout', {cancelable: true}) === false) {\n      return;\n    }\n\n    layouts.update(this, this.width, this.height, minPadding);\n\n    const area = this.chartArea;\n    const noArea = area.width <= 0 || area.height <= 0;\n\n    this._layers = [];\n    each(this.boxes, (box) => {\n      if (noArea && box.position === 'chartArea') {\n        // Skip drawing and configuring chartArea boxes when chartArea is zero or negative\n        return;\n      }\n\n      // configure is called twice, once in core.scale.update and once here.\n      // Here the boxes are fully updated and at their final positions.\n      if (box.configure) {\n        box.configure();\n      }\n      this._layers.push(...box._layers());\n    }, this);\n\n    this._layers.forEach((item, index) => {\n      item._idx = index;\n    });\n\n    this.notifyPlugins('afterLayout');\n  }\n\n  /**\n\t * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.\n\t * @private\n\t */\n  _updateDatasets(mode) {\n    if (this.notifyPlugins('beforeDatasetsUpdate', {mode, cancelable: true}) === false) {\n      return;\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this.getDatasetMeta(i).controller.configure();\n    }\n\n    for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._updateDataset(i, isFunction(mode) ? mode({datasetIndex: i}) : mode);\n    }\n\n    this.notifyPlugins('afterDatasetsUpdate', {mode});\n  }\n\n  /**\n\t * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`\n\t * hook, in which case, plugins will not be called on `afterDatasetUpdate`.\n\t * @private\n\t */\n  _updateDataset(index, mode) {\n    const meta = this.getDatasetMeta(index);\n    const args = {meta, index, mode, cancelable: true};\n\n    if (this.notifyPlugins('beforeDatasetUpdate', args) === false) {\n      return;\n    }\n\n    meta.controller._update(mode);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetUpdate', args);\n  }\n\n  render() {\n    if (this.notifyPlugins('beforeRender', {cancelable: true}) === false) {\n      return;\n    }\n\n    if (animator.has(this)) {\n      if (this.attached && !animator.running(this)) {\n        animator.start(this);\n      }\n    } else {\n      this.draw();\n      onAnimationsComplete({chart: this});\n    }\n  }\n\n  draw() {\n    let i;\n    if (this._resizeBeforeDraw) {\n      const {width, height} = this._resizeBeforeDraw;\n      this._resize(width, height);\n      this._resizeBeforeDraw = null;\n    }\n    this.clear();\n\n    if (this.width <= 0 || this.height <= 0) {\n      return;\n    }\n\n    if (this.notifyPlugins('beforeDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't\n    // currently be part of layers. Instead, we draw\n    // layers <= 0 before(default, backward compat), and the rest after\n    const layers = this._layers;\n    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this._drawDatasets();\n\n    // Rest of layers\n    for (; i < layers.length; ++i) {\n      layers[i].draw(this.chartArea);\n    }\n\n    this.notifyPlugins('afterDraw');\n  }\n\n  /**\n\t * @private\n\t */\n  _getSortedDatasetMetas(filterVisible) {\n    const metasets = this._sortedMetasets;\n    const result = [];\n    let i, ilen;\n\n    for (i = 0, ilen = metasets.length; i < ilen; ++i) {\n      const meta = metasets[i];\n      if (!filterVisible || meta.visible) {\n        result.push(meta);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n\t * Gets the visible dataset metas in drawing order\n\t * @return {object[]}\n\t */\n  getSortedVisibleDatasetMetas() {\n    return this._getSortedDatasetMetas(true);\n  }\n\n  /**\n\t * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetsDraw`.\n\t * @private\n\t */\n  _drawDatasets() {\n    if (this.notifyPlugins('beforeDatasetsDraw', {cancelable: true}) === false) {\n      return;\n    }\n\n    const metasets = this.getSortedVisibleDatasetMetas();\n    for (let i = metasets.length - 1; i >= 0; --i) {\n      this._drawDataset(metasets[i]);\n    }\n\n    this.notifyPlugins('afterDatasetsDraw');\n  }\n\n  /**\n\t * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`\n\t * hook, in which case, plugins will not be called on `afterDatasetDraw`.\n\t * @private\n\t */\n  _drawDataset(meta) {\n    const ctx = this.ctx;\n    const clip = meta._clip;\n    const useClip = !clip.disabled;\n    const area = getDatasetArea(meta, this.chartArea);\n    const args = {\n      meta,\n      index: meta.index,\n      cancelable: true\n    };\n\n    if (this.notifyPlugins('beforeDatasetDraw', args) === false) {\n      return;\n    }\n\n    if (useClip) {\n      clipArea(ctx, {\n        left: clip.left === false ? 0 : area.left - clip.left,\n        right: clip.right === false ? this.width : area.right + clip.right,\n        top: clip.top === false ? 0 : area.top - clip.top,\n        bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom\n      });\n    }\n\n    meta.controller.draw();\n\n    if (useClip) {\n      unclipArea(ctx);\n    }\n\n    args.cancelable = false;\n    this.notifyPlugins('afterDatasetDraw', args);\n  }\n\n  /**\n   * Checks whether the given point is in the chart area.\n   * @param {Point} point - in relative coordinates (see, e.g., getRelativePosition)\n   * @returns {boolean}\n   */\n  isPointInArea(point) {\n    return _isPointInArea(point, this.chartArea, this._minPadding);\n  }\n\n  getElementsAtEventForMode(e, mode, options, useFinalPosition) {\n    const method = Interaction.modes[mode];\n    if (typeof method === 'function') {\n      return method(this, e, options, useFinalPosition);\n    }\n\n    return [];\n  }\n\n  getDatasetMeta(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    const metasets = this._metasets;\n    let meta = metasets.filter(x => x && x._dataset === dataset).pop();\n\n    if (!meta) {\n      meta = {\n        type: null,\n        data: [],\n        dataset: null,\n        controller: null,\n        hidden: null,\t\t\t// See isDatasetVisible() comment\n        xAxisID: null,\n        yAxisID: null,\n        order: dataset && dataset.order || 0,\n        index: datasetIndex,\n        _dataset: dataset,\n        _parsed: [],\n        _sorted: false\n      };\n      metasets.push(meta);\n    }\n\n    return meta;\n  }\n\n  getContext() {\n    return this.$context || (this.$context = createContext(null, {chart: this, type: 'chart'}));\n  }\n\n  getVisibleDatasetCount() {\n    return this.getSortedVisibleDatasetMetas().length;\n  }\n\n  isDatasetVisible(datasetIndex) {\n    const dataset = this.data.datasets[datasetIndex];\n    if (!dataset) {\n      return false;\n    }\n\n    const meta = this.getDatasetMeta(datasetIndex);\n\n    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,\n    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.\n    return typeof meta.hidden === 'boolean' ? !meta.hidden : !dataset.hidden;\n  }\n\n  setDatasetVisibility(datasetIndex, visible) {\n    const meta = this.getDatasetMeta(datasetIndex);\n    meta.hidden = !visible;\n  }\n\n  toggleDataVisibility(index) {\n    this._hiddenIndices[index] = !this._hiddenIndices[index];\n  }\n\n  getDataVisibility(index) {\n    return !this._hiddenIndices[index];\n  }\n\n  /**\n\t * @private\n\t */\n  _updateVisibility(datasetIndex, dataIndex, visible) {\n    const mode = visible ? 'show' : 'hide';\n    const meta = this.getDatasetMeta(datasetIndex);\n    const anims = meta.controller._resolveAnimations(undefined, mode);\n\n    if (defined(dataIndex)) {\n      meta.data[dataIndex].hidden = !visible;\n      this.update();\n    } else {\n      this.setDatasetVisibility(datasetIndex, visible);\n      // Animate visible state, so hide animation can be seen. This could be handled better if update / updateDataset returned a Promise.\n      anims.update(meta, {visible});\n      this.update((ctx) => ctx.datasetIndex === datasetIndex ? mode : undefined);\n    }\n  }\n\n  hide(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, false);\n  }\n\n  show(datasetIndex, dataIndex) {\n    this._updateVisibility(datasetIndex, dataIndex, true);\n  }\n\n  /**\n\t * @private\n\t */\n  _destroyDatasetMeta(datasetIndex) {\n    const meta = this._metasets[datasetIndex];\n    if (meta && meta.controller) {\n      meta.controller._destroy();\n    }\n    delete this._metasets[datasetIndex];\n  }\n\n  _stop() {\n    let i, ilen;\n    this.stop();\n    animator.remove(this);\n\n    for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {\n      this._destroyDatasetMeta(i);\n    }\n  }\n\n  destroy() {\n    this.notifyPlugins('beforeDestroy');\n    const {canvas, ctx} = this;\n\n    this._stop();\n    this.config.clearCache();\n\n    if (canvas) {\n      this.unbindEvents();\n      clearCanvas(canvas, ctx);\n      this.platform.releaseContext(ctx);\n      this.canvas = null;\n      this.ctx = null;\n    }\n\n    delete instances[this.id];\n\n    this.notifyPlugins('afterDestroy');\n  }\n\n  toBase64Image(...args) {\n    return this.canvas.toDataURL(...args);\n  }\n\n  /**\n\t * @private\n\t */\n  bindEvents() {\n    this.bindUserEvents();\n    if (this.options.responsive) {\n      this.bindResponsiveEvents();\n    } else {\n      this.attached = true;\n    }\n  }\n\n  /**\n   * @private\n   */\n  bindUserEvents() {\n    const listeners = this._listeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n\n    const listener = (e, x, y) => {\n      e.offsetX = x;\n      e.offsetY = y;\n      this._eventHandler(e);\n    };\n\n    each(this.options.events, (type) => _add(type, listener));\n  }\n\n  /**\n   * @private\n   */\n  bindResponsiveEvents() {\n    if (!this._responsiveListeners) {\n      this._responsiveListeners = {};\n    }\n    const listeners = this._responsiveListeners;\n    const platform = this.platform;\n\n    const _add = (type, listener) => {\n      platform.addEventListener(this, type, listener);\n      listeners[type] = listener;\n    };\n    const _remove = (type, listener) => {\n      if (listeners[type]) {\n        platform.removeEventListener(this, type, listener);\n        delete listeners[type];\n      }\n    };\n\n    const listener = (width, height) => {\n      if (this.canvas) {\n        this.resize(width, height);\n      }\n    };\n\n    let detached; // eslint-disable-line prefer-const\n    const attached = () => {\n      _remove('attach', attached);\n\n      this.attached = true;\n      this.resize();\n\n      _add('resize', listener);\n      _add('detach', detached);\n    };\n\n    detached = () => {\n      this.attached = false;\n\n      _remove('resize', listener);\n\n      // Stop animating and remove metasets, so when re-attached, the animations start from beginning.\n      this._stop();\n      this._resize(0, 0);\n\n      _add('attach', attached);\n    };\n\n    if (platform.isAttached(this.canvas)) {\n      attached();\n    } else {\n      detached();\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  unbindEvents() {\n    each(this._listeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._listeners = {};\n\n    each(this._responsiveListeners, (listener, type) => {\n      this.platform.removeEventListener(this, type, listener);\n    });\n    this._responsiveListeners = undefined;\n  }\n\n  updateHoverStyle(items, mode, enabled) {\n    const prefix = enabled ? 'set' : 'remove';\n    let meta, item, i, ilen;\n\n    if (mode === 'dataset') {\n      meta = this.getDatasetMeta(items[0].datasetIndex);\n      meta.controller['_' + prefix + 'DatasetHoverStyle']();\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      item = items[i];\n      const controller = item && this.getDatasetMeta(item.datasetIndex).controller;\n      if (controller) {\n        controller[prefix + 'HoverStyle'](item.element, item.datasetIndex, item.index);\n      }\n    }\n  }\n\n  /**\n\t * Get active (hovered) elements\n\t * @returns array\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active (hovered) elements\n\t * @param {array} activeElements New active data points\n\t */\n  setActiveElements(activeElements) {\n    const lastActive = this._active || [];\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.getDatasetMeta(datasetIndex);\n      if (!meta) {\n        throw new Error('No dataset found at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(active, lastActive);\n\n    if (changed) {\n      this._active = active;\n      // Make sure we don't use the previous mouse event to override the active elements in update.\n      this._lastEvent = null;\n      this._updateHoverStyles(active, lastActive);\n    }\n  }\n\n  /**\n\t * Calls enabled plugins on the specified hook and with the given args.\n\t * This method immediately returns as soon as a plugin explicitly returns false. The\n\t * returned value can be used, for instance, to interrupt the current action.\n\t * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').\n\t * @param {Object} [args] - Extra arguments to apply to the hook call.\n   * @param {import('./core.plugins.js').filterCallback} [filter] - Filtering function for limiting which plugins are notified\n\t * @returns {boolean} false if any of the plugins return false, else returns true.\n\t */\n  notifyPlugins(hook, args, filter) {\n    return this._plugins.notify(this, hook, args, filter);\n  }\n\n  /**\n   * Check if a plugin with the specific ID is registered and enabled\n   * @param {string} pluginId - The ID of the plugin of which to check if it is enabled\n   * @returns {boolean}\n   */\n  isPluginEnabled(pluginId) {\n    return this._plugins._cache.filter(p => p.plugin.id === pluginId).length === 1;\n  }\n\n  /**\n\t * @private\n\t */\n  _updateHoverStyles(active, lastActive, replay) {\n    const hoverOptions = this.options.hover;\n    const diff = (a, b) => a.filter(x => !b.some(y => x.datasetIndex === y.datasetIndex && x.index === y.index));\n    const deactivated = diff(lastActive, active);\n    const activated = replay ? active : diff(active, lastActive);\n\n    if (deactivated.length) {\n      this.updateHoverStyle(deactivated, hoverOptions.mode, false);\n    }\n\n    if (activated.length && hoverOptions.mode) {\n      this.updateHoverStyle(activated, hoverOptions.mode, true);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _eventHandler(e, replay) {\n    const args = {\n      event: e,\n      replay,\n      cancelable: true,\n      inChartArea: this.isPointInArea(e)\n    };\n    const eventFilter = (plugin) => (plugin.options.events || this.options.events).includes(e.native.type);\n\n    if (this.notifyPlugins('beforeEvent', args, eventFilter) === false) {\n      return;\n    }\n\n    const changed = this._handleEvent(e, replay, args.inChartArea);\n\n    args.cancelable = false;\n    this.notifyPlugins('afterEvent', args, eventFilter);\n\n    if (changed || args.changed) {\n      this.render();\n    }\n\n    return this;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e the event to handle\n\t * @param {boolean} [replay] - true if the event was replayed by `update`\n   * @param {boolean} [inChartArea] - true if the event is inside chartArea\n\t * @return {boolean} true if the chart needs to re-render\n\t * @private\n\t */\n  _handleEvent(e, replay, inChartArea) {\n    const {_active: lastActive = [], options} = this;\n\n    // If the event is replayed from `update`, we should evaluate with the final positions.\n    //\n    // The `replay`:\n    // It's the last event (excluding click) that has occurred before `update`.\n    // So mouse has not moved. It's also over the chart, because there is a `replay`.\n    //\n    // The why:\n    // If animations are active, the elements haven't moved yet compared to state before update.\n    // But if they will, we are activating the elements that would be active, if this check\n    // was done after the animations have completed. => \"final positions\".\n    // If there is no animations, the \"final\" and \"current\" positions are equal.\n    // This is done so we do not have to evaluate the active elements each animation frame\n    // - it would be expensive.\n    const useFinalPosition = replay;\n    const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);\n    const isClick = _isClickEvent(e);\n    const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);\n\n    if (inChartArea) {\n      // Set _lastEvent to null while we are processing the event handlers.\n      // This prevents recursion if the handler calls chart.update()\n      this._lastEvent = null;\n\n      // Invoke onHover hook\n      callCallback(options.onHover, [e, active, this], this);\n\n      if (isClick) {\n        callCallback(options.onClick, [e, active, this], this);\n      }\n    }\n\n    const changed = !_elementsEqual(active, lastActive);\n    if (changed || replay) {\n      this._active = active;\n      this._updateHoverStyles(active, lastActive, replay);\n    }\n\n    this._lastEvent = lastEvent;\n\n    return changed;\n  }\n\n  /**\n   * @param {ChartEvent} e - The event\n   * @param {import('../types/index.js').ActiveElement[]} lastActive - Previously active elements\n   * @param {boolean} inChartArea - Is the envent inside chartArea\n   * @param {boolean} useFinalPosition - Should the evaluation be done with current or final (after animation) element positions\n   * @returns {import('../types/index.js').ActiveElement[]} - The active elements\n   * @pravate\n   */\n  _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      return lastActive;\n    }\n\n    const hoverOptions = this.options.hover;\n    return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);\n  }\n}\n\n// @ts-ignore\nfunction invalidatePlugins() {\n  return each(Chart.instances, (chart) => chart._plugins.invalidate());\n}\n\nexport default Chart;\n","import {_isDomSupported} from '../helpers/index.js';\nimport BasePlatform from './platform.base.js';\nimport BasicPlatform from './platform.basic.js';\nimport DomPlatform from './platform.dom.js';\n\nexport function _detectPlatform(canvas) {\n  if (!_isDomSupported() || (typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n    return BasicPlatform;\n  }\n  return DomPlatform;\n}\n\nexport {BasePlatform, BasicPlatform, DomPlatform};\n","import Element from '../core/core.element.js';\nimport {_angleBetween, getAngleFromPoint, TAU, HALF_PI, valueOrDefault} from '../helpers/index.js';\nimport {PI, _isBetween, _limitValue} from '../helpers/helpers.math.js';\nimport {_readValueToProps} from '../helpers/helpers.options.js';\nimport type {ArcOptions, Point} from '../types/index.js';\n\n\nfunction clipArc(ctx: CanvasRenderingContext2D, element: ArcElement, endAngle: number) {\n  const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;\n  let angleMargin = pixelMargin / outerRadius;\n\n  // Draw an inner border by clipping the arc and drawing a double-width border\n  // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders\n  ctx.beginPath();\n  ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);\n  if (innerRadius > pixelMargin) {\n    angleMargin = pixelMargin / innerRadius;\n    ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);\n  } else {\n    ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);\n  }\n  ctx.closePath();\n  ctx.clip();\n}\n\nfunction toRadiusCorners(value) {\n  return _readValueToProps(value, ['outerStart', 'outerEnd', 'innerStart', 'innerEnd']);\n}\n\n/**\n * Parse border radius from the provided options\n */\nfunction parseBorderRadius(arc: ArcElement, innerRadius: number, outerRadius: number, angleDelta: number) {\n  const o = toRadiusCorners(arc.options.borderRadius);\n  const halfThickness = (outerRadius - innerRadius) / 2;\n  const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);\n\n  // Outer limits are complicated. We want to compute the available angular distance at\n  // a radius of outerRadius - borderRadius because for small angular distances, this term limits.\n  // We compute at r = outerRadius - borderRadius because this circle defines the center of the border corners.\n  //\n  // If the borderRadius is large, that value can become negative.\n  // This causes the outer borders to lose their radius entirely, which is rather unexpected. To solve that, if borderRadius > outerRadius\n  // we know that the thickness term will dominate and compute the limits at that point\n  const computeOuterLimit = (val) => {\n    const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;\n    return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));\n  };\n\n  return {\n    outerStart: computeOuterLimit(o.outerStart),\n    outerEnd: computeOuterLimit(o.outerEnd),\n    innerStart: _limitValue(o.innerStart, 0, innerLimit),\n    innerEnd: _limitValue(o.innerEnd, 0, innerLimit),\n  };\n}\n\n/**\n * Convert (r, ) to (x, y)\n */\nfunction rThetaToXY(r: number, theta: number, x: number, y: number) {\n  return {\n    x: x + r * Math.cos(theta),\n    y: y + r * Math.sin(theta),\n  };\n}\n\n\n/**\n * Path the arc, respecting border radius by separating into left and right halves.\n *\n *   Start      End\n *\n *    1--->a--->2    Outer\n *   /           \\\n *   8           3\n *   |           |\n *   |           |\n *   7           4\n *   \\           /\n *    6<---b<---5    Inner\n */\nfunction pathArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  end: number,\n  circular: boolean,\n) {\n  const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;\n\n  const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);\n  const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;\n\n  let spacingOffset = 0;\n  const alpha = end - start;\n\n  if (spacing) {\n    // When spacing is present, it is the same for all items\n    // So we adjust the start and end angle of the arc such that\n    // the distance is the same as it would be without the spacing\n    const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;\n    const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;\n    const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;\n    const adjustedAngle = avNogSpacingRadius !== 0 ? (alpha * avNogSpacingRadius) / (avNogSpacingRadius + spacing) : alpha;\n    spacingOffset = (alpha - adjustedAngle) / 2;\n  }\n\n  const beta = Math.max(0.001, alpha * outerRadius - offset / PI) / outerRadius;\n  const angleOffset = (alpha - beta) / 2;\n  const startAngle = start + angleOffset + spacingOffset;\n  const endAngle = end - angleOffset - spacingOffset;\n  const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius(element, innerRadius, outerRadius, endAngle - startAngle);\n\n  const outerStartAdjustedRadius = outerRadius - outerStart;\n  const outerEndAdjustedRadius = outerRadius - outerEnd;\n  const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;\n  const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;\n\n  const innerStartAdjustedRadius = innerRadius + innerStart;\n  const innerEndAdjustedRadius = innerRadius + innerEnd;\n  const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;\n  const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;\n\n  ctx.beginPath();\n\n  if (circular) {\n    // The first arc segments from point 1 to point a to point 2\n    const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;\n    ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);\n    ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);\n\n    // The corner segment from point 2 to point 3\n    if (outerEnd > 0) {\n      const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);\n    }\n\n    // The line from point 3 to point 4\n    const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);\n    ctx.lineTo(p4.x, p4.y);\n\n    // The corner segment from point 4 to point 5\n    if (innerEnd > 0) {\n      const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);\n    }\n\n    // The inner arc from point 5 to point b to point 6\n    const innerMidAdjustedAngle = ((endAngle - (innerEnd / innerRadius)) + (startAngle + (innerStart / innerRadius))) / 2;\n    ctx.arc(x, y, innerRadius, endAngle - (innerEnd / innerRadius), innerMidAdjustedAngle, true);\n    ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + (innerStart / innerRadius), true);\n\n    // The corner segment from point 6 to point 7\n    if (innerStart > 0) {\n      const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);\n    }\n\n    // The line from point 7 to point 8\n    const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);\n    ctx.lineTo(p8.x, p8.y);\n\n    // The corner segment from point 8 to point 1\n    if (outerStart > 0) {\n      const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);\n      ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);\n    }\n  } else {\n    ctx.moveTo(x, y);\n\n    const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;\n    const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerStartX, outerStartY);\n\n    const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;\n    const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;\n    ctx.lineTo(outerEndX, outerEndY);\n  }\n\n  ctx.closePath();\n}\n\nfunction drawArc(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference} = element;\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.fill();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n  pathArc(ctx, element, offset, spacing, endAngle, circular);\n  ctx.fill();\n  return endAngle;\n}\n\nfunction drawBorder(\n  ctx: CanvasRenderingContext2D,\n  element: ArcElement,\n  offset: number,\n  spacing: number,\n  circular: boolean,\n) {\n  const {fullCircles, startAngle, circumference, options} = element;\n  const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;\n  const inner = options.borderAlign === 'inner';\n\n  if (!borderWidth) {\n    return;\n  }\n\n  ctx.setLineDash(borderDash || []);\n  ctx.lineDashOffset = borderDashOffset;\n\n  if (inner) {\n    ctx.lineWidth = borderWidth * 2;\n    ctx.lineJoin = borderJoinStyle || 'round';\n  } else {\n    ctx.lineWidth = borderWidth;\n    ctx.lineJoin = borderJoinStyle || 'bevel';\n  }\n\n  let endAngle = element.endAngle;\n  if (fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    for (let i = 0; i < fullCircles; ++i) {\n      ctx.stroke();\n    }\n    if (!isNaN(circumference)) {\n      endAngle = startAngle + (circumference % TAU || TAU);\n    }\n  }\n\n  if (inner) {\n    clipArc(ctx, element, endAngle);\n  }\n\n  if (!fullCircles) {\n    pathArc(ctx, element, offset, spacing, endAngle, circular);\n    ctx.stroke();\n  }\n}\n\nexport interface ArcProps extends Point {\n  startAngle: number;\n  endAngle: number;\n  innerRadius: number;\n  outerRadius: number;\n  circumference: number;\n}\n\nexport default class ArcElement extends Element<ArcProps, ArcOptions> {\n\n  static id = 'arc';\n\n  static defaults = {\n    borderAlign: 'center',\n    borderColor: '#fff',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: undefined,\n    borderRadius: 0,\n    borderWidth: 2,\n    offset: 0,\n    spacing: 0,\n    angle: undefined,\n    circular: true,\n  };\n\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor'\n  };\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash'\n  };\n\n  circumference: number;\n  endAngle: number;\n  fullCircles: number;\n  innerRadius: number;\n  outerRadius: number;\n  pixelMargin: number;\n  startAngle: number;\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.circumference = undefined;\n    this.startAngle = undefined;\n    this.endAngle = undefined;\n    this.innerRadius = undefined;\n    this.outerRadius = undefined;\n    this.pixelMargin = 0;\n    this.fullCircles = 0;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(chartX: number, chartY: number, useFinalPosition: boolean) {\n    const point = this.getProps(['x', 'y'], useFinalPosition);\n    const {angle, distance} = getAngleFromPoint(point, {x: chartX, y: chartY});\n    const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius',\n      'circumference'\n    ], useFinalPosition);\n    const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;\n    const _circumference = valueOrDefault(circumference, endAngle - startAngle);\n    const betweenAngles = _circumference >= TAU || _angleBetween(angle, startAngle, endAngle);\n    const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);\n\n    return (betweenAngles && withinRadius);\n  }\n\n  getCenterPoint(useFinalPosition: boolean) {\n    const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([\n      'x',\n      'y',\n      'startAngle',\n      'endAngle',\n      'innerRadius',\n      'outerRadius'\n    ], useFinalPosition);\n    const {offset, spacing} = this.options;\n    const halfAngle = (startAngle + endAngle) / 2;\n    const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;\n    return {\n      x: x + Math.cos(halfAngle) * halfRadius,\n      y: y + Math.sin(halfAngle) * halfRadius\n    };\n  }\n\n  tooltipPosition(useFinalPosition: boolean) {\n    return this.getCenterPoint(useFinalPosition);\n  }\n\n  draw(ctx: CanvasRenderingContext2D) {\n    const {options, circumference} = this;\n    const offset = (options.offset || 0) / 4;\n    const spacing = (options.spacing || 0) / 2;\n    const circular = options.circular;\n    this.pixelMargin = (options.borderAlign === 'inner') ? 0.33 : 0;\n    this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;\n\n    if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) {\n      return;\n    }\n\n    ctx.save();\n\n    const halfAngle = (this.startAngle + this.endAngle) / 2;\n    ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);\n    const fix = 1 - Math.sin(Math.min(PI, circumference || 0));\n    const radiusOffset = offset * fix;\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n\n    drawArc(ctx, this, radiusOffset, spacing, circular);\n    drawBorder(ctx, this, radiusOffset, spacing, circular);\n\n    ctx.restore();\n  }\n}\n","import Element from '../core/core.element.js';\nimport {_bezierInterpolation, _pointInLine, _steppedInterpolation} from '../helpers/helpers.interpolation.js';\nimport {_computeSegments, _boundSegments} from '../helpers/helpers.segment.js';\nimport {_steppedLineTo, _bezierCurveTo} from '../helpers/helpers.canvas.js';\nimport {_updateBezierControlPoints} from '../helpers/helpers.curve.js';\nimport {valueOrDefault} from '../helpers/index.js';\n\n/**\n * @typedef { import('./element.point.js').default } PointElement\n */\n\nfunction setStyle(ctx, options, style = options) {\n  ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);\n  ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));\n  ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);\n  ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);\n  ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);\n  ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);\n}\n\nfunction lineTo(ctx, previous, target) {\n  ctx.lineTo(target.x, target.y);\n}\n\n/**\n * @returns {any}\n */\nfunction getLineMethod(options) {\n  if (options.stepped) {\n    return _steppedLineTo;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierCurveTo;\n  }\n\n  return lineTo;\n}\n\nfunction pathVars(points, segment, params = {}) {\n  const count = points.length;\n  const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;\n  const {start: segmentStart, end: segmentEnd} = segment;\n  const start = Math.max(paramsStart, segmentStart);\n  const end = Math.min(paramsEnd, segmentEnd);\n  const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;\n\n  return {\n    count,\n    start,\n    loop: segment.loop,\n    ilen: end < start && !outside ? count + end - start : end - start\n  };\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction pathSegment(ctx, line, segment, params) {\n  const {points, options} = line;\n  const {count, start, loop, ilen} = pathVars(points, segment, params);\n  const lineMethod = getLineMethod(options);\n  // eslint-disable-next-line prefer-const\n  let {move = true, reverse} = params || {};\n  let i, point, prev;\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[(start + (reverse ? ilen - i : i)) % count];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    } else if (move) {\n      ctx.moveTo(point.x, point.y);\n      move = false;\n    } else {\n      lineMethod(ctx, prev, point, reverse, options.stepped);\n    }\n\n    prev = point;\n  }\n\n  if (loop) {\n    point = points[(start + (reverse ? ilen : 0)) % count];\n    lineMethod(ctx, prev, point, reverse, options.stepped);\n  }\n\n  return !!loop;\n}\n\n/**\n * Create path from points, grouping by truncated x-coordinate\n * Points need to be in order by x-coordinate for this to work efficiently\n * @param {CanvasRenderingContext2D|Path2D} ctx - Context\n * @param {LineElement} line\n * @param {object} segment\n * @param {number} segment.start - start index of the segment, referring the points array\n * @param {number} segment.end - end index of the segment, referring the points array\n * @param {boolean} segment.loop - indicates that the segment is a loop\n * @param {object} params\n * @param {boolean} params.move - move to starting point (vs line to it)\n * @param {boolean} params.reverse - path the segment from end to start\n * @param {number} params.start - limit segment to points starting from `start` index\n * @param {number} params.end - limit segment to points ending at `start` + `count` index\n */\nfunction fastPathSegment(ctx, line, segment, params) {\n  const points = line.points;\n  const {count, start, ilen} = pathVars(points, segment, params);\n  const {move = true, reverse} = params || {};\n  let avgX = 0;\n  let countX = 0;\n  let i, point, prevX, minY, maxY, lastY;\n\n  const pointIndex = (index) => (start + (reverse ? ilen - index : index)) % count;\n  const drawX = () => {\n    if (minY !== maxY) {\n      // Draw line to maxY and minY, using the average x-coordinate\n      ctx.lineTo(avgX, maxY);\n      ctx.lineTo(avgX, minY);\n      // Line to y-value of last point in group. So the line continues\n      // from correct position. Not using move, to have solid path.\n      ctx.lineTo(avgX, lastY);\n    }\n  };\n\n  if (move) {\n    point = points[pointIndex(0)];\n    ctx.moveTo(point.x, point.y);\n  }\n\n  for (i = 0; i <= ilen; ++i) {\n    point = points[pointIndex(i)];\n\n    if (point.skip) {\n      // If there is a skipped point inside a segment, spanGaps must be true\n      continue;\n    }\n\n    const x = point.x;\n    const y = point.y;\n    const truncX = x | 0; // truncated x-coordinate\n\n    if (truncX === prevX) {\n      // Determine `minY` / `maxY` and `avgX` while we stay within same x-position\n      if (y < minY) {\n        minY = y;\n      } else if (y > maxY) {\n        maxY = y;\n      }\n      // For first point in group, countX is `0`, so average will be `x` / 1.\n      avgX = (countX * avgX + x) / ++countX;\n    } else {\n      drawX();\n      // Draw line to next x-position, using the first (or only)\n      // y-value in that group\n      ctx.lineTo(x, y);\n\n      prevX = truncX;\n      countX = 0;\n      minY = maxY = y;\n    }\n    // Keep track of the last y-value in group\n    lastY = y;\n  }\n  drawX();\n}\n\n/**\n * @param {LineElement} line - the line\n * @returns {function}\n * @private\n */\nfunction _getSegmentMethod(line) {\n  const opts = line.options;\n  const borderDash = opts.borderDash && opts.borderDash.length;\n  const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== 'monotone' && !opts.stepped && !borderDash;\n  return useFastPath ? fastPathSegment : pathSegment;\n}\n\n/**\n * @private\n */\nfunction _getInterpolationMethod(options) {\n  if (options.stepped) {\n    return _steppedInterpolation;\n  }\n\n  if (options.tension || options.cubicInterpolationMode === 'monotone') {\n    return _bezierInterpolation;\n  }\n\n  return _pointInLine;\n}\n\nfunction strokePathWithCache(ctx, line, start, count) {\n  let path = line._path;\n  if (!path) {\n    path = line._path = new Path2D();\n    if (line.path(path, start, count)) {\n      path.closePath();\n    }\n  }\n  setStyle(ctx, line.options);\n  ctx.stroke(path);\n}\n\nfunction strokePathDirect(ctx, line, start, count) {\n  const {segments, options} = line;\n  const segmentMethod = _getSegmentMethod(line);\n\n  for (const segment of segments) {\n    setStyle(ctx, options, segment.style);\n    ctx.beginPath();\n    if (segmentMethod(ctx, line, segment, {start, end: start + count - 1})) {\n      ctx.closePath();\n    }\n    ctx.stroke();\n  }\n}\n\nconst usePath2D = typeof Path2D === 'function';\n\nfunction draw(ctx, line, start, count) {\n  if (usePath2D && !line.options.segment) {\n    strokePathWithCache(ctx, line, start, count);\n  } else {\n    strokePathDirect(ctx, line, start, count);\n  }\n}\n\nexport default class LineElement extends Element {\n\n  static id = 'line';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderCapStyle: 'butt',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 3,\n    capBezierPoints: true,\n    cubicInterpolationMode: 'default',\n    fill: false,\n    spanGaps: false,\n    stepped: false,\n    tension: 0,\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n\n  static descriptors = {\n    _scriptable: true,\n    _indexable: (name) => name !== 'borderDash' && name !== 'fill',\n  };\n\n\n  constructor(cfg) {\n    super();\n\n    this.animated = true;\n    this.options = undefined;\n    this._chart = undefined;\n    this._loop = undefined;\n    this._fullLoop = undefined;\n    this._path = undefined;\n    this._points = undefined;\n    this._segments = undefined;\n    this._decimated = false;\n    this._pointsUpdated = false;\n    this._datasetIndex = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  updateControlPoints(chartArea, indexAxis) {\n    const options = this.options;\n    if ((options.tension || options.cubicInterpolationMode === 'monotone') && !options.stepped && !this._pointsUpdated) {\n      const loop = options.spanGaps ? this._loop : this._fullLoop;\n      _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);\n      this._pointsUpdated = true;\n    }\n  }\n\n  set points(points) {\n    this._points = points;\n    delete this._segments;\n    delete this._path;\n    this._pointsUpdated = false;\n  }\n\n  get points() {\n    return this._points;\n  }\n\n  get segments() {\n    return this._segments || (this._segments = _computeSegments(this, this.options.segment));\n  }\n\n  /**\n\t * First non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  first() {\n    const segments = this.segments;\n    const points = this.points;\n    return segments.length && points[segments[0].start];\n  }\n\n  /**\n\t * Last non-skipped point on this line\n\t * @returns {PointElement|undefined}\n\t */\n  last() {\n    const segments = this.segments;\n    const points = this.points;\n    const count = segments.length;\n    return count && points[segments[count - 1].end];\n  }\n\n  /**\n\t * Interpolate a point in this line at the same value on `property` as\n\t * the reference `point` provided\n\t * @param {PointElement} point - the reference point\n\t * @param {string} property - the property to match on\n\t * @returns {PointElement|undefined}\n\t */\n  interpolate(point, property) {\n    const options = this.options;\n    const value = point[property];\n    const points = this.points;\n    const segments = _boundSegments(this, {property, start: value, end: value});\n\n    if (!segments.length) {\n      return;\n    }\n\n    const result = [];\n    const _interpolate = _getInterpolationMethod(options);\n    let i, ilen;\n    for (i = 0, ilen = segments.length; i < ilen; ++i) {\n      const {start, end} = segments[i];\n      const p1 = points[start];\n      const p2 = points[end];\n      if (p1 === p2) {\n        result.push(p1);\n        continue;\n      }\n      const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));\n      const interpolated = _interpolate(p1, p2, t, options.stepped);\n      interpolated[property] = point[property];\n      result.push(interpolated);\n    }\n    return result.length === 1 ? result[0] : result;\n  }\n\n  /**\n\t * Append a segment of this line to current path.\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} segment\n\t * @param {number} segment.start - start index of the segment, referring the points array\n \t * @param {number} segment.end - end index of the segment, referring the points array\n \t * @param {boolean} segment.loop - indicates that the segment is a loop\n\t * @param {object} params\n\t * @param {boolean} params.move - move to starting point (vs line to it)\n\t * @param {boolean} params.reverse - path the segment from end to start\n\t * @param {number} params.start - limit segment to points starting from `start` index\n\t * @param {number} params.end - limit segment to points ending at `start` + `count` index\n\t * @returns {undefined|boolean} - true if the segment is a full loop (path should be closed)\n\t */\n  pathSegment(ctx, segment, params) {\n    const segmentMethod = _getSegmentMethod(this);\n    return segmentMethod(ctx, this, segment, params);\n  }\n\n  /**\n\t * Append all segments of this line to current path.\n\t * @param {CanvasRenderingContext2D|Path2D} ctx\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t * @returns {undefined|boolean} - true if line is a full loop (path should be closed)\n\t */\n  path(ctx, start, count) {\n    const segments = this.segments;\n    const segmentMethod = _getSegmentMethod(this);\n    let loop = this._loop;\n\n    start = start || 0;\n    count = count || (this.points.length - start);\n\n    for (const segment of segments) {\n      loop &= segmentMethod(ctx, this, segment, {start, end: start + count - 1});\n    }\n    return !!loop;\n  }\n\n  /**\n\t * Draw\n\t * @param {CanvasRenderingContext2D} ctx\n\t * @param {object} chartArea\n\t * @param {number} [start]\n\t * @param {number} [count]\n\t */\n  draw(ctx, chartArea, start, count) {\n    const options = this.options || {};\n    const points = this.points || [];\n\n    if (points.length && options.borderWidth) {\n      ctx.save();\n\n      draw(ctx, this, start, count);\n\n      ctx.restore();\n    }\n\n    if (this.animated) {\n      // When line is animated, the control points and path are not cached.\n      this._pointsUpdated = false;\n      this._path = undefined;\n    }\n  }\n}\n","import Element from '../core/core.element.js';\nimport {drawPoint, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport type {\n  CartesianParsedData,\n  ChartArea,\n  Point,\n  PointHoverOptions,\n  PointOptions,\n} from '../types/index.js';\n\nfunction inRange(el: PointElement, pos: number, axis: 'x' | 'y', useFinalPosition?: boolean) {\n  const options = el.options;\n  const {[axis]: value} = el.getProps([axis], useFinalPosition);\n\n  return (Math.abs(pos - value) < options.radius + options.hitRadius);\n}\n\nexport type PointProps = Point\n\nexport default class PointElement extends Element<PointProps, PointOptions & PointHoverOptions> {\n\n  static id = 'point';\n\n  parsed: CartesianParsedData;\n  skip?: boolean;\n  stop?: boolean;\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderWidth: 1,\n    hitRadius: 1,\n    hoverBorderWidth: 1,\n    hoverRadius: 4,\n    pointStyle: 'circle',\n    radius: 3,\n    rotation: 0\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.parsed = undefined;\n    this.skip = undefined;\n    this.stop = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  inRange(mouseX: number, mouseY: number, useFinalPosition?: boolean) {\n    const options = this.options;\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return ((Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2)) < Math.pow(options.hitRadius + options.radius, 2));\n  }\n\n  inXRange(mouseX: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseX, 'x', useFinalPosition);\n  }\n\n  inYRange(mouseY: number, useFinalPosition?: boolean) {\n    return inRange(this, mouseY, 'y', useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition?: boolean) {\n    const {x, y} = this.getProps(['x', 'y'], useFinalPosition);\n    return {x, y};\n  }\n\n  size(options?: Partial<PointOptions & PointHoverOptions>) {\n    options = options || this.options || {};\n    let radius = options.radius || 0;\n    radius = Math.max(radius, radius && options.hoverRadius || 0);\n    const borderWidth = radius && options.borderWidth || 0;\n    return (radius + borderWidth) * 2;\n  }\n\n  draw(ctx: CanvasRenderingContext2D, area: ChartArea) {\n    const options = this.options;\n\n    if (this.skip || options.radius < 0.1 || !_isPointInArea(this, area, this.size(options) / 2)) {\n      return;\n    }\n\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n    ctx.fillStyle = options.backgroundColor;\n    drawPoint(ctx, options, this.x, this.y);\n  }\n\n  getRange() {\n    const options = this.options || {};\n    // @ts-expect-error Fallbacks should never be hit in practice\n    return options.radius + options.hitRadius;\n  }\n}\n","import Element from '../core/core.element.js';\nimport {isObject, _isBetween, _limitValue} from '../helpers/index.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {toTRBL, toTRBLCorners} from '../helpers/helpers.options.js';\n\n/** @typedef {{ x: number, y: number, base: number, horizontal: boolean, width: number, height: number }} BarProps */\n\n/**\n * Helper function to get the bounds of the bar regardless of the orientation\n * @param {BarElement} bar the bar\n * @param {boolean} [useFinalPosition]\n * @return {object} bounds of the bar\n * @private\n */\nfunction getBarBounds(bar, useFinalPosition) {\n  const {x, y, base, width, height} = /** @type {BarProps} */ (bar.getProps(['x', 'y', 'base', 'width', 'height'], useFinalPosition));\n\n  let left, right, top, bottom, half;\n\n  if (bar.horizontal) {\n    half = height / 2;\n    left = Math.min(x, base);\n    right = Math.max(x, base);\n    top = y - half;\n    bottom = y + half;\n  } else {\n    half = width / 2;\n    left = x - half;\n    right = x + half;\n    top = Math.min(y, base);\n    bottom = Math.max(y, base);\n  }\n\n  return {left, top, right, bottom};\n}\n\nfunction skipOrLimit(skip, value, min, max) {\n  return skip ? 0 : _limitValue(value, min, max);\n}\n\nfunction parseBorderWidth(bar, maxW, maxH) {\n  const value = bar.options.borderWidth;\n  const skip = bar.borderSkipped;\n  const o = toTRBL(value);\n\n  return {\n    t: skipOrLimit(skip.top, o.top, 0, maxH),\n    r: skipOrLimit(skip.right, o.right, 0, maxW),\n    b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),\n    l: skipOrLimit(skip.left, o.left, 0, maxW)\n  };\n}\n\nfunction parseBorderRadius(bar, maxW, maxH) {\n  const {enableBorderRadius} = bar.getProps(['enableBorderRadius']);\n  const value = bar.options.borderRadius;\n  const o = toTRBLCorners(value);\n  const maxR = Math.min(maxW, maxH);\n  const skip = bar.borderSkipped;\n\n  // If the value is an object, assume the user knows what they are doing\n  // and apply as directed.\n  const enableBorder = enableBorderRadius || isObject(value);\n\n  return {\n    topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),\n    topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),\n    bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),\n    bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)\n  };\n}\n\nfunction boundingRects(bar) {\n  const bounds = getBarBounds(bar);\n  const width = bounds.right - bounds.left;\n  const height = bounds.bottom - bounds.top;\n  const border = parseBorderWidth(bar, width / 2, height / 2);\n  const radius = parseBorderRadius(bar, width / 2, height / 2);\n\n  return {\n    outer: {\n      x: bounds.left,\n      y: bounds.top,\n      w: width,\n      h: height,\n      radius\n    },\n    inner: {\n      x: bounds.left + border.l,\n      y: bounds.top + border.t,\n      w: width - border.l - border.r,\n      h: height - border.t - border.b,\n      radius: {\n        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),\n        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),\n        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),\n        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r)),\n      }\n    }\n  };\n}\n\nfunction inRange(bar, x, y, useFinalPosition) {\n  const skipX = x === null;\n  const skipY = y === null;\n  const skipBoth = skipX && skipY;\n  const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);\n\n  return bounds\n\t\t&& (skipX || _isBetween(x, bounds.left, bounds.right))\n\t\t&& (skipY || _isBetween(y, bounds.top, bounds.bottom));\n}\n\nfunction hasRadius(radius) {\n  return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;\n}\n\n/**\n * Add a path of a rectangle to the current sub-path\n * @param {CanvasRenderingContext2D} ctx Context\n * @param {*} rect Bounding rect\n */\nfunction addNormalRectPath(ctx, rect) {\n  ctx.rect(rect.x, rect.y, rect.w, rect.h);\n}\n\nfunction inflateRect(rect, amount, refRect = {}) {\n  const x = rect.x !== refRect.x ? -amount : 0;\n  const y = rect.y !== refRect.y ? -amount : 0;\n  const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;\n  const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;\n  return {\n    x: rect.x + x,\n    y: rect.y + y,\n    w: rect.w + w,\n    h: rect.h + h,\n    radius: rect.radius\n  };\n}\n\nexport default class BarElement extends Element {\n\n  static id = 'bar';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    borderSkipped: 'start',\n    borderWidth: 0,\n    borderRadius: 0,\n    inflateAmount: 'auto',\n    pointStyle: undefined\n  };\n\n  /**\n   * @type {any}\n   */\n  static defaultRoutes = {\n    backgroundColor: 'backgroundColor',\n    borderColor: 'borderColor'\n  };\n\n  constructor(cfg) {\n    super();\n\n    this.options = undefined;\n    this.horizontal = undefined;\n    this.base = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.inflateAmount = undefined;\n\n    if (cfg) {\n      Object.assign(this, cfg);\n    }\n  }\n\n  draw(ctx) {\n    const {inflateAmount, options: {borderColor, backgroundColor}} = this;\n    const {inner, outer} = boundingRects(this);\n    const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;\n\n    ctx.save();\n\n    if (outer.w !== inner.w || outer.h !== inner.h) {\n      ctx.beginPath();\n      addRectPath(ctx, inflateRect(outer, inflateAmount, inner));\n      ctx.clip();\n      addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));\n      ctx.fillStyle = borderColor;\n      ctx.fill('evenodd');\n    }\n\n    ctx.beginPath();\n    addRectPath(ctx, inflateRect(inner, inflateAmount));\n    ctx.fillStyle = backgroundColor;\n    ctx.fill();\n\n    ctx.restore();\n  }\n\n  inRange(mouseX, mouseY, useFinalPosition) {\n    return inRange(this, mouseX, mouseY, useFinalPosition);\n  }\n\n  inXRange(mouseX, useFinalPosition) {\n    return inRange(this, mouseX, null, useFinalPosition);\n  }\n\n  inYRange(mouseY, useFinalPosition) {\n    return inRange(this, null, mouseY, useFinalPosition);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    const {x, y, base, horizontal} = /** @type {BarProps} */ (this.getProps(['x', 'y', 'base', 'horizontal'], useFinalPosition));\n    return {\n      x: horizontal ? (x + base) / 2 : x,\n      y: horizontal ? y : (y + base) / 2\n    };\n  }\n\n  getRange(axis) {\n    return axis === 'x' ? this.width / 2 : this.height / 2;\n  }\n}\n","import defaults from '../core/core.defaults.js';\nimport Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {addRoundedRectPath, drawPointLegend, renderText} from '../helpers/helpers.canvas.js';\nimport {\n  _isBetween,\n  callback as call,\n  clipArea,\n  getRtlAdapter,\n  overrideTextDirection,\n  restoreTextDirection,\n  toFont,\n  toPadding,\n  unclipArea,\n  valueOrDefault,\n} from '../helpers/index.js';\nimport {_alignStartEnd, _textX, _toLeftRightCenter} from '../helpers/helpers.extras.js';\nimport {toTRBLCorners} from '../helpers/helpers.options.js';\n\n/**\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n */\n\nconst getBoxSize = (labelOpts, fontSize) => {\n  let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;\n\n  if (labelOpts.usePointStyle) {\n    boxHeight = Math.min(boxHeight, fontSize);\n    boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);\n  }\n\n  return {\n    boxWidth,\n    boxHeight,\n    itemHeight: Math.max(fontSize, boxHeight)\n  };\n};\n\nconst itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;\n\nexport class Legend extends Element {\n\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this._added = false;\n\n    // Contains hit boxes for each dataset (in dataset order)\n    this.legendHitBoxes = [];\n\n    /**\n \t\t * @private\n \t\t */\n    this._hoveredItem = null;\n\n    // Are we in doughnut mode which has a different data type\n    this.doughnutMode = false;\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this.legendItems = undefined;\n    this.columnSizes = undefined;\n    this.lineWidths = undefined;\n    this.maxHeight = undefined;\n    this.maxWidth = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this._margins = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    this.maxWidth = maxWidth;\n    this.maxHeight = maxHeight;\n    this._margins = margins;\n\n    this.setDimensions();\n    this.buildLabels();\n    this.fit();\n  }\n\n  setDimensions() {\n    if (this.isHorizontal()) {\n      this.width = this.maxWidth;\n      this.left = this._margins.left;\n      this.right = this.width;\n    } else {\n      this.height = this.maxHeight;\n      this.top = this._margins.top;\n      this.bottom = this.height;\n    }\n  }\n\n  buildLabels() {\n    const labelOpts = this.options.labels || {};\n    let legendItems = call(labelOpts.generateLabels, [this.chart], this) || [];\n\n    if (labelOpts.filter) {\n      legendItems = legendItems.filter((item) => labelOpts.filter(item, this.chart.data));\n    }\n\n    if (labelOpts.sort) {\n      legendItems = legendItems.sort((a, b) => labelOpts.sort(a, b, this.chart.data));\n    }\n\n    if (this.options.reverse) {\n      legendItems.reverse();\n    }\n\n    this.legendItems = legendItems;\n  }\n\n  fit() {\n    const {options, ctx} = this;\n\n    // The legend may not be displayed for a variety of reasons including\n    // the fact that the defaults got set to `false`.\n    // When the legend is not displayed, there are no guarantees that the options\n    // are correctly formatted so we need to bail out as early as possible.\n    if (!options.display) {\n      this.width = this.height = 0;\n      return;\n    }\n\n    const labelOpts = options.labels;\n    const labelFont = toFont(labelOpts.font);\n    const fontSize = labelFont.size;\n    const titleHeight = this._computeTitleHeight();\n    const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    let width, height;\n\n    ctx.font = labelFont.string;\n\n    if (this.isHorizontal()) {\n      width = this.maxWidth; // fill all the width\n      height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;\n    } else {\n      height = this.maxHeight; // fill all the height\n      width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;\n    }\n\n    this.width = Math.min(width, options.maxWidth || this.maxWidth);\n    this.height = Math.min(height, options.maxHeight || this.maxHeight);\n  }\n\n  /**\n\t * @private\n\t */\n  _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {\n    const {ctx, maxWidth, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n    const lineWidths = this.lineWidths = [0];\n    const lineHeight = itemHeight + padding;\n    let totalHeight = titleHeight;\n\n    ctx.textAlign = 'left';\n    ctx.textBaseline = 'middle';\n\n    let row = -1;\n    let top = -lineHeight;\n    this.legendItems.forEach((legendItem, i) => {\n      const itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n      if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {\n        totalHeight += lineHeight;\n        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;\n        top += lineHeight;\n        row++;\n      }\n\n      hitboxes[i] = {left: 0, top, row, width: itemWidth, height: itemHeight};\n\n      lineWidths[lineWidths.length - 1] += itemWidth + padding;\n    });\n\n    return totalHeight;\n  }\n\n  _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {\n    const {ctx, maxHeight, options: {labels: {padding}}} = this;\n    const hitboxes = this.legendHitBoxes = [];\n    const columnSizes = this.columnSizes = [];\n    const heightLimit = maxHeight - titleHeight;\n\n    let totalWidth = padding;\n    let currentColWidth = 0;\n    let currentColHeight = 0;\n\n    let left = 0;\n    let col = 0;\n\n    this.legendItems.forEach((legendItem, i) => {\n      const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);\n\n      // If too tall, go to new column\n      if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {\n        totalWidth += currentColWidth + padding;\n        columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n        left += currentColWidth + padding;\n        col++;\n        currentColWidth = currentColHeight = 0;\n      }\n\n      // Store the hitbox width and height here. Final position will be updated in `draw`\n      hitboxes[i] = {left, top: currentColHeight, col, width: itemWidth, height: itemHeight};\n\n      // Get max width\n      currentColWidth = Math.max(currentColWidth, itemWidth);\n      currentColHeight += itemHeight + padding;\n    });\n\n    totalWidth += currentColWidth;\n    columnSizes.push({width: currentColWidth, height: currentColHeight}); // previous column size\n\n    return totalWidth;\n  }\n\n  adjustHitBoxes() {\n    if (!this.options.display) {\n      return;\n    }\n    const titleHeight = this._computeTitleHeight();\n    const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;\n    const rtlHelper = getRtlAdapter(rtl, this.left, this.width);\n    if (this.isHorizontal()) {\n      let row = 0;\n      let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n      for (const hitbox of hitboxes) {\n        if (row !== hitbox.row) {\n          row = hitbox.row;\n          left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);\n        }\n        hitbox.top += this.top + titleHeight + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);\n        left += hitbox.width + padding;\n      }\n    } else {\n      let col = 0;\n      let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n      for (const hitbox of hitboxes) {\n        if (hitbox.col !== col) {\n          col = hitbox.col;\n          top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);\n        }\n        hitbox.top = top;\n        hitbox.left += this.left + padding;\n        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);\n        top += hitbox.height + padding;\n      }\n    }\n  }\n\n  isHorizontal() {\n    return this.options.position === 'top' || this.options.position === 'bottom';\n  }\n\n  draw() {\n    if (this.options.display) {\n      const ctx = this.ctx;\n      clipArea(ctx, this);\n\n      this._draw();\n\n      unclipArea(ctx);\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _draw() {\n    const {options: opts, columnSizes, lineWidths, ctx} = this;\n    const {align, labels: labelOpts} = opts;\n    const defaultColor = defaults.color;\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const labelFont = toFont(labelOpts.font);\n    const {padding} = labelOpts;\n    const fontSize = labelFont.size;\n    const halfFontSize = fontSize / 2;\n    let cursor;\n\n    this.drawTitle();\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign('left');\n    ctx.textBaseline = 'middle';\n    ctx.lineWidth = 0.5;\n    ctx.font = labelFont.string;\n\n    const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);\n\n    // current position\n    const drawLegendBox = function(x, y, legendItem) {\n      if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) {\n        return;\n      }\n\n      // Set the ctx for the box\n      ctx.save();\n\n      const lineWidth = valueOrDefault(legendItem.lineWidth, 1);\n      ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);\n      ctx.lineCap = valueOrDefault(legendItem.lineCap, 'butt');\n      ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);\n      ctx.lineJoin = valueOrDefault(legendItem.lineJoin, 'miter');\n      ctx.lineWidth = lineWidth;\n      ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);\n\n      ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));\n\n      if (labelOpts.usePointStyle) {\n        // Recalculate x and y for drawPoint() because its expecting\n        // x and y to be center of figure (instead of top left)\n        const drawOptions = {\n          radius: boxHeight * Math.SQRT2 / 2,\n          pointStyle: legendItem.pointStyle,\n          rotation: legendItem.rotation,\n          borderWidth: lineWidth\n        };\n        const centerX = rtlHelper.xPlus(x, boxWidth / 2);\n        const centerY = y + halfFontSize;\n\n        // Draw pointStyle as legend symbol\n        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);\n      } else {\n        // Draw box as legend symbol\n        // Adjust position when boxHeight < fontSize (want it centered)\n        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);\n        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);\n        const borderRadius = toTRBLCorners(legendItem.borderRadius);\n\n        ctx.beginPath();\n\n        if (Object.values(borderRadius).some(v => v !== 0)) {\n          addRoundedRectPath(ctx, {\n            x: xBoxLeft,\n            y: yBoxTop,\n            w: boxWidth,\n            h: boxHeight,\n            radius: borderRadius,\n          });\n        } else {\n          ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);\n        }\n\n        ctx.fill();\n        if (lineWidth !== 0) {\n          ctx.stroke();\n        }\n      }\n\n      ctx.restore();\n    };\n\n    const fillText = function(x, y, legendItem) {\n      renderText(ctx, legendItem.text, x, y + (itemHeight / 2), labelFont, {\n        strikethrough: legendItem.hidden,\n        textAlign: rtlHelper.textAlign(legendItem.textAlign)\n      });\n    };\n\n    // Horizontal\n    const isHorizontal = this.isHorizontal();\n    const titleHeight = this._computeTitleHeight();\n    if (isHorizontal) {\n      cursor = {\n        x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),\n        y: this.top + padding + titleHeight,\n        line: 0\n      };\n    } else {\n      cursor = {\n        x: this.left + padding,\n        y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),\n        line: 0\n      };\n    }\n\n    overrideTextDirection(this.ctx, opts.textDirection);\n\n    const lineHeight = itemHeight + padding;\n    this.legendItems.forEach((legendItem, i) => {\n      ctx.strokeStyle = legendItem.fontColor; // for strikethrough effect\n      ctx.fillStyle = legendItem.fontColor; // render in correct colour\n\n      const textWidth = ctx.measureText(legendItem.text).width;\n      const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));\n      const width = boxWidth + halfFontSize + textWidth;\n      let x = cursor.x;\n      let y = cursor.y;\n\n      rtlHelper.setWidth(this.width);\n\n      if (isHorizontal) {\n        if (i > 0 && x + width + padding > this.right) {\n          y = cursor.y += lineHeight;\n          cursor.line++;\n          x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);\n        }\n      } else if (i > 0 && y + lineHeight > this.bottom) {\n        x = cursor.x = x + columnSizes[cursor.line].width + padding;\n        cursor.line++;\n        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);\n      }\n\n      const realX = rtlHelper.x(x);\n\n      drawLegendBox(realX, y, legendItem);\n\n      x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);\n\n      // Fill the actual label\n      fillText(rtlHelper.x(x), y, legendItem);\n\n      if (isHorizontal) {\n        cursor.x += width + padding;\n      } else if (typeof legendItem.text !== 'string') {\n        const fontLineHeight = labelFont.lineHeight;\n        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;\n      } else {\n        cursor.y += lineHeight;\n      }\n    });\n\n    restoreTextDirection(this.ctx, opts.textDirection);\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {\n    const opts = this.options;\n    const titleOpts = opts.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n\n    if (!titleOpts.display) {\n      return;\n    }\n\n    const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);\n    const ctx = this.ctx;\n    const position = titleOpts.position;\n    const halfFontSize = titleFont.size / 2;\n    const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;\n    let y;\n\n    // These defaults are used when the legend is vertical.\n    // When horizontal, they are computed below.\n    let left = this.left;\n    let maxWidth = this.width;\n\n    if (this.isHorizontal()) {\n      // Move left / right so that the title is above the legend lines\n      maxWidth = Math.max(...this.lineWidths);\n      y = this.top + topPaddingPlusHalfFontSize;\n      left = _alignStartEnd(opts.align, left, this.right - maxWidth);\n    } else {\n      // Move down so that the title is above the legend stack in every alignment\n      const maxHeight = this.columnSizes.reduce((acc, size) => Math.max(acc, size.height), 0);\n      y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());\n    }\n\n    // Now that we know the left edge of the inner legend box, compute the correct\n    // X coordinate from the title alignment\n    const x = _alignStartEnd(position, left, left + maxWidth);\n\n    // Canvas setup\n    ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));\n    ctx.textBaseline = 'middle';\n    ctx.strokeStyle = titleOpts.color;\n    ctx.fillStyle = titleOpts.color;\n    ctx.font = titleFont.string;\n\n    renderText(ctx, titleOpts.text, x, y, titleFont);\n  }\n\n  /**\n\t * @private\n\t */\n  _computeTitleHeight() {\n    const titleOpts = this.options.title;\n    const titleFont = toFont(titleOpts.font);\n    const titlePadding = toPadding(titleOpts.padding);\n    return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;\n  }\n\n  /**\n\t * @private\n\t */\n  _getLegendItemAt(x, y) {\n    let i, hitBox, lh;\n\n    if (_isBetween(x, this.left, this.right)\n      && _isBetween(y, this.top, this.bottom)) {\n      // See if we are touching one of the dataset boxes\n      lh = this.legendHitBoxes;\n      for (i = 0; i < lh.length; ++i) {\n        hitBox = lh[i];\n\n        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width)\n          && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) {\n          // Touching an element\n          return this.legendItems[i];\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t */\n  handleEvent(e) {\n    const opts = this.options;\n    if (!isListened(e.type, opts)) {\n      return;\n    }\n\n    // Chart event already has relative position in it\n    const hoveredItem = this._getLegendItemAt(e.x, e.y);\n\n    if (e.type === 'mousemove' || e.type === 'mouseout') {\n      const previous = this._hoveredItem;\n      const sameItem = itemsEqual(previous, hoveredItem);\n      if (previous && !sameItem) {\n        call(opts.onLeave, [e, previous, this], this);\n      }\n\n      this._hoveredItem = hoveredItem;\n\n      if (hoveredItem && !sameItem) {\n        call(opts.onHover, [e, hoveredItem, this], this);\n      }\n    } else if (hoveredItem) {\n      call(opts.onClick, [e, hoveredItem, this], this);\n    }\n  }\n}\n\nfunction calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {\n  const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);\n  const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);\n  return {itemWidth, itemHeight};\n}\n\nfunction calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {\n  let legendItemText = legendItem.text;\n  if (legendItemText && typeof legendItemText !== 'string') {\n    legendItemText = legendItemText.reduce((a, b) => a.length > b.length ? a : b);\n  }\n  return boxWidth + (labelFont.size / 2) + ctx.measureText(legendItemText).width;\n}\n\nfunction calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {\n  let itemHeight = _itemHeight;\n  if (typeof legendItem.text !== 'string') {\n    itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);\n  }\n  return itemHeight;\n}\n\nfunction calculateLegendItemHeight(legendItem, fontLineHeight) {\n  const labelHeight = legendItem.text ? legendItem.text.length : 0;\n  return fontLineHeight * labelHeight;\n}\n\nfunction isListened(type, opts) {\n  if ((type === 'mousemove' || type === 'mouseout') && (opts.onHover || opts.onLeave)) {\n    return true;\n  }\n  if (opts.onClick && (type === 'click' || type === 'mouseup')) {\n    return true;\n  }\n  return false;\n}\n\nexport default {\n  id: 'legend',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Legend,\n\n  start(chart, _args, options) {\n    const legend = chart.legend = new Legend({ctx: chart.ctx, options, chart});\n    layouts.configure(chart, legend, options);\n    layouts.addBox(chart, legend);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, chart.legend);\n    delete chart.legend;\n  },\n\n  // During the beforeUpdate step, the layout configuration needs to run\n  // This ensures that if the legend position changes (via an option update)\n  // the layout system respects the change. See https://github.com/chartjs/Chart.js/issues/7527\n  beforeUpdate(chart, _args, options) {\n    const legend = chart.legend;\n    layouts.configure(chart, legend, options);\n    legend.options = options;\n  },\n\n  // The labels need to be built after datasets are updated to ensure that colors\n  // and other styling are correct. See https://github.com/chartjs/Chart.js/issues/6968\n  afterUpdate(chart) {\n    const legend = chart.legend;\n    legend.buildLabels();\n    legend.adjustHitBoxes();\n  },\n\n\n  afterEvent(chart, args) {\n    if (!args.replay) {\n      chart.legend.handleEvent(args.event);\n    }\n  },\n\n  defaults: {\n    display: true,\n    position: 'top',\n    align: 'center',\n    fullSize: true,\n    reverse: false,\n    weight: 1000,\n\n    // a callback that will handle\n    onClick(e, legendItem, legend) {\n      const index = legendItem.datasetIndex;\n      const ci = legend.chart;\n      if (ci.isDatasetVisible(index)) {\n        ci.hide(index);\n        legendItem.hidden = true;\n      } else {\n        ci.show(index);\n        legendItem.hidden = false;\n      }\n    },\n\n    onHover: null,\n    onLeave: null,\n\n    labels: {\n      color: (ctx) => ctx.chart.options.color,\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels(chart) {\n        const datasets = chart.data.datasets;\n        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;\n\n        return chart._getSortedDatasetMetas().map((meta) => {\n          const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n          const borderWidth = toPadding(style.borderWidth);\n\n          return {\n            text: datasets[meta.index].label,\n            fillStyle: style.backgroundColor,\n            fontColor: color,\n            hidden: !meta.visible,\n            lineCap: style.borderCapStyle,\n            lineDash: style.borderDash,\n            lineDashOffset: style.borderDashOffset,\n            lineJoin: style.borderJoinStyle,\n            lineWidth: (borderWidth.width + borderWidth.height) / 4,\n            strokeStyle: style.borderColor,\n            pointStyle: pointStyle || style.pointStyle,\n            rotation: style.rotation,\n            textAlign: textAlign || style.textAlign,\n            borderRadius: useBorderRadius && (borderRadius || style.borderRadius),\n\n            // Below is extra data used for toggling the datasets\n            datasetIndex: meta.index\n          };\n        }, this);\n      }\n    },\n\n    title: {\n      color: (ctx) => ctx.chart.options.color,\n      display: false,\n      position: 'center',\n      text: '',\n    }\n  },\n\n  descriptors: {\n    _scriptable: (name) => !name.startsWith('on'),\n    labels: {\n      _scriptable: (name) => !['generateLabels', 'filter', 'sort'].includes(name),\n    }\n  },\n};\n","import Element from '../core/core.element.js';\nimport layouts from '../core/core.layouts.js';\nimport {PI, isArray, toPadding, toFont} from '../helpers/index.js';\nimport {_toLeftRightCenter, _alignStartEnd} from '../helpers/helpers.extras.js';\nimport {renderText} from '../helpers/helpers.canvas.js';\n\nexport class Title extends Element {\n  /**\n\t * @param {{ ctx: any; options: any; chart: any; }} config\n\t */\n  constructor(config) {\n    super();\n\n    this.chart = config.chart;\n    this.options = config.options;\n    this.ctx = config.ctx;\n    this._padding = undefined;\n    this.top = undefined;\n    this.bottom = undefined;\n    this.left = undefined;\n    this.right = undefined;\n    this.width = undefined;\n    this.height = undefined;\n    this.position = undefined;\n    this.weight = undefined;\n    this.fullSize = undefined;\n  }\n\n  update(maxWidth, maxHeight) {\n    const opts = this.options;\n\n    this.left = 0;\n    this.top = 0;\n\n    if (!opts.display) {\n      this.width = this.height = this.right = this.bottom = 0;\n      return;\n    }\n\n    this.width = this.right = maxWidth;\n    this.height = this.bottom = maxHeight;\n\n    const lineCount = isArray(opts.text) ? opts.text.length : 1;\n    this._padding = toPadding(opts.padding);\n    const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;\n\n    if (this.isHorizontal()) {\n      this.height = textSize;\n    } else {\n      this.width = textSize;\n    }\n  }\n\n  isHorizontal() {\n    const pos = this.options.position;\n    return pos === 'top' || pos === 'bottom';\n  }\n\n  _drawArgs(offset) {\n    const {top, left, bottom, right, options} = this;\n    const align = options.align;\n    let rotation = 0;\n    let maxWidth, titleX, titleY;\n\n    if (this.isHorizontal()) {\n      titleX = _alignStartEnd(align, left, right);\n      titleY = top + offset;\n      maxWidth = right - left;\n    } else {\n      if (options.position === 'left') {\n        titleX = left + offset;\n        titleY = _alignStartEnd(align, bottom, top);\n        rotation = PI * -0.5;\n      } else {\n        titleX = right - offset;\n        titleY = _alignStartEnd(align, top, bottom);\n        rotation = PI * 0.5;\n      }\n      maxWidth = bottom - top;\n    }\n    return {titleX, titleY, maxWidth, rotation};\n  }\n\n  draw() {\n    const ctx = this.ctx;\n    const opts = this.options;\n\n    if (!opts.display) {\n      return;\n    }\n\n    const fontOpts = toFont(opts.font);\n    const lineHeight = fontOpts.lineHeight;\n    const offset = lineHeight / 2 + this._padding.top;\n    const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);\n\n    renderText(ctx, opts.text, 0, 0, fontOpts, {\n      color: opts.color,\n      maxWidth,\n      rotation,\n      textAlign: _toLeftRightCenter(opts.align),\n      textBaseline: 'middle',\n      translation: [titleX, titleY],\n    });\n  }\n}\n\nfunction createTitle(chart, titleOpts) {\n  const title = new Title({\n    ctx: chart.ctx,\n    options: titleOpts,\n    chart\n  });\n\n  layouts.configure(chart, title, titleOpts);\n  layouts.addBox(chart, title);\n  chart.titleBlock = title;\n}\n\nexport default {\n  id: 'title',\n\n  /**\n\t * For tests\n\t * @private\n\t */\n  _element: Title,\n\n  start(chart, _args, options) {\n    createTitle(chart, options);\n  },\n\n  stop(chart) {\n    const titleBlock = chart.titleBlock;\n    layouts.removeBox(chart, titleBlock);\n    delete chart.titleBlock;\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = chart.titleBlock;\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'bold',\n    },\n    fullSize: true,\n    padding: 10,\n    position: 'top',\n    text: '',\n    weight: 2000         // by default greater than legend (1000) to be above\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import {Title} from './plugin.title.js';\nimport layouts from '../core/core.layouts.js';\n\nconst map = new WeakMap();\n\nexport default {\n  id: 'subtitle',\n\n  start(chart, _args, options) {\n    const title = new Title({\n      ctx: chart.ctx,\n      options,\n      chart\n    });\n\n    layouts.configure(chart, title, options);\n    layouts.addBox(chart, title);\n    map.set(chart, title);\n  },\n\n  stop(chart) {\n    layouts.removeBox(chart, map.get(chart));\n    map.delete(chart);\n  },\n\n  beforeUpdate(chart, _args, options) {\n    const title = map.get(chart);\n    layouts.configure(chart, title, options);\n    title.options = options;\n  },\n\n  defaults: {\n    align: 'center',\n    display: false,\n    font: {\n      weight: 'normal',\n    },\n    fullSize: true,\n    padding: 0,\n    position: 'top',\n    text: '',\n    weight: 1500         // by default greater than legend (1000) and smaller than title (2000)\n  },\n\n  defaultRoutes: {\n    color: 'color'\n  },\n\n  descriptors: {\n    _scriptable: true,\n    _indexable: false,\n  },\n};\n","import Animations from '../core/core.animations.js';\nimport Element from '../core/core.element.js';\nimport {addRoundedRectPath} from '../helpers/helpers.canvas.js';\nimport {each, noop, isNullOrUndef, isArray, _elementsEqual, isObject} from '../helpers/helpers.core.js';\nimport {toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\nimport {getRtlAdapter, overrideTextDirection, restoreTextDirection} from '../helpers/helpers.rtl.js';\nimport {distanceBetweenPoints, _limitValue} from '../helpers/helpers.math.js';\nimport {createContext, drawPoint} from '../helpers/index.js';\n\n/**\n * @typedef { import('../platform/platform.base.js').Chart } Chart\n * @typedef { import('../types/index.js').ChartEvent } ChartEvent\n * @typedef { import('../types/index.js').ActiveElement } ActiveElement\n * @typedef { import('../core/core.interaction.js').InteractionItem } InteractionItem\n */\n\nconst positioners = {\n  /**\n\t * Average mode places the tooltip at the average position of the elements shown\n\t */\n  average(items) {\n    if (!items.length) {\n      return false;\n    }\n\n    let i, len;\n    let x = 0;\n    let y = 0;\n    let count = 0;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const pos = el.tooltipPosition();\n        x += pos.x;\n        y += pos.y;\n        ++count;\n      }\n    }\n\n    return {\n      x: x / count,\n      y: y / count\n    };\n  },\n\n  /**\n\t * Gets the tooltip position nearest of the item nearest to the event position\n\t */\n  nearest(items, eventPosition) {\n    if (!items.length) {\n      return false;\n    }\n\n    let x = eventPosition.x;\n    let y = eventPosition.y;\n    let minDistance = Number.POSITIVE_INFINITY;\n    let i, len, nearestElement;\n\n    for (i = 0, len = items.length; i < len; ++i) {\n      const el = items[i].element;\n      if (el && el.hasValue()) {\n        const center = el.getCenterPoint();\n        const d = distanceBetweenPoints(eventPosition, center);\n\n        if (d < minDistance) {\n          minDistance = d;\n          nearestElement = el;\n        }\n      }\n    }\n\n    if (nearestElement) {\n      const tp = nearestElement.tooltipPosition();\n      x = tp.x;\n      y = tp.y;\n    }\n\n    return {\n      x,\n      y\n    };\n  }\n};\n\n// Helper to push or concat based on if the 2nd parameter is an array or not\nfunction pushOrConcat(base, toPush) {\n  if (toPush) {\n    if (isArray(toPush)) {\n      // base = base.concat(toPush);\n      Array.prototype.push.apply(base, toPush);\n    } else {\n      base.push(toPush);\n    }\n  }\n\n  return base;\n}\n\n/**\n * Returns array of strings split by newline\n * @param {*} str - The value to split by newline.\n * @returns {string|string[]} value if newline present - Returned from String split() method\n * @function\n */\nfunction splitNewlines(str) {\n  if ((typeof str === 'string' || str instanceof String) && str.indexOf('\\n') > -1) {\n    return str.split('\\n');\n  }\n  return str;\n}\n\n\n/**\n * Private helper to create a tooltip item model\n * @param {Chart} chart\n * @param {ActiveElement} item - {element, index, datasetIndex} to create the tooltip item for\n * @return new tooltip item\n */\nfunction createTooltipItem(chart, item) {\n  const {element, datasetIndex, index} = item;\n  const controller = chart.getDatasetMeta(datasetIndex).controller;\n  const {label, value} = controller.getLabelAndValue(index);\n\n  return {\n    chart,\n    label,\n    parsed: controller.getParsed(index),\n    raw: chart.data.datasets[datasetIndex].data[index],\n    formattedValue: value,\n    dataset: controller.getDataset(),\n    dataIndex: index,\n    datasetIndex,\n    element\n  };\n}\n\n/**\n * Get the size of the tooltip\n */\nfunction getTooltipSize(tooltip, options) {\n  const ctx = tooltip.chart.ctx;\n  const {body, footer, title} = tooltip;\n  const {boxWidth, boxHeight} = options;\n  const bodyFont = toFont(options.bodyFont);\n  const titleFont = toFont(options.titleFont);\n  const footerFont = toFont(options.footerFont);\n  const titleLineCount = title.length;\n  const footerLineCount = footer.length;\n  const bodyLineItemCount = body.length;\n\n  const padding = toPadding(options.padding);\n  let height = padding.height;\n  let width = 0;\n\n  // Count of all lines in the body\n  let combinedBodyLength = body.reduce((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length, 0);\n  combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;\n\n  if (titleLineCount) {\n    height += titleLineCount * titleFont.lineHeight\n\t\t\t+ (titleLineCount - 1) * options.titleSpacing\n\t\t\t+ options.titleMarginBottom;\n  }\n  if (combinedBodyLength) {\n    // Body lines may include some extra height depending on boxHeight\n    const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;\n    height += bodyLineItemCount * bodyLineHeight\n\t\t\t+ (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight\n\t\t\t+ (combinedBodyLength - 1) * options.bodySpacing;\n  }\n  if (footerLineCount) {\n    height += options.footerMarginTop\n\t\t\t+ footerLineCount * footerFont.lineHeight\n\t\t\t+ (footerLineCount - 1) * options.footerSpacing;\n  }\n\n  // Title width\n  let widthPadding = 0;\n  const maxLineWidth = function(line) {\n    width = Math.max(width, ctx.measureText(line).width + widthPadding);\n  };\n\n  ctx.save();\n\n  ctx.font = titleFont.string;\n  each(tooltip.title, maxLineWidth);\n\n  // Body width\n  ctx.font = bodyFont.string;\n  each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);\n\n  // Body lines may include some extra width due to the color box\n  widthPadding = options.displayColors ? (boxWidth + 2 + options.boxPadding) : 0;\n  each(body, (bodyItem) => {\n    each(bodyItem.before, maxLineWidth);\n    each(bodyItem.lines, maxLineWidth);\n    each(bodyItem.after, maxLineWidth);\n  });\n\n  // Reset back to 0\n  widthPadding = 0;\n\n  // Footer width\n  ctx.font = footerFont.string;\n  each(tooltip.footer, maxLineWidth);\n\n  ctx.restore();\n\n  // Add padding\n  width += padding.width;\n\n  return {width, height};\n}\n\nfunction determineYAlign(chart, size) {\n  const {y, height} = size;\n\n  if (y < height / 2) {\n    return 'top';\n  } else if (y > (chart.height - height / 2)) {\n    return 'bottom';\n  }\n  return 'center';\n}\n\nfunction doesNotFitWithAlign(xAlign, chart, options, size) {\n  const {x, width} = size;\n  const caret = options.caretSize + options.caretPadding;\n  if (xAlign === 'left' && x + width + caret > chart.width) {\n    return true;\n  }\n\n  if (xAlign === 'right' && x - width - caret < 0) {\n    return true;\n  }\n}\n\nfunction determineXAlign(chart, options, size, yAlign) {\n  const {x, width} = size;\n  const {width: chartWidth, chartArea: {left, right}} = chart;\n  let xAlign = 'center';\n\n  if (yAlign === 'center') {\n    xAlign = x <= (left + right) / 2 ? 'left' : 'right';\n  } else if (x <= width / 2) {\n    xAlign = 'left';\n  } else if (x >= chartWidth - width / 2) {\n    xAlign = 'right';\n  }\n\n  if (doesNotFitWithAlign(xAlign, chart, options, size)) {\n    xAlign = 'center';\n  }\n\n  return xAlign;\n}\n\n/**\n * Helper to get the alignment of a tooltip given the size\n */\nfunction determineAlignment(chart, options, size) {\n  const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);\n\n  return {\n    xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),\n    yAlign\n  };\n}\n\nfunction alignX(size, xAlign) {\n  let {x, width} = size;\n  if (xAlign === 'right') {\n    x -= width;\n  } else if (xAlign === 'center') {\n    x -= (width / 2);\n  }\n  return x;\n}\n\nfunction alignY(size, yAlign, paddingAndSize) {\n  // eslint-disable-next-line prefer-const\n  let {y, height} = size;\n  if (yAlign === 'top') {\n    y += paddingAndSize;\n  } else if (yAlign === 'bottom') {\n    y -= height + paddingAndSize;\n  } else {\n    y -= (height / 2);\n  }\n  return y;\n}\n\n/**\n * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment\n */\nfunction getBackgroundPoint(options, size, alignment, chart) {\n  const {caretSize, caretPadding, cornerRadius} = options;\n  const {xAlign, yAlign} = alignment;\n  const paddingAndSize = caretSize + caretPadding;\n  const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n\n  let x = alignX(size, xAlign);\n  const y = alignY(size, yAlign, paddingAndSize);\n\n  if (yAlign === 'center') {\n    if (xAlign === 'left') {\n      x += paddingAndSize;\n    } else if (xAlign === 'right') {\n      x -= paddingAndSize;\n    }\n  } else if (xAlign === 'left') {\n    x -= Math.max(topLeft, bottomLeft) + caretSize;\n  } else if (xAlign === 'right') {\n    x += Math.max(topRight, bottomRight) + caretSize;\n  }\n\n  return {\n    x: _limitValue(x, 0, chart.width - size.width),\n    y: _limitValue(y, 0, chart.height - size.height)\n  };\n}\n\nfunction getAlignedX(tooltip, align, options) {\n  const padding = toPadding(options.padding);\n\n  return align === 'center'\n    ? tooltip.x + tooltip.width / 2\n    : align === 'right'\n      ? tooltip.x + tooltip.width - padding.right\n      : tooltip.x + padding.left;\n}\n\n/**\n * Helper to build before and after body lines\n */\nfunction getBeforeAfterBodyLines(callback) {\n  return pushOrConcat([], splitNewlines(callback));\n}\n\nfunction createTooltipContext(parent, tooltip, tooltipItems) {\n  return createContext(parent, {\n    tooltip,\n    tooltipItems,\n    type: 'tooltip'\n  });\n}\n\nfunction overrideCallbacks(callbacks, context) {\n  const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;\n  return override ? callbacks.override(override) : callbacks;\n}\n\nconst defaultCallbacks = {\n  // Args are: (tooltipItems, data)\n  beforeTitle: noop,\n  title(tooltipItems) {\n    if (tooltipItems.length > 0) {\n      const item = tooltipItems[0];\n      const labels = item.chart.data.labels;\n      const labelCount = labels ? labels.length : 0;\n\n      if (this && this.options && this.options.mode === 'dataset') {\n        return item.dataset.label || '';\n      } else if (item.label) {\n        return item.label;\n      } else if (labelCount > 0 && item.dataIndex < labelCount) {\n        return labels[item.dataIndex];\n      }\n    }\n\n    return '';\n  },\n  afterTitle: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeBody: noop,\n\n  // Args are: (tooltipItem, data)\n  beforeLabel: noop,\n  label(tooltipItem) {\n    if (this && this.options && this.options.mode === 'dataset') {\n      return tooltipItem.label + ': ' + tooltipItem.formattedValue || tooltipItem.formattedValue;\n    }\n\n    let label = tooltipItem.dataset.label || '';\n\n    if (label) {\n      label += ': ';\n    }\n    const value = tooltipItem.formattedValue;\n    if (!isNullOrUndef(value)) {\n      label += value;\n    }\n    return label;\n  },\n  labelColor(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      borderColor: options.borderColor,\n      backgroundColor: options.backgroundColor,\n      borderWidth: options.borderWidth,\n      borderDash: options.borderDash,\n      borderDashOffset: options.borderDashOffset,\n      borderRadius: 0,\n    };\n  },\n  labelTextColor() {\n    return this.options.bodyColor;\n  },\n  labelPointStyle(tooltipItem) {\n    const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);\n    const options = meta.controller.getStyle(tooltipItem.dataIndex);\n    return {\n      pointStyle: options.pointStyle,\n      rotation: options.rotation,\n    };\n  },\n  afterLabel: noop,\n\n  // Args are: (tooltipItems, data)\n  afterBody: noop,\n\n  // Args are: (tooltipItems, data)\n  beforeFooter: noop,\n  footer: noop,\n  afterFooter: noop\n};\n\n/**\n * Invoke callback from object with context and arguments.\n * If callback returns `undefined`, then will be invoked default callback.\n * @param {Record<keyof typeof defaultCallbacks, Function>} callbacks\n * @param {keyof typeof defaultCallbacks} name\n * @param {*} ctx\n * @param {*} arg\n * @returns {any}\n */\nfunction invokeCallbackWithFallback(callbacks, name, ctx, arg) {\n  const result = callbacks[name].call(ctx, arg);\n\n  if (typeof result === 'undefined') {\n    return defaultCallbacks[name].call(ctx, arg);\n  }\n\n  return result;\n}\n\nexport class Tooltip extends Element {\n\n  /**\n   * @namespace Chart.Tooltip.positioners\n   */\n  static positioners = positioners;\n\n  constructor(config) {\n    super();\n\n    this.opacity = 0;\n    this._active = [];\n    this._eventPosition = undefined;\n    this._size = undefined;\n    this._cachedAnimations = undefined;\n    this._tooltipItems = [];\n    this.$animations = undefined;\n    this.$context = undefined;\n    this.chart = config.chart;\n    this.options = config.options;\n    this.dataPoints = undefined;\n    this.title = undefined;\n    this.beforeBody = undefined;\n    this.body = undefined;\n    this.afterBody = undefined;\n    this.footer = undefined;\n    this.xAlign = undefined;\n    this.yAlign = undefined;\n    this.x = undefined;\n    this.y = undefined;\n    this.height = undefined;\n    this.width = undefined;\n    this.caretX = undefined;\n    this.caretY = undefined;\n    // TODO: V4, make this private, rename to `_labelStyles`, and combine with `labelPointStyles`\n    // and `labelTextColors` to create a single variable\n    this.labelColors = undefined;\n    this.labelPointStyles = undefined;\n    this.labelTextColors = undefined;\n  }\n\n  initialize(options) {\n    this.options = options;\n    this._cachedAnimations = undefined;\n    this.$context = undefined;\n  }\n\n  /**\n\t * @private\n\t */\n  _resolveAnimations() {\n    const cached = this._cachedAnimations;\n\n    if (cached) {\n      return cached;\n    }\n\n    const chart = this.chart;\n    const options = this.options.setContext(this.getContext());\n    const opts = options.enabled && chart.options.animation && options.animations;\n    const animations = new Animations(this.chart, opts);\n    if (opts._cacheable) {\n      this._cachedAnimations = Object.freeze(animations);\n    }\n\n    return animations;\n  }\n\n  /**\n\t * @protected\n\t */\n  getContext() {\n    return this.$context ||\n\t\t\t(this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));\n  }\n\n  getTitle(context, options) {\n    const {callbacks} = options;\n\n    const beforeTitle = invokeCallbackWithFallback(callbacks, 'beforeTitle', this, context);\n    const title = invokeCallbackWithFallback(callbacks, 'title', this, context);\n    const afterTitle = invokeCallbackWithFallback(callbacks, 'afterTitle', this, context);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeTitle));\n    lines = pushOrConcat(lines, splitNewlines(title));\n    lines = pushOrConcat(lines, splitNewlines(afterTitle));\n\n    return lines;\n  }\n\n  getBeforeBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'beforeBody', this, tooltipItems)\n    );\n  }\n\n  getBody(tooltipItems, options) {\n    const {callbacks} = options;\n    const bodyItems = [];\n\n    each(tooltipItems, (context) => {\n      const bodyItem = {\n        before: [],\n        lines: [],\n        after: []\n      };\n      const scoped = overrideCallbacks(callbacks, context);\n      pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, 'beforeLabel', this, context)));\n      pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, 'label', this, context));\n      pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, 'afterLabel', this, context)));\n\n      bodyItems.push(bodyItem);\n    });\n\n    return bodyItems;\n  }\n\n  getAfterBody(tooltipItems, options) {\n    return getBeforeAfterBodyLines(\n      invokeCallbackWithFallback(options.callbacks, 'afterBody', this, tooltipItems)\n    );\n  }\n\n  // Get the footer and beforeFooter and afterFooter lines\n  getFooter(tooltipItems, options) {\n    const {callbacks} = options;\n\n    const beforeFooter = invokeCallbackWithFallback(callbacks, 'beforeFooter', this, tooltipItems);\n    const footer = invokeCallbackWithFallback(callbacks, 'footer', this, tooltipItems);\n    const afterFooter = invokeCallbackWithFallback(callbacks, 'afterFooter', this, tooltipItems);\n\n    let lines = [];\n    lines = pushOrConcat(lines, splitNewlines(beforeFooter));\n    lines = pushOrConcat(lines, splitNewlines(footer));\n    lines = pushOrConcat(lines, splitNewlines(afterFooter));\n\n    return lines;\n  }\n\n  /**\n\t * @private\n\t */\n  _createItems(options) {\n    const active = this._active;\n    const data = this.chart.data;\n    const labelColors = [];\n    const labelPointStyles = [];\n    const labelTextColors = [];\n    let tooltipItems = [];\n    let i, len;\n\n    for (i = 0, len = active.length; i < len; ++i) {\n      tooltipItems.push(createTooltipItem(this.chart, active[i]));\n    }\n\n    // If the user provided a filter function, use it to modify the tooltip items\n    if (options.filter) {\n      tooltipItems = tooltipItems.filter((element, index, array) => options.filter(element, index, array, data));\n    }\n\n    // If the user provided a sorting function, use it to modify the tooltip items\n    if (options.itemSort) {\n      tooltipItems = tooltipItems.sort((a, b) => options.itemSort(a, b, data));\n    }\n\n    // Determine colors for boxes\n    each(tooltipItems, (context) => {\n      const scoped = overrideCallbacks(options.callbacks, context);\n      labelColors.push(invokeCallbackWithFallback(scoped, 'labelColor', this, context));\n      labelPointStyles.push(invokeCallbackWithFallback(scoped, 'labelPointStyle', this, context));\n      labelTextColors.push(invokeCallbackWithFallback(scoped, 'labelTextColor', this, context));\n    });\n\n    this.labelColors = labelColors;\n    this.labelPointStyles = labelPointStyles;\n    this.labelTextColors = labelTextColors;\n    this.dataPoints = tooltipItems;\n    return tooltipItems;\n  }\n\n  update(changed, replay) {\n    const options = this.options.setContext(this.getContext());\n    const active = this._active;\n    let properties;\n    let tooltipItems = [];\n\n    if (!active.length) {\n      if (this.opacity !== 0) {\n        properties = {\n          opacity: 0\n        };\n      }\n    } else {\n      const position = positioners[options.position].call(this, active, this._eventPosition);\n      tooltipItems = this._createItems(options);\n\n      this.title = this.getTitle(tooltipItems, options);\n      this.beforeBody = this.getBeforeBody(tooltipItems, options);\n      this.body = this.getBody(tooltipItems, options);\n      this.afterBody = this.getAfterBody(tooltipItems, options);\n      this.footer = this.getFooter(tooltipItems, options);\n\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, size);\n      const alignment = determineAlignment(this.chart, options, positionAndSize);\n      const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);\n\n      this.xAlign = alignment.xAlign;\n      this.yAlign = alignment.yAlign;\n\n      properties = {\n        opacity: 1,\n        x: backgroundPoint.x,\n        y: backgroundPoint.y,\n        width: size.width,\n        height: size.height,\n        caretX: position.x,\n        caretY: position.y\n      };\n    }\n\n    this._tooltipItems = tooltipItems;\n    this.$context = undefined;\n\n    if (properties) {\n      this._resolveAnimations().update(this, properties);\n    }\n\n    if (changed && options.external) {\n      options.external.call(this, {chart: this.chart, tooltip: this, replay});\n    }\n  }\n\n  drawCaret(tooltipPoint, ctx, size, options) {\n    const caretPosition = this.getCaretPosition(tooltipPoint, size, options);\n\n    ctx.lineTo(caretPosition.x1, caretPosition.y1);\n    ctx.lineTo(caretPosition.x2, caretPosition.y2);\n    ctx.lineTo(caretPosition.x3, caretPosition.y3);\n  }\n\n  getCaretPosition(tooltipPoint, size, options) {\n    const {xAlign, yAlign} = this;\n    const {caretSize, cornerRadius} = options;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);\n    const {x: ptX, y: ptY} = tooltipPoint;\n    const {width, height} = size;\n    let x1, x2, x3, y1, y2, y3;\n\n    if (yAlign === 'center') {\n      y2 = ptY + (height / 2);\n\n      if (xAlign === 'left') {\n        x1 = ptX;\n        x2 = x1 - caretSize;\n\n        // Left draws bottom -> top, this y1 is on the bottom\n        y1 = y2 + caretSize;\n        y3 = y2 - caretSize;\n      } else {\n        x1 = ptX + width;\n        x2 = x1 + caretSize;\n\n        // Right draws top -> bottom, thus y1 is on the top\n        y1 = y2 - caretSize;\n        y3 = y2 + caretSize;\n      }\n\n      x3 = x1;\n    } else {\n      if (xAlign === 'left') {\n        x2 = ptX + Math.max(topLeft, bottomLeft) + (caretSize);\n      } else if (xAlign === 'right') {\n        x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize;\n      } else {\n        x2 = this.caretX;\n      }\n\n      if (yAlign === 'top') {\n        y1 = ptY;\n        y2 = y1 - caretSize;\n\n        // Top draws left -> right, thus x1 is on the left\n        x1 = x2 - caretSize;\n        x3 = x2 + caretSize;\n      } else {\n        y1 = ptY + height;\n        y2 = y1 + caretSize;\n\n        // Bottom draws right -> left, thus x1 is on the right\n        x1 = x2 + caretSize;\n        x3 = x2 - caretSize;\n      }\n      y3 = y1;\n    }\n    return {x1, x2, x3, y1, y2, y3};\n  }\n\n  drawTitle(pt, ctx, options) {\n    const title = this.title;\n    const length = title.length;\n    let titleFont, titleSpacing, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.titleAlign, options);\n\n      ctx.textAlign = rtlHelper.textAlign(options.titleAlign);\n      ctx.textBaseline = 'middle';\n\n      titleFont = toFont(options.titleFont);\n      titleSpacing = options.titleSpacing;\n\n      ctx.fillStyle = options.titleColor;\n      ctx.font = titleFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);\n        pt.y += titleFont.lineHeight + titleSpacing; // Line Height and spacing\n\n        if (i + 1 === length) {\n          pt.y += options.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing\n        }\n      }\n    }\n  }\n\n  /**\n\t * @private\n\t */\n  _drawColorBox(ctx, pt, i, rtlHelper, options) {\n    const labelColor = this.labelColors[i];\n    const labelPointStyle = this.labelPointStyles[i];\n    const {boxHeight, boxWidth} = options;\n    const bodyFont = toFont(options.bodyFont);\n    const colorX = getAlignedX(this, 'left', options);\n    const rtlColorX = rtlHelper.x(colorX);\n    const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;\n    const colorY = pt.y + yOffSet;\n\n    if (options.usePointStyle) {\n      const drawOptions = {\n        radius: Math.min(boxWidth, boxHeight) / 2, // fit the circle in the box\n        pointStyle: labelPointStyle.pointStyle,\n        rotation: labelPointStyle.rotation,\n        borderWidth: 1\n      };\n      // Recalculate x and y for drawPoint() because its expecting\n      // x and y to be center of figure (instead of top left)\n      const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;\n      const centerY = colorY + boxHeight / 2;\n\n      // Fill the point with white so that colours merge nicely if the opacity is < 1\n      ctx.strokeStyle = options.multiKeyBackground;\n      ctx.fillStyle = options.multiKeyBackground;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n\n      // Draw the point\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.fillStyle = labelColor.backgroundColor;\n      drawPoint(ctx, drawOptions, centerX, centerY);\n    } else {\n      // Border\n      ctx.lineWidth = isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : (labelColor.borderWidth || 1); // TODO, v4 remove fallback\n      ctx.strokeStyle = labelColor.borderColor;\n      ctx.setLineDash(labelColor.borderDash || []);\n      ctx.lineDashOffset = labelColor.borderDashOffset || 0;\n\n      // Fill a white rect so that colours merge nicely if the opacity is < 1\n      const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);\n      const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);\n      const borderRadius = toTRBLCorners(labelColor.borderRadius);\n\n      if (Object.values(borderRadius).some(v => v !== 0)) {\n        ctx.beginPath();\n        ctx.fillStyle = options.multiKeyBackground;\n        addRoundedRectPath(ctx, {\n          x: outerX,\n          y: colorY,\n          w: boxWidth,\n          h: boxHeight,\n          radius: borderRadius,\n        });\n        ctx.fill();\n        ctx.stroke();\n\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.beginPath();\n        addRoundedRectPath(ctx, {\n          x: innerX,\n          y: colorY + 1,\n          w: boxWidth - 2,\n          h: boxHeight - 2,\n          radius: borderRadius,\n        });\n        ctx.fill();\n      } else {\n        // Normal rect\n        ctx.fillStyle = options.multiKeyBackground;\n        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);\n        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);\n        // Inner square\n        ctx.fillStyle = labelColor.backgroundColor;\n        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);\n      }\n    }\n\n    // restore fillStyle\n    ctx.fillStyle = this.labelTextColors[i];\n  }\n\n  drawBody(pt, ctx, options) {\n    const {body} = this;\n    const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;\n    const bodyFont = toFont(options.bodyFont);\n    let bodyLineHeight = bodyFont.lineHeight;\n    let xLinePadding = 0;\n\n    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n    const fillLineOfText = function(line) {\n      ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);\n      pt.y += bodyLineHeight + bodySpacing;\n    };\n\n    const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);\n    let bodyItem, textColor, lines, i, j, ilen, jlen;\n\n    ctx.textAlign = bodyAlign;\n    ctx.textBaseline = 'middle';\n    ctx.font = bodyFont.string;\n\n    pt.x = getAlignedX(this, bodyAlignForCalculation, options);\n\n    // Before body lines\n    ctx.fillStyle = options.bodyColor;\n    each(this.beforeBody, fillLineOfText);\n\n    xLinePadding = displayColors && bodyAlignForCalculation !== 'right'\n      ? bodyAlign === 'center' ? (boxWidth / 2 + boxPadding) : (boxWidth + 2 + boxPadding)\n      : 0;\n\n    // Draw body lines now\n    for (i = 0, ilen = body.length; i < ilen; ++i) {\n      bodyItem = body[i];\n      textColor = this.labelTextColors[i];\n\n      ctx.fillStyle = textColor;\n      each(bodyItem.before, fillLineOfText);\n\n      lines = bodyItem.lines;\n      // Draw Legend-like boxes if needed\n      if (displayColors && lines.length) {\n        this._drawColorBox(ctx, pt, i, rtlHelper, options);\n        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);\n      }\n\n      for (j = 0, jlen = lines.length; j < jlen; ++j) {\n        fillLineOfText(lines[j]);\n        // Reset for any lines that don't include colorbox\n        bodyLineHeight = bodyFont.lineHeight;\n      }\n\n      each(bodyItem.after, fillLineOfText);\n    }\n\n    // Reset back to 0 for after body\n    xLinePadding = 0;\n    bodyLineHeight = bodyFont.lineHeight;\n\n    // After body lines\n    each(this.afterBody, fillLineOfText);\n    pt.y -= bodySpacing; // Remove last body spacing\n  }\n\n  drawFooter(pt, ctx, options) {\n    const footer = this.footer;\n    const length = footer.length;\n    let footerFont, i;\n\n    if (length) {\n      const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);\n\n      pt.x = getAlignedX(this, options.footerAlign, options);\n      pt.y += options.footerMarginTop;\n\n      ctx.textAlign = rtlHelper.textAlign(options.footerAlign);\n      ctx.textBaseline = 'middle';\n\n      footerFont = toFont(options.footerFont);\n\n      ctx.fillStyle = options.footerColor;\n      ctx.font = footerFont.string;\n\n      for (i = 0; i < length; ++i) {\n        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);\n        pt.y += footerFont.lineHeight + options.footerSpacing;\n      }\n    }\n  }\n\n  drawBackground(pt, ctx, tooltipSize, options) {\n    const {xAlign, yAlign} = this;\n    const {x, y} = pt;\n    const {width, height} = tooltipSize;\n    const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);\n\n    ctx.fillStyle = options.backgroundColor;\n    ctx.strokeStyle = options.borderColor;\n    ctx.lineWidth = options.borderWidth;\n\n    ctx.beginPath();\n    ctx.moveTo(x + topLeft, y);\n    if (yAlign === 'top') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width - topRight, y);\n    ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);\n    if (yAlign === 'center' && xAlign === 'right') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + width, y + height - bottomRight);\n    ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);\n    if (yAlign === 'bottom') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x + bottomLeft, y + height);\n    ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);\n    if (yAlign === 'center' && xAlign === 'left') {\n      this.drawCaret(pt, ctx, tooltipSize, options);\n    }\n    ctx.lineTo(x, y + topLeft);\n    ctx.quadraticCurveTo(x, y, x + topLeft, y);\n    ctx.closePath();\n\n    ctx.fill();\n\n    if (options.borderWidth > 0) {\n      ctx.stroke();\n    }\n  }\n\n  /**\n\t * Update x/y animation targets when _active elements are animating too\n\t * @private\n\t */\n  _updateAnimationTarget(options) {\n    const chart = this.chart;\n    const anims = this.$animations;\n    const animX = anims && anims.x;\n    const animY = anims && anims.y;\n    if (animX || animY) {\n      const position = positioners[options.position].call(this, this._active, this._eventPosition);\n      if (!position) {\n        return;\n      }\n      const size = this._size = getTooltipSize(this, options);\n      const positionAndSize = Object.assign({}, position, this._size);\n      const alignment = determineAlignment(chart, options, positionAndSize);\n      const point = getBackgroundPoint(options, positionAndSize, alignment, chart);\n      if (animX._to !== point.x || animY._to !== point.y) {\n        this.xAlign = alignment.xAlign;\n        this.yAlign = alignment.yAlign;\n        this.width = size.width;\n        this.height = size.height;\n        this.caretX = position.x;\n        this.caretY = position.y;\n        this._resolveAnimations().update(this, point);\n      }\n    }\n  }\n\n  /**\n   * Determine if the tooltip will draw anything\n   * @returns {boolean} True if the tooltip will render\n   */\n  _willRender() {\n    return !!this.opacity;\n  }\n\n  draw(ctx) {\n    const options = this.options.setContext(this.getContext());\n    let opacity = this.opacity;\n\n    if (!opacity) {\n      return;\n    }\n\n    this._updateAnimationTarget(options);\n\n    const tooltipSize = {\n      width: this.width,\n      height: this.height\n    };\n    const pt = {\n      x: this.x,\n      y: this.y\n    };\n\n    // IE11/Edge does not like very small opacities, so snap to 0\n    opacity = Math.abs(opacity) < 1e-3 ? 0 : opacity;\n\n    const padding = toPadding(options.padding);\n\n    // Truthy/falsey value for empty tooltip\n    const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;\n\n    if (options.enabled && hasTooltipContent) {\n      ctx.save();\n      ctx.globalAlpha = opacity;\n\n      // Draw Background\n      this.drawBackground(pt, ctx, tooltipSize, options);\n\n      overrideTextDirection(ctx, options.textDirection);\n\n      pt.y += padding.top;\n\n      // Titles\n      this.drawTitle(pt, ctx, options);\n\n      // Body\n      this.drawBody(pt, ctx, options);\n\n      // Footer\n      this.drawFooter(pt, ctx, options);\n\n      restoreTextDirection(ctx, options.textDirection);\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * Get active elements in the tooltip\n\t * @returns {Array} Array of elements that are active in the tooltip\n\t */\n  getActiveElements() {\n    return this._active || [];\n  }\n\n  /**\n\t * Set active elements in the tooltip\n\t * @param {array} activeElements Array of active datasetIndex/index pairs.\n\t * @param {object} eventPosition Synthetic event position used in positioning\n\t */\n  setActiveElements(activeElements, eventPosition) {\n    const lastActive = this._active;\n    const active = activeElements.map(({datasetIndex, index}) => {\n      const meta = this.chart.getDatasetMeta(datasetIndex);\n\n      if (!meta) {\n        throw new Error('Cannot find a dataset at index ' + datasetIndex);\n      }\n\n      return {\n        datasetIndex,\n        element: meta.data[index],\n        index,\n      };\n    });\n    const changed = !_elementsEqual(lastActive, active);\n    const positionChanged = this._positionChanged(active, eventPosition);\n\n    if (changed || positionChanged) {\n      this._active = active;\n      this._eventPosition = eventPosition;\n      this._ignoreReplayEvents = true;\n      this.update(true);\n    }\n  }\n\n  /**\n\t * Handle an event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {boolean} true if the tooltip changed\n\t */\n  handleEvent(e, replay, inChartArea = true) {\n    if (replay && this._ignoreReplayEvents) {\n      return false;\n    }\n    this._ignoreReplayEvents = false;\n\n    const options = this.options;\n    const lastActive = this._active || [];\n    const active = this._getActiveElements(e, lastActive, replay, inChartArea);\n\n    // When there are multiple items shown, but the tooltip position is nearest mode\n    // an update may need to be made because our position may have changed even though\n    // the items are the same as before.\n    const positionChanged = this._positionChanged(active, e);\n\n    // Remember Last Actives\n    const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;\n\n    // Only handle target event on tooltip change\n    if (changed) {\n      this._active = active;\n\n      if (options.enabled || options.external) {\n        this._eventPosition = {\n          x: e.x,\n          y: e.y\n        };\n\n        this.update(true, replay);\n      }\n    }\n\n    return changed;\n  }\n\n  /**\n\t * Helper for determining the active elements for event\n\t * @param {ChartEvent} e - The event to handle\n\t * @param {InteractionItem[]} lastActive - Previously active elements\n\t * @param {boolean} [replay] - This is a replayed event (from update)\n\t * @param {boolean} [inChartArea] - The event is inside chartArea\n\t * @returns {InteractionItem[]} - Active elements\n\t * @private\n\t */\n  _getActiveElements(e, lastActive, replay, inChartArea) {\n    const options = this.options;\n\n    if (e.type === 'mouseout') {\n      return [];\n    }\n\n    if (!inChartArea) {\n      // Let user control the active elements outside chartArea. Eg. using Legend.\n      // But make sure that active elements are still valid.\n      return lastActive.filter(i =>\n        this.chart.data.datasets[i.datasetIndex] &&\n        this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== undefined\n      );\n    }\n\n    // Find Active Elements for tooltips\n    const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);\n\n    if (options.reverse) {\n      active.reverse();\n    }\n\n    return active;\n  }\n\n  /**\n\t * Determine if the active elements + event combination changes the\n\t * tooltip position\n\t * @param {array} active - Active elements\n\t * @param {ChartEvent} e - Event that triggered the position change\n\t * @returns {boolean} True if the position has changed\n\t */\n  _positionChanged(active, e) {\n    const {caretX, caretY, options} = this;\n    const position = positioners[options.position].call(this, active, e);\n    return position !== false && (caretX !== position.x || caretY !== position.y);\n  }\n}\n\nexport default {\n  id: 'tooltip',\n  _element: Tooltip,\n  positioners,\n\n  afterInit(chart, _args, options) {\n    if (options) {\n      chart.tooltip = new Tooltip({chart, options});\n    }\n  },\n\n  beforeUpdate(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  reset(chart, _args, options) {\n    if (chart.tooltip) {\n      chart.tooltip.initialize(options);\n    }\n  },\n\n  afterDraw(chart) {\n    const tooltip = chart.tooltip;\n\n    if (tooltip && tooltip._willRender()) {\n      const args = {\n        tooltip\n      };\n\n      if (chart.notifyPlugins('beforeTooltipDraw', {...args, cancelable: true}) === false) {\n        return;\n      }\n\n      tooltip.draw(chart.ctx);\n\n      chart.notifyPlugins('afterTooltipDraw', args);\n    }\n  },\n\n  afterEvent(chart, args) {\n    if (chart.tooltip) {\n      // If the event is replayed from `update`, we should evaluate with the final positions.\n      const useFinalPosition = args.replay;\n      if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) {\n        // notify chart about the change, so it will render\n        args.changed = true;\n      }\n    }\n  },\n\n  defaults: {\n    enabled: true,\n    external: null,\n    position: 'average',\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    titleColor: '#fff',\n    titleFont: {\n      weight: 'bold',\n    },\n    titleSpacing: 2,\n    titleMarginBottom: 6,\n    titleAlign: 'left',\n    bodyColor: '#fff',\n    bodySpacing: 2,\n    bodyFont: {\n    },\n    bodyAlign: 'left',\n    footerColor: '#fff',\n    footerSpacing: 2,\n    footerMarginTop: 6,\n    footerFont: {\n      weight: 'bold',\n    },\n    footerAlign: 'left',\n    padding: 6,\n    caretPadding: 2,\n    caretSize: 5,\n    cornerRadius: 6,\n    boxHeight: (ctx, opts) => opts.bodyFont.size,\n    boxWidth: (ctx, opts) => opts.bodyFont.size,\n    multiKeyBackground: '#fff',\n    displayColors: true,\n    boxPadding: 0,\n    borderColor: 'rgba(0,0,0,0)',\n    borderWidth: 0,\n    animation: {\n      duration: 400,\n      easing: 'easeOutQuart',\n    },\n    animations: {\n      numbers: {\n        type: 'number',\n        properties: ['x', 'y', 'width', 'height', 'caretX', 'caretY'],\n      },\n      opacity: {\n        easing: 'linear',\n        duration: 200\n      }\n    },\n    callbacks: defaultCallbacks\n  },\n\n  defaultRoutes: {\n    bodyFont: 'font',\n    footerFont: 'font',\n    titleFont: 'font'\n  },\n\n  descriptors: {\n    _scriptable: (name) => name !== 'filter' && name !== 'itemSort' && name !== 'external',\n    _indexable: false,\n    callbacks: {\n      _scriptable: false,\n      _indexable: false,\n    },\n    animation: {\n      _fallback: false\n    },\n    animations: {\n      _fallback: 'animation'\n    }\n  },\n\n  // Resolve additionally from `interaction` options and defaults.\n  additionalOptionScopes: ['interaction']\n};\n","import Scale from '../core/core.scale.js';\nimport {isNullOrUndef, valueOrDefault, _limitValue} from '../helpers/index.js';\n\nconst addIfString = (labels, raw, index, addedLabels) => {\n  if (typeof raw === 'string') {\n    index = labels.push(raw) - 1;\n    addedLabels.unshift({index, label: raw});\n  } else if (isNaN(raw)) {\n    index = null;\n  }\n  return index;\n};\n\nfunction findOrAddLabel(labels, raw, index, addedLabels) {\n  const first = labels.indexOf(raw);\n  if (first === -1) {\n    return addIfString(labels, raw, index, addedLabels);\n  }\n  const last = labels.lastIndexOf(raw);\n  return first !== last ? index : first;\n}\n\nconst validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);\n\nfunction _getLabelForValue(value) {\n  const labels = this.getLabels();\n\n  if (value >= 0 && value < labels.length) {\n    return labels[value];\n  }\n  return value;\n}\n\nexport default class CategoryScale extends Scale {\n\n  static id = 'category';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: _getLabelForValue\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n    this._addedLabels = [];\n  }\n\n  init(scaleOptions) {\n    const added = this._addedLabels;\n    if (added.length) {\n      const labels = this.getLabels();\n      for (const {index, label} of added) {\n        if (labels[index] === label) {\n          labels.splice(index, 1);\n        }\n      }\n      this._addedLabels = [];\n    }\n    super.init(scaleOptions);\n  }\n\n  parse(raw, index) {\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    const labels = this.getLabels();\n    index = isFinite(index) && labels[index] === raw ? index\n      : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);\n    return validIndex(index, labels.length - 1);\n  }\n\n  determineDataLimits() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this.getMinMax(true);\n\n    if (this.options.bounds === 'ticks') {\n      if (!minDefined) {\n        min = 0;\n      }\n      if (!maxDefined) {\n        max = this.getLabels().length - 1;\n      }\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const min = this.min;\n    const max = this.max;\n    const offset = this.options.offset;\n    const ticks = [];\n    let labels = this.getLabels();\n\n    // If we are viewing some subset of labels, slice the original array\n    labels = (min === 0 && max === labels.length - 1) ? labels : labels.slice(min, max + 1);\n\n    this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);\n    this._startValue = this.min - (offset ? 0.5 : 0);\n\n    for (let value = min; value <= max; value++) {\n      ticks.push({value});\n    }\n    return ticks;\n  }\n\n  getLabelForValue(value) {\n    return _getLabelForValue.call(this, value);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    super.configure();\n\n    if (!this.isHorizontal()) {\n      // For backward compatibility, vertical category scale reverse is inverted.\n      this._reversePixels = !this._reversePixels;\n    }\n  }\n\n  // Used to get data value locations. Value can either be an index or a numerical value\n  getPixelForValue(value) {\n    if (typeof value !== 'number') {\n      value = this.parse(value);\n    }\n\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  // Must override base implementation because it calls getPixelForValue\n  // and category scale can have duplicate values\n  getPixelForTick(index) {\n    const ticks = this.ticks;\n    if (index < 0 || index > ticks.length - 1) {\n      return null;\n    }\n    return this.getPixelForValue(ticks[index].value);\n  }\n\n  getValueForPixel(pixel) {\n    return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);\n  }\n\n  getBasePixel() {\n    return this.bottom;\n  }\n}\n","import {isNullOrUndef} from '../helpers/helpers.core.js';\nimport {almostEquals, almostWhole, niceNum, _decimalPlaces, _setMinAndMaxByKey, sign, toRadians} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\n\n/**\n * Generate a set of linear ticks for an axis\n * 1. If generationOptions.min, generationOptions.max, and generationOptions.step are defined:\n *    if (max - min) / step is an integer, ticks are generated as [min, min + step, ..., max]\n *    Note that the generationOptions.maxCount setting is respected in this scenario\n *\n * 2. If generationOptions.min, generationOptions.max, and generationOptions.count is defined\n *    spacing = (max - min) / count\n *    Ticks are generated as [min, min + spacing, ..., max]\n *\n * 3. If generationOptions.count is defined\n *    spacing = (niceMax - niceMin) / count\n *\n * 4. Compute optimal spacing of ticks using niceNum algorithm\n *\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, dataRange) {\n  const ticks = [];\n  // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  const MIN_SPACING = 1e-14;\n  const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;\n  const unit = step || 1;\n  const maxSpaces = maxTicks - 1;\n  const {min: rmin, max: rmax} = dataRange;\n  const minDefined = !isNullOrUndef(min);\n  const maxDefined = !isNullOrUndef(max);\n  const countDefined = !isNullOrUndef(count);\n  const minSpacing = (rmax - rmin) / (maxDigits + 1);\n  let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;\n  let factor, niceMin, niceMax, numSpaces;\n\n  // Beyond MIN_SPACING floating point numbers being to lose precision\n  // such that we can't do the math necessary to generate ticks\n  if (spacing < MIN_SPACING && !minDefined && !maxDefined) {\n    return [{value: rmin}, {value: rmax}];\n  }\n\n  numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);\n  if (numSpaces > maxSpaces) {\n    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it\n    spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;\n  }\n\n  if (!isNullOrUndef(precision)) {\n    // If the user specified a precision, round to that number of decimal places\n    factor = Math.pow(10, precision);\n    spacing = Math.ceil(spacing * factor) / factor;\n  }\n\n  if (bounds === 'ticks') {\n    niceMin = Math.floor(rmin / spacing) * spacing;\n    niceMax = Math.ceil(rmax / spacing) * spacing;\n  } else {\n    niceMin = rmin;\n    niceMax = rmax;\n  }\n\n  if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1000)) {\n    // Case 1: If min, max and stepSize are set and they make an evenly spaced scale use it.\n    // spacing = step;\n    // numSpaces = (max - min) / spacing;\n    // Note that we round here to handle the case where almostWhole translated an FP error\n    numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));\n    spacing = (max - min) / numSpaces;\n    niceMin = min;\n    niceMax = max;\n  } else if (countDefined) {\n    // Cases 2 & 3, we have a count specified. Handle optional user defined edges to the range.\n    // Sometimes these are no-ops, but it makes the code a lot clearer\n    // and when a user defined range is specified, we want the correct ticks\n    niceMin = minDefined ? min : niceMin;\n    niceMax = maxDefined ? max : niceMax;\n    numSpaces = count - 1;\n    spacing = (niceMax - niceMin) / numSpaces;\n  } else {\n    // Case 4\n    numSpaces = (niceMax - niceMin) / spacing;\n\n    // If very close to our rounded value, use it.\n    if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n      numSpaces = Math.round(numSpaces);\n    } else {\n      numSpaces = Math.ceil(numSpaces);\n    }\n  }\n\n  // The spacing will have changed in cases 1, 2, and 3 so the factor cannot be computed\n  // until this point\n  const decimalPlaces = Math.max(\n    _decimalPlaces(spacing),\n    _decimalPlaces(niceMin)\n  );\n  factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);\n  niceMin = Math.round(niceMin * factor) / factor;\n  niceMax = Math.round(niceMax * factor) / factor;\n\n  let j = 0;\n  if (minDefined) {\n    if (includeBounds && niceMin !== min) {\n      ticks.push({value: min});\n\n      if (niceMin < min) {\n        j++; // Skip niceMin\n      }\n      // If the next nice tick is close to min, skip it\n      if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) {\n        j++;\n      }\n    } else if (niceMin < min) {\n      j++;\n    }\n  }\n\n  for (; j < numSpaces; ++j) {\n    const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;\n    if (maxDefined && tickValue > max) {\n      break;\n    }\n    ticks.push({value: tickValue});\n  }\n\n  if (maxDefined && includeBounds && niceMax !== max) {\n    // If the previous tick is too close to max, replace it with max, else add max\n    if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) {\n      ticks[ticks.length - 1].value = max;\n    } else {\n      ticks.push({value: max});\n    }\n  } else if (!maxDefined || niceMax === max) {\n    ticks.push({value: niceMax});\n  }\n\n  return ticks;\n}\n\nfunction relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {\n  const rad = toRadians(minRotation);\n  const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || 0.001;\n  const length = 0.75 * minSpacing * ('' + value).length;\n  return Math.min(minSpacing / ratio, length);\n}\n\nexport default class LinearScaleBase extends Scale {\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    /** @type {number} */\n    this._endValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (isNullOrUndef(raw)) {\n      return null;\n    }\n    if ((typeof raw === 'number' || raw instanceof Number) && !isFinite(+raw)) {\n      return null;\n    }\n\n    return +raw;\n  }\n\n  handleTickRangeOptions() {\n    const {beginAtZero} = this.options;\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let {min, max} = this;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (beginAtZero) {\n      const minSign = sign(min);\n      const maxSign = sign(max);\n\n      if (minSign < 0 && maxSign < 0) {\n        setMax(0);\n      } else if (minSign > 0 && maxSign > 0) {\n        setMin(0);\n      }\n    }\n\n    if (min === max) {\n      let offset = max === 0 ? 1 : Math.abs(max * 0.05);\n\n      setMax(max + offset);\n\n      if (!beginAtZero) {\n        setMin(min - offset);\n      }\n    }\n    this.min = min;\n    this.max = max;\n  }\n\n  getTickLimit() {\n    const tickOpts = this.options.ticks;\n    // eslint-disable-next-line prefer-const\n    let {maxTicksLimit, stepSize} = tickOpts;\n    let maxTicks;\n\n    if (stepSize) {\n      maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;\n      if (maxTicks > 1000) {\n        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);\n        maxTicks = 1000;\n      }\n    } else {\n      maxTicks = this.computeTickLimit();\n      maxTicksLimit = maxTicksLimit || 11;\n    }\n\n    if (maxTicksLimit) {\n      maxTicks = Math.min(maxTicksLimit, maxTicks);\n    }\n\n    return maxTicks;\n  }\n\n  /**\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Number.POSITIVE_INFINITY;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    // Figure out what the max number of ticks we can support it is based on the size of\n    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40\n    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n    // the graph. Make sure we always have at least 2 ticks\n    let maxTicks = this.getTickLimit();\n    maxTicks = Math.max(2, maxTicks);\n\n    const numericGeneratorOptions = {\n      maxTicks,\n      bounds: opts.bounds,\n      min: opts.min,\n      max: opts.max,\n      precision: tickOpts.precision,\n      step: tickOpts.stepSize,\n      count: tickOpts.count,\n      maxDigits: this._maxDigits(),\n      horizontal: this.isHorizontal(),\n      minRotation: tickOpts.minRotation || 0,\n      includeBounds: tickOpts.includeBounds !== false\n    };\n    const dataRange = this._range || this;\n    const ticks = generateTicks(numericGeneratorOptions, dataRange);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const ticks = this.ticks;\n    let start = this.min;\n    let end = this.max;\n\n    super.configure();\n\n    if (this.options.offset && ticks.length) {\n      const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;\n      start -= offset;\n      end += offset;\n    }\n    this._startValue = start;\n    this._endValue = end;\n    this._valueRange = end - start;\n  }\n\n  getLabelForValue(value) {\n    return formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n}\n","import {isFinite} from '../helpers/helpers.core.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {toRadians} from '../helpers/index.js';\n\nexport default class LinearScale extends LinearScaleBase {\n\n  static id = 'linear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.numeric\n    }\n  };\n\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? min : 0;\n    this.max = isFinite(max) ? max : 1;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n \t */\n  computeTickLimit() {\n    const horizontal = this.isHorizontal();\n    const length = horizontal ? this.width : this.height;\n    const minRotation = toRadians(this.options.ticks.minRotation);\n    const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || 0.001;\n    const tickFont = this._resolveTickFontOptions(0);\n    return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));\n  }\n\n  // Utils\n  getPixelForValue(value) {\n    return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;\n  }\n}\n","import {finiteOrDefault, isFinite} from '../helpers/helpers.core.js';\nimport {formatNumber} from '../helpers/helpers.intl.js';\nimport {_setMinAndMaxByKey, log10} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\n\nconst log10Floor = v => Math.floor(log10(v));\nconst changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);\n\nfunction isMajor(tickVal) {\n  const remain = tickVal / (Math.pow(10, log10Floor(tickVal)));\n  return remain === 1;\n}\n\nfunction steps(min, max, rangeExp) {\n  const rangeStep = Math.pow(10, rangeExp);\n  const start = Math.floor(min / rangeStep);\n  const end = Math.ceil(max / rangeStep);\n  return end - start;\n}\n\nfunction startExp(min, max) {\n  const range = max - min;\n  let rangeExp = log10Floor(range);\n  while (steps(min, max, rangeExp) > 10) {\n    rangeExp++;\n  }\n  while (steps(min, max, rangeExp) < 10) {\n    rangeExp--;\n  }\n  return Math.min(rangeExp, log10Floor(min));\n}\n\n\n/**\n * Generate a set of logarithmic ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {object[]} array of tick objects\n */\nfunction generateTicks(generationOptions, {min, max}) {\n  min = finiteOrDefault(generationOptions.min, min);\n  const ticks = [];\n  const minExp = log10Floor(min);\n  let exp = startExp(min, max);\n  let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;\n  const stepSize = Math.pow(10, exp);\n  const base = minExp > exp ? Math.pow(10, minExp) : 0;\n  const start = Math.round((min - base) * precision) / precision;\n  const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;\n  let significand = Math.floor((start - offset) / Math.pow(10, exp));\n  let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);\n  while (value < max) {\n    ticks.push({value, major: isMajor(value), significand});\n    if (significand >= 10) {\n      significand = significand < 15 ? 15 : 20;\n    } else {\n      significand++;\n    }\n    if (significand >= 20) {\n      exp++;\n      significand = 2;\n      precision = exp >= 0 ? 1 : precision;\n    }\n    value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;\n  }\n  const lastTick = finiteOrDefault(generationOptions.max, value);\n  ticks.push({value: lastTick, major: isMajor(lastTick), significand});\n\n  return ticks;\n}\n\nexport default class LogarithmicScale extends Scale {\n\n  static id = 'logarithmic';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    ticks: {\n      callback: Ticks.formatters.logarithmic,\n      major: {\n        enabled: true\n      }\n    }\n  };\n\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.start = undefined;\n    /** @type {number} */\n    this.end = undefined;\n    /** @type {number} */\n    this._startValue = undefined;\n    this._valueRange = 0;\n  }\n\n  parse(raw, index) {\n    const value = LinearScaleBase.prototype.parse.apply(this, [raw, index]);\n    if (value === 0) {\n      this._zero = true;\n      return undefined;\n    }\n    return isFinite(value) && value > 0 ? value : null;\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(true);\n\n    this.min = isFinite(min) ? Math.max(0, min) : null;\n    this.max = isFinite(max) ? Math.max(0, max) : null;\n\n    if (this.options.beginAtZero) {\n      this._zero = true;\n    }\n\n    // if data has `0` in it or `beginAtZero` is true, min (non zero) value is at bottom\n    // of scale, and it does not equal suggestedMin, lower the min bound by one exp.\n    if (this._zero && this.min !== this._suggestedMin && !isFinite(this._userMin)) {\n      this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);\n    }\n\n    this.handleTickRangeOptions();\n  }\n\n  handleTickRangeOptions() {\n    const {minDefined, maxDefined} = this.getUserBounds();\n    let min = this.min;\n    let max = this.max;\n\n    const setMin = v => (min = minDefined ? min : v);\n    const setMax = v => (max = maxDefined ? max : v);\n\n    if (min === max) {\n      if (min <= 0) { // includes null\n        setMin(1);\n        setMax(10);\n      } else {\n        setMin(changeExponent(min, -1));\n        setMax(changeExponent(max, +1));\n      }\n    }\n    if (min <= 0) {\n      setMin(changeExponent(max, -1));\n    }\n    if (max <= 0) {\n\n      setMax(changeExponent(min, +1));\n    }\n\n    this.min = min;\n    this.max = max;\n  }\n\n  buildTicks() {\n    const opts = this.options;\n\n    const generationOptions = {\n      min: this._userMin,\n      max: this._userMax\n    };\n    const ticks = generateTicks(generationOptions, this);\n\n    // At this point, we need to update our max and min given the tick values,\n    // since we probably have expanded the range of the scale\n    if (opts.bounds === 'ticks') {\n      _setMinAndMaxByKey(ticks, this, 'value');\n    }\n\n    if (opts.reverse) {\n      ticks.reverse();\n\n      this.start = this.max;\n      this.end = this.min;\n    } else {\n      this.start = this.min;\n      this.end = this.max;\n    }\n\n    return ticks;\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    return value === undefined\n      ? '0'\n      : formatNumber(value, this.chart.options.locale, this.options.ticks.format);\n  }\n\n  /**\n\t * @protected\n\t */\n  configure() {\n    const start = this.min;\n\n    super.configure();\n\n    this._startValue = log10(start);\n    this._valueRange = log10(this.max) - log10(start);\n  }\n\n  getPixelForValue(value) {\n    if (value === undefined || value === 0) {\n      value = this.min;\n    }\n    if (value === null || isNaN(value)) {\n      return NaN;\n    }\n    return this.getPixelForDecimal(value === this.min\n      ? 0\n      : (log10(value) - this._startValue) / this._valueRange);\n  }\n\n  getValueForPixel(pixel) {\n    const decimal = this.getDecimalForPixel(pixel);\n    return Math.pow(10, this._startValue + decimal * this._valueRange);\n  }\n}\n","import defaults from '../core/core.defaults.js';\nimport {_longestText, addRoundedRectPath, renderText, _isPointInArea} from '../helpers/helpers.canvas.js';\nimport {HALF_PI, TAU, toDegrees, toRadians, _normalizeAngle, PI} from '../helpers/helpers.math.js';\nimport LinearScaleBase from './scale.linearbase.js';\nimport Ticks from '../core/core.ticks.js';\nimport {valueOrDefault, isArray, isFinite, callback as callCallback, isNullOrUndef} from '../helpers/helpers.core.js';\nimport {createContext, toFont, toPadding, toTRBLCorners} from '../helpers/helpers.options.js';\n\nfunction getTickBackdropHeight(opts) {\n  const tickOpts = opts.ticks;\n\n  if (tickOpts.display && opts.display) {\n    const padding = toPadding(tickOpts.backdropPadding);\n    return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;\n  }\n  return 0;\n}\n\nfunction measureLabelSize(ctx, font, label) {\n  label = isArray(label) ? label : [label];\n  return {\n    w: _longestText(ctx, font.string, label),\n    h: label.length * font.lineHeight\n  };\n}\n\nfunction determineLimits(angle, pos, size, min, max) {\n  if (angle === min || angle === max) {\n    return {\n      start: pos - (size / 2),\n      end: pos + (size / 2)\n    };\n  } else if (angle < min || angle > max) {\n    return {\n      start: pos - size,\n      end: pos\n    };\n  }\n\n  return {\n    start: pos,\n    end: pos + size\n  };\n}\n\n/**\n * Helper function to fit a radial linear scale with point labels\n */\nfunction fitWithPointLabels(scale) {\n\n  // Right, this is really confusing and there is a lot of maths going on here\n  // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9\n  //\n  // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif\n  //\n  // Solution:\n  //\n  // We assume the radius of the polygon is half the size of the canvas at first\n  // at each index we check if the text overlaps.\n  //\n  // Where it does, we store that angle and that index.\n  //\n  // After finding the largest index and angle we calculate how much we need to remove\n  // from the shape radius to move the point inwards by that x.\n  //\n  // We average the left and right distances to get the maximum shape radius that can fit in the box\n  // along with labels.\n  //\n  // Once we have that, we can find the centre point for the chart, by taking the x text protrusion\n  // on each side, removing that from the size, halving it and adding the left x protrusion width.\n  //\n  // This will mean we have a shape fitted to the canvas, as large as it can be with the labels\n  // and position it in the most space efficient manner\n  //\n  // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif\n\n  // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.\n  // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points\n  const orig = {\n    l: scale.left + scale._padding.left,\n    r: scale.right - scale._padding.right,\n    t: scale.top + scale._padding.top,\n    b: scale.bottom - scale._padding.bottom\n  };\n  const limits = Object.assign({}, orig);\n  const labelSizes = [];\n  const padding = [];\n  const valueCount = scale._pointLabels.length;\n  const pointLabelOpts = scale.options.pointLabels;\n  const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;\n\n  for (let i = 0; i < valueCount; i++) {\n    const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));\n    padding[i] = opts.padding;\n    const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);\n    const plFont = toFont(opts.font);\n    const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);\n    labelSizes[i] = textSize;\n\n    const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);\n    const angle = Math.round(toDegrees(angleRadians));\n    const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);\n    const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);\n    updateLimits(limits, orig, angleRadians, hLimits, vLimits);\n  }\n\n  scale.setCenterPoint(\n    orig.l - limits.l,\n    limits.r - orig.r,\n    orig.t - limits.t,\n    limits.b - orig.b\n  );\n\n  // Now that text size is determined, compute the full positions\n  scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);\n}\n\nfunction updateLimits(limits, orig, angle, hLimits, vLimits) {\n  const sin = Math.abs(Math.sin(angle));\n  const cos = Math.abs(Math.cos(angle));\n  let x = 0;\n  let y = 0;\n  if (hLimits.start < orig.l) {\n    x = (orig.l - hLimits.start) / sin;\n    limits.l = Math.min(limits.l, orig.l - x);\n  } else if (hLimits.end > orig.r) {\n    x = (hLimits.end - orig.r) / sin;\n    limits.r = Math.max(limits.r, orig.r + x);\n  }\n  if (vLimits.start < orig.t) {\n    y = (orig.t - vLimits.start) / cos;\n    limits.t = Math.min(limits.t, orig.t - y);\n  } else if (vLimits.end > orig.b) {\n    y = (vLimits.end - orig.b) / cos;\n    limits.b = Math.max(limits.b, orig.b + y);\n  }\n}\n\nfunction createPointLabelItem(scale, index, itemOpts) {\n  const outerDistance = scale.drawingArea;\n  const {extra, additionalAngle, padding, size} = itemOpts;\n  const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);\n  const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));\n  const y = yForAngle(pointLabelPosition.y, size.h, angle);\n  const textAlign = getTextAlignForAngle(angle);\n  const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);\n  return {\n    // if to draw or overlapped\n    visible: true,\n\n    // Text position\n    x: pointLabelPosition.x,\n    y,\n\n    // Text rendering data\n    textAlign,\n\n    // Bounding box\n    left,\n    top: y,\n    right: left + size.w,\n    bottom: y + size.h\n  };\n}\n\nfunction isNotOverlapped(item, area) {\n  if (!area) {\n    return true;\n  }\n  const {left, top, right, bottom} = item;\n  const apexesInArea = _isPointInArea({x: left, y: top}, area) || _isPointInArea({x: left, y: bottom}, area) ||\n    _isPointInArea({x: right, y: top}, area) || _isPointInArea({x: right, y: bottom}, area);\n  return !apexesInArea;\n}\n\nfunction buildPointLabelItems(scale, labelSizes, padding) {\n  const items = [];\n  const valueCount = scale._pointLabels.length;\n  const opts = scale.options;\n  const {centerPointLabels, display} = opts.pointLabels;\n  const itemOpts = {\n    extra: getTickBackdropHeight(opts) / 2,\n    additionalAngle: centerPointLabels ? PI / valueCount : 0\n  };\n  let area;\n\n  for (let i = 0; i < valueCount; i++) {\n    itemOpts.padding = padding[i];\n    itemOpts.size = labelSizes[i];\n\n    const item = createPointLabelItem(scale, i, itemOpts);\n    items.push(item);\n    if (display === 'auto') {\n      item.visible = isNotOverlapped(item, area);\n      if (item.visible) {\n        area = item;\n      }\n    }\n  }\n  return items;\n}\n\nfunction getTextAlignForAngle(angle) {\n  if (angle === 0 || angle === 180) {\n    return 'center';\n  } else if (angle < 180) {\n    return 'left';\n  }\n\n  return 'right';\n}\n\nfunction leftForTextAlign(x, w, align) {\n  if (align === 'right') {\n    x -= w;\n  } else if (align === 'center') {\n    x -= (w / 2);\n  }\n  return x;\n}\n\nfunction yForAngle(y, h, angle) {\n  if (angle === 90 || angle === 270) {\n    y -= (h / 2);\n  } else if (angle > 270 || angle < 90) {\n    y -= h;\n  }\n  return y;\n}\n\nfunction drawPointLabelBox(ctx, opts, item) {\n  const {left, top, right, bottom} = item;\n  const {backdropColor} = opts;\n\n  if (!isNullOrUndef(backdropColor)) {\n    const borderRadius = toTRBLCorners(opts.borderRadius);\n    const padding = toPadding(opts.backdropPadding);\n    ctx.fillStyle = backdropColor;\n\n    const backdropLeft = left - padding.left;\n    const backdropTop = top - padding.top;\n    const backdropWidth = right - left + padding.width;\n    const backdropHeight = bottom - top + padding.height;\n\n    if (Object.values(borderRadius).some(v => v !== 0)) {\n      ctx.beginPath();\n      addRoundedRectPath(ctx, {\n        x: backdropLeft,\n        y: backdropTop,\n        w: backdropWidth,\n        h: backdropHeight,\n        radius: borderRadius,\n      });\n      ctx.fill();\n    } else {\n      ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);\n    }\n  }\n}\n\nfunction drawPointLabels(scale, labelCount) {\n  const {ctx, options: {pointLabels}} = scale;\n\n  for (let i = labelCount - 1; i >= 0; i--) {\n    const item = scale._pointLabelItems[i];\n    if (!item.visible) {\n      // overlapping\n      continue;\n    }\n    const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));\n    drawPointLabelBox(ctx, optsAtIndex, item);\n    const plFont = toFont(optsAtIndex.font);\n    const {x, y, textAlign} = item;\n\n    renderText(\n      ctx,\n      scale._pointLabels[i],\n      x,\n      y + (plFont.lineHeight / 2),\n      plFont,\n      {\n        color: optsAtIndex.color,\n        textAlign: textAlign,\n        textBaseline: 'middle'\n      }\n    );\n  }\n}\n\nfunction pathRadiusLine(scale, radius, circular, labelCount) {\n  const {ctx} = scale;\n  if (circular) {\n    // Draw circular arcs between the points\n    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU);\n  } else {\n    // Draw straight lines connecting each index\n    let pointPosition = scale.getPointPosition(0, radius);\n    ctx.moveTo(pointPosition.x, pointPosition.y);\n\n    for (let i = 1; i < labelCount; i++) {\n      pointPosition = scale.getPointPosition(i, radius);\n      ctx.lineTo(pointPosition.x, pointPosition.y);\n    }\n  }\n}\n\nfunction drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {\n  const ctx = scale.ctx;\n  const circular = gridLineOpts.circular;\n\n  const {color, lineWidth} = gridLineOpts;\n\n  if ((!circular && !labelCount) || !color || !lineWidth || radius < 0) {\n    return;\n  }\n\n  ctx.save();\n  ctx.strokeStyle = color;\n  ctx.lineWidth = lineWidth;\n  ctx.setLineDash(borderOpts.dash);\n  ctx.lineDashOffset = borderOpts.dashOffset;\n\n  ctx.beginPath();\n  pathRadiusLine(scale, radius, circular, labelCount);\n  ctx.closePath();\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction createPointLabelContext(parent, index, label) {\n  return createContext(parent, {\n    label,\n    index,\n    type: 'pointLabel'\n  });\n}\n\nexport default class RadialLinearScale extends LinearScaleBase {\n\n  static id = 'radialLinear';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    display: true,\n\n    // Boolean - Whether to animate scaling the chart from the centre\n    animate: true,\n    position: 'chartArea',\n\n    angleLines: {\n      display: true,\n      lineWidth: 1,\n      borderDash: [],\n      borderDashOffset: 0.0\n    },\n\n    grid: {\n      circular: false\n    },\n\n    startAngle: 0,\n\n    // label settings\n    ticks: {\n      // Boolean - Show a backdrop to the scale label\n      showLabelBackdrop: true,\n\n      callback: Ticks.formatters.numeric\n    },\n\n    pointLabels: {\n      backdropColor: undefined,\n\n      // Number - The backdrop padding above & below the label in pixels\n      backdropPadding: 2,\n\n      // Boolean - if true, show point labels\n      display: true,\n\n      // Number - Point label font size in pixels\n      font: {\n        size: 10\n      },\n\n      // Function - Used to convert point labels\n      callback(label) {\n        return label;\n      },\n\n      // Number - Additionl padding between scale and pointLabel\n      padding: 5,\n\n      // Boolean - if true, center point labels to slices in polar chart\n      centerPointLabels: false\n    }\n  };\n\n  static defaultRoutes = {\n    'angleLines.color': 'borderColor',\n    'pointLabels.color': 'color',\n    'ticks.color': 'color'\n  };\n\n  static descriptors = {\n    angleLines: {\n      _fallback: 'grid'\n    }\n  };\n\n  constructor(cfg) {\n    super(cfg);\n\n    /** @type {number} */\n    this.xCenter = undefined;\n    /** @type {number} */\n    this.yCenter = undefined;\n    /** @type {number} */\n    this.drawingArea = undefined;\n    /** @type {string[]} */\n    this._pointLabels = [];\n    this._pointLabelItems = [];\n  }\n\n  setDimensions() {\n    // Set the unconstrained dimension before label rotation\n    const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);\n    const w = this.width = this.maxWidth - padding.width;\n    const h = this.height = this.maxHeight - padding.height;\n    this.xCenter = Math.floor(this.left + w / 2 + padding.left);\n    this.yCenter = Math.floor(this.top + h / 2 + padding.top);\n    this.drawingArea = Math.floor(Math.min(w, h) / 2);\n  }\n\n  determineDataLimits() {\n    const {min, max} = this.getMinMax(false);\n\n    this.min = isFinite(min) && !isNaN(min) ? min : 0;\n    this.max = isFinite(max) && !isNaN(max) ? max : 0;\n\n    // Common base implementation to handle min, max, beginAtZero\n    this.handleTickRangeOptions();\n  }\n\n  /**\n\t * Returns the maximum number of ticks based on the scale dimension\n\t * @protected\n\t */\n  computeTickLimit() {\n    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));\n  }\n\n  generateTickLabels(ticks) {\n    LinearScaleBase.prototype.generateTickLabels.call(this, ticks);\n\n    // Point labels\n    this._pointLabels = this.getLabels()\n      .map((value, index) => {\n        const label = callCallback(this.options.pointLabels.callback, [value, index], this);\n        return label || label === 0 ? label : '';\n      })\n      .filter((v, i) => this.chart.getDataVisibility(i));\n  }\n\n  fit() {\n    const opts = this.options;\n\n    if (opts.display && opts.pointLabels.display) {\n      fitWithPointLabels(this);\n    } else {\n      this.setCenterPoint(0, 0, 0, 0);\n    }\n  }\n\n  setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {\n    this.xCenter += Math.floor((leftMovement - rightMovement) / 2);\n    this.yCenter += Math.floor((topMovement - bottomMovement) / 2);\n    this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));\n  }\n\n  getIndexAngle(index) {\n    const angleMultiplier = TAU / (this._pointLabels.length || 1);\n    const startAngle = this.options.startAngle || 0;\n\n    return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));\n  }\n\n  getDistanceFromCenterForValue(value) {\n    if (isNullOrUndef(value)) {\n      return NaN;\n    }\n\n    // Take into account half font size + the yPadding of the top value\n    const scalingFactor = this.drawingArea / (this.max - this.min);\n    if (this.options.reverse) {\n      return (this.max - value) * scalingFactor;\n    }\n    return (value - this.min) * scalingFactor;\n  }\n\n  getValueForDistanceFromCenter(distance) {\n    if (isNullOrUndef(distance)) {\n      return NaN;\n    }\n\n    const scaledDistance = distance / (this.drawingArea / (this.max - this.min));\n    return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;\n  }\n\n  getPointLabelContext(index) {\n    const pointLabels = this._pointLabels || [];\n\n    if (index >= 0 && index < pointLabels.length) {\n      const pointLabel = pointLabels[index];\n      return createPointLabelContext(this.getContext(), index, pointLabel);\n    }\n  }\n\n  getPointPosition(index, distanceFromCenter, additionalAngle = 0) {\n    const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;\n    return {\n      x: Math.cos(angle) * distanceFromCenter + this.xCenter,\n      y: Math.sin(angle) * distanceFromCenter + this.yCenter,\n      angle\n    };\n  }\n\n  getPointPositionForValue(index, value) {\n    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));\n  }\n\n  getBasePosition(index) {\n    return this.getPointPositionForValue(index || 0, this.getBaseValue());\n  }\n\n  getPointLabelPosition(index) {\n    const {left, top, right, bottom} = this._pointLabelItems[index];\n    return {\n      left,\n      top,\n      right,\n      bottom,\n    };\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBackground() {\n    const {backgroundColor, grid: {circular}} = this.options;\n    if (backgroundColor) {\n      const ctx = this.ctx;\n      ctx.save();\n      ctx.beginPath();\n      pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);\n      ctx.closePath();\n      ctx.fillStyle = backgroundColor;\n      ctx.fill();\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawGrid() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const {angleLines, grid, border} = opts;\n    const labelCount = this._pointLabels.length;\n\n    let i, offset, position;\n\n    if (opts.pointLabels.display) {\n      drawPointLabels(this, labelCount);\n    }\n\n    if (grid.display) {\n      this.ticks.forEach((tick, index) => {\n        if (index !== 0) {\n          offset = this.getDistanceFromCenterForValue(tick.value);\n          const context = this.getContext(index);\n          const optsAtIndex = grid.setContext(context);\n          const optsAtIndexBorder = border.setContext(context);\n\n          drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);\n        }\n      });\n    }\n\n    if (angleLines.display) {\n      ctx.save();\n\n      for (i = labelCount - 1; i >= 0; i--) {\n        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));\n        const {color, lineWidth} = optsAtIndex;\n\n        if (!lineWidth || !color) {\n          continue;\n        }\n\n        ctx.lineWidth = lineWidth;\n        ctx.strokeStyle = color;\n\n        ctx.setLineDash(optsAtIndex.borderDash);\n        ctx.lineDashOffset = optsAtIndex.borderDashOffset;\n\n        offset = this.getDistanceFromCenterForValue(opts.ticks.reverse ? this.min : this.max);\n        position = this.getPointPosition(i, offset);\n        ctx.beginPath();\n        ctx.moveTo(this.xCenter, this.yCenter);\n        ctx.lineTo(position.x, position.y);\n        ctx.stroke();\n      }\n\n      ctx.restore();\n    }\n  }\n\n  /**\n\t * @protected\n\t */\n  drawBorder() {}\n\n  /**\n\t * @protected\n\t */\n  drawLabels() {\n    const ctx = this.ctx;\n    const opts = this.options;\n    const tickOpts = opts.ticks;\n\n    if (!tickOpts.display) {\n      return;\n    }\n\n    const startAngle = this.getIndexAngle(0);\n    let offset, width;\n\n    ctx.save();\n    ctx.translate(this.xCenter, this.yCenter);\n    ctx.rotate(startAngle);\n    ctx.textAlign = 'center';\n    ctx.textBaseline = 'middle';\n\n    this.ticks.forEach((tick, index) => {\n      if (index === 0 && !opts.reverse) {\n        return;\n      }\n\n      const optsAtIndex = tickOpts.setContext(this.getContext(index));\n      const tickFont = toFont(optsAtIndex.font);\n      offset = this.getDistanceFromCenterForValue(this.ticks[index].value);\n\n      if (optsAtIndex.showLabelBackdrop) {\n        ctx.font = tickFont.string;\n        width = ctx.measureText(tick.label).width;\n        ctx.fillStyle = optsAtIndex.backdropColor;\n\n        const padding = toPadding(optsAtIndex.backdropPadding);\n        ctx.fillRect(\n          -width / 2 - padding.left,\n          -offset - tickFont.size / 2 - padding.top,\n          width + padding.width,\n          tickFont.size + padding.height\n        );\n      }\n\n      renderText(ctx, tick.label, 0, -offset, tickFont, {\n        color: optsAtIndex.color,\n        strokeColor: optsAtIndex.textStrokeColor,\n        strokeWidth: optsAtIndex.textStrokeWidth,\n      });\n    });\n\n    ctx.restore();\n  }\n\n  /**\n\t * @protected\n\t */\n  drawTitle() {}\n}\n","import adapters from '../core/core.adapters.js';\nimport {callback as call, isFinite, isNullOrUndef, mergeIf, valueOrDefault} from '../helpers/helpers.core.js';\nimport {toRadians, isNumber, _limitValue} from '../helpers/helpers.math.js';\nimport Scale from '../core/core.scale.js';\nimport {_arrayUnique, _filterBetween, _lookup} from '../helpers/helpers.collection.js';\n\n/**\n * @typedef { import('../core/core.adapters.js').TimeUnit } Unit\n * @typedef {{common: boolean, size: number, steps?: number}} Interval\n * @typedef { import('../core/core.adapters.js').DateAdapter } DateAdapter\n */\n\n/**\n * @type {Object<Unit, Interval>}\n */\nconst INTERVALS = {\n  millisecond: {common: true, size: 1, steps: 1000},\n  second: {common: true, size: 1000, steps: 60},\n  minute: {common: true, size: 60000, steps: 60},\n  hour: {common: true, size: 3600000, steps: 24},\n  day: {common: true, size: 86400000, steps: 30},\n  week: {common: false, size: 604800000, steps: 4},\n  month: {common: true, size: 2.628e9, steps: 12},\n  quarter: {common: false, size: 7.884e9, steps: 4},\n  year: {common: true, size: 3.154e10}\n};\n\n/**\n * @type {Unit[]}\n */\nconst UNITS = /** @type Unit[] */ /* #__PURE__ */ (Object.keys(INTERVALS));\n\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction sorter(a, b) {\n  return a - b;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {*} input\n * @return {number}\n */\nfunction parse(scale, input) {\n  if (isNullOrUndef(input)) {\n    return null;\n  }\n\n  const adapter = scale._adapter;\n  const {parser, round, isoWeekday} = scale._parseOpts;\n  let value = input;\n\n  if (typeof parser === 'function') {\n    value = parser(value);\n  }\n\n  // Only parse if it's not a timestamp already\n  if (!isFinite(value)) {\n    value = typeof parser === 'string'\n      ? adapter.parse(value, /** @type {Unit} */ (parser))\n      : adapter.parse(value);\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (round) {\n    value = round === 'week' && (isNumber(isoWeekday) || isoWeekday === true)\n      ? adapter.startOf(value, 'isoWeek', isoWeekday)\n      : adapter.startOf(value, round);\n  }\n\n  return +value;\n}\n\n/**\n * Figures out what unit results in an appropriate number of auto-generated ticks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @param {number} capacity\n * @return {object}\n */\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const interval = INTERVALS[UNITS[i]];\n    const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;\n\n    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\n/**\n * Figures out what unit to format a set of ticks with\n * @param {TimeScale} scale\n * @param {number} numTicks\n * @param {Unit} minUnit\n * @param {number} min\n * @param {number} max\n * @return {Unit}\n */\nfunction determineUnitForFormatting(scale, numTicks, minUnit, min, max) {\n  for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {\n    const unit = UNITS[i];\n    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {\n      return unit;\n    }\n  }\n\n  return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];\n}\n\n/**\n * @param {Unit} unit\n * @return {object}\n */\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\n/**\n * @param {object} ticks\n * @param {number} time\n * @param {number[]} [timestamps] - if defined, snap to these timestamps\n */\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\n/**\n * @param {TimeScale} scale\n * @param {object[]} ticks\n * @param {object} map\n * @param {Unit} majorUnit\n * @return {object[]}\n */\nfunction setMajorTicks(scale, ticks, map, majorUnit) {\n  const adapter = scale._adapter;\n  const first = +adapter.startOf(ticks[0].value, majorUnit);\n  const last = ticks[ticks.length - 1].value;\n  let major, index;\n\n  for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {\n    index = map[major];\n    if (index >= 0) {\n      ticks[index].major = true;\n    }\n  }\n  return ticks;\n}\n\n/**\n * @param {TimeScale} scale\n * @param {number[]} values\n * @param {Unit|undefined} [majorUnit]\n * @return {object[]}\n */\nfunction ticksFromTimestamps(scale, values, majorUnit) {\n  const ticks = [];\n  /** @type {Object<number,object>} */\n  const map = {};\n  const ilen = values.length;\n  let i, value;\n\n  for (i = 0; i < ilen; ++i) {\n    value = values[i];\n    map[value] = i;\n\n    ticks.push({\n      value,\n      major: false\n    });\n  }\n\n  // We set the major ticks separately from the above loop because calling startOf for every tick\n  // is expensive when there is a large number of ticks\n  return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);\n}\n\nexport default class TimeScale extends Scale {\n\n  static id = 'time';\n\n  /**\n   * @type {any}\n   */\n  static defaults = {\n    /**\n     * Scale boundary strategy (bypassed by min/max time options)\n     * - `data`: make sure data are fully visible, ticks outside are removed\n     * - `ticks`: make sure ticks are fully visible, data outside are truncated\n     * @see https://github.com/chartjs/Chart.js/pull/4556\n     * @since 2.7.0\n     */\n    bounds: 'data',\n\n    adapters: {},\n    time: {\n      parser: false, // false == a pattern string from or a custom callback that converts its argument to a timestamp\n      unit: false, // false == automatic or override with week, month, year, etc.\n      round: false, // none, or override with week, month, year, etc.\n      isoWeekday: false, // override week start day\n      minUnit: 'millisecond',\n      displayFormats: {}\n    },\n    ticks: {\n      /**\n       * Ticks generation input values:\n       * - 'auto': generates \"optimal\" ticks based on scale size and time options.\n       * - 'data': generates ticks from data (including labels from data {t|x|y} objects).\n       * - 'labels': generates ticks from user given `data.labels` values ONLY.\n       * @see https://github.com/chartjs/Chart.js/pull/4507\n       * @since 2.7.0\n       */\n      source: 'auto',\n\n      callback: false,\n\n      major: {\n        enabled: false\n      }\n    }\n  };\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {{data: number[], labels: number[], all: number[]}} */\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n\n    /** @type {Unit} */\n    this._unit = 'day';\n    /** @type {Unit=} */\n    this._majorUnit = undefined;\n    this._offsets = {};\n    this._normalized = false;\n    this._parseOpts = undefined;\n  }\n\n  init(scaleOpts, opts = {}) {\n    const time = scaleOpts.time || (scaleOpts.time = {});\n    /** @type {DateAdapter} */\n    const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);\n\n    adapter.init(opts);\n\n    // Backward compatibility: before introducing adapter, `displayFormats` was\n    // supposed to contain *all* unit/string pairs but this can't be resolved\n    // when loading the scale (adapters are loaded afterward), so let's populate\n    // missing formats on update\n    mergeIf(time.displayFormats, adapter.formats());\n\n    this._parseOpts = {\n      parser: time.parser,\n      round: time.round,\n      isoWeekday: time.isoWeekday\n    };\n\n    super.init(scaleOpts);\n\n    this._normalized = opts.normalized;\n  }\n\n  /**\n\t * @param {*} raw\n\t * @param {number?} [index]\n\t * @return {number}\n\t */\n  parse(raw, index) { // eslint-disable-line no-unused-vars\n    if (raw === undefined) {\n      return null;\n    }\n    return parse(this, raw);\n  }\n\n  beforeLayout() {\n    super.beforeLayout();\n    this._cache = {\n      data: [],\n      labels: [],\n      all: []\n    };\n  }\n\n  determineDataLimits() {\n    const options = this.options;\n    const adapter = this._adapter;\n    const unit = options.time.unit || 'day';\n    // eslint-disable-next-line prefer-const\n    let {min, max, minDefined, maxDefined} = this.getUserBounds();\n\n    /**\n\t\t * @param {object} bounds\n\t\t */\n    function _applyBounds(bounds) {\n      if (!minDefined && !isNaN(bounds.min)) {\n        min = Math.min(min, bounds.min);\n      }\n      if (!maxDefined && !isNaN(bounds.max)) {\n        max = Math.max(max, bounds.max);\n      }\n    }\n\n    // If we have user provided `min` and `max` labels / data bounds can be ignored\n    if (!minDefined || !maxDefined) {\n      // Labels are always considered, when user did not force bounds\n      _applyBounds(this._getLabelBounds());\n\n      // If `bounds` is `'ticks'` and `ticks.source` is `'labels'`,\n      // data bounds are ignored (and don't need to be determined)\n      if (options.bounds !== 'ticks' || options.ticks.source !== 'labels') {\n        _applyBounds(this.getMinMax(false));\n      }\n    }\n\n    min = isFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);\n    max = isFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;\n\n    // Make sure that max is strictly higher than min (required by the timeseries lookup table)\n    this.min = Math.min(min, max - 1);\n    this.max = Math.max(min + 1, max);\n  }\n\n  /**\n\t * @private\n\t */\n  _getLabelBounds() {\n    const arr = this.getLabelTimestamps();\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    if (arr.length) {\n      min = arr[0];\n      max = arr[arr.length - 1];\n    }\n    return {min, max};\n  }\n\n  /**\n\t * @return {object[]}\n\t */\n  buildTicks() {\n    const options = this.options;\n    const timeOpts = options.time;\n    const tickOpts = options.ticks;\n    const timestamps = tickOpts.source === 'labels' ? this.getLabelTimestamps() : this._generate();\n\n    if (options.bounds === 'ticks' && timestamps.length) {\n      this.min = this._userMin || timestamps[0];\n      this.max = this._userMax || timestamps[timestamps.length - 1];\n    }\n\n    const min = this.min;\n    const max = this.max;\n\n    const ticks = _filterBetween(timestamps, min, max);\n\n    // PRIVATE\n    // determineUnitForFormatting relies on the number of ticks so we don't use it when\n    // autoSkip is enabled because we don't yet know what the final number of ticks will be\n    this._unit = timeOpts.unit || (tickOpts.autoSkip\n      ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min))\n      : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));\n    this._majorUnit = !tickOpts.major.enabled || this._unit === 'year' ? undefined\n      : determineMajorUnit(this._unit);\n    this.initOffsets(timestamps);\n\n    if (options.reverse) {\n      ticks.reverse();\n    }\n\n    return ticksFromTimestamps(this, ticks, this._majorUnit);\n  }\n\n  afterAutoSkip() {\n    // Offsets for bar charts need to be handled with the auto skipped\n    // ticks. Once ticks have been skipped, we re-compute the offsets.\n    if (this.options.offsetAfterAutoskip) {\n      this.initOffsets(this.ticks.map(tick => +tick.value));\n    }\n  }\n\n  /**\n\t * Returns the start and end offsets from edges in the form of {start, end}\n\t * where each value is a relative width to the scale and ranges between 0 and 1.\n\t * They add extra margins on the both sides by scaling down the original scale.\n\t * Offsets are added when the `offset` option is true.\n\t * @param {number[]} timestamps\n\t * @protected\n\t */\n  initOffsets(timestamps = []) {\n    let start = 0;\n    let end = 0;\n    let first, last;\n\n    if (this.options.offset && timestamps.length) {\n      first = this.getDecimalForValue(timestamps[0]);\n      if (timestamps.length === 1) {\n        start = 1 - first;\n      } else {\n        start = (this.getDecimalForValue(timestamps[1]) - first) / 2;\n      }\n      last = this.getDecimalForValue(timestamps[timestamps.length - 1]);\n      if (timestamps.length === 1) {\n        end = last;\n      } else {\n        end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;\n      }\n    }\n    const limit = timestamps.length < 3 ? 0.5 : 0.25;\n    start = _limitValue(start, 0, limit);\n    end = _limitValue(end, 0, limit);\n\n    this._offsets = {start, end, factor: 1 / (start + 1 + end)};\n  }\n\n  /**\n\t * Generates a maximum of `capacity` timestamps between min and max, rounded to the\n\t * `minor` unit using the given scale time `options`.\n\t * Important: this method can return ticks outside the min and max range, it's the\n\t * responsibility of the calling code to clamp values if needed.\n\t * @protected\n\t */\n  _generate() {\n    const adapter = this._adapter;\n    const min = this.min;\n    const max = this.max;\n    const options = this.options;\n    const timeOpts = options.time;\n    // @ts-ignore\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));\n    const stepSize = valueOrDefault(options.ticks.stepSize, 1);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    // For 'week' unit, handle the first day of week option\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    // Align first ticks on unit\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    // Prevent browser from freezing in case user options request millions of milliseconds\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    const timestamps = options.ticks.source === 'data' && this.getDataTimestamps();\n    for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max || options.bounds === 'ticks' || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    // @ts-ignore\n    return Object.keys(ticks).sort(sorter).map(x => +x);\n  }\n\n  /**\n\t * @param {number} value\n\t * @return {string}\n\t */\n  getLabelForValue(value) {\n    const adapter = this._adapter;\n    const timeOpts = this.options.time;\n\n    if (timeOpts.tooltipFormat) {\n      return adapter.format(value, timeOpts.tooltipFormat);\n    }\n    return adapter.format(value, timeOpts.displayFormats.datetime);\n  }\n\n  /**\n\t * @param {number} value\n\t * @param {string|undefined} format\n\t * @return {string}\n\t */\n  format(value, format) {\n    const options = this.options;\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const fmt = format || formats[unit];\n    return this._adapter.format(value, fmt);\n  }\n\n  /**\n\t * Function to format an individual tick mark\n\t * @param {number} time\n\t * @param {number} index\n\t * @param {object[]} ticks\n\t * @param {string|undefined} [format]\n\t * @return {string}\n\t * @private\n\t */\n  _tickFormatFunction(time, index, ticks, format) {\n    const options = this.options;\n    const formatter = options.ticks.callback;\n\n    if (formatter) {\n      return call(formatter, [time, index, ticks], this);\n    }\n\n    const formats = options.time.displayFormats;\n    const unit = this._unit;\n    const majorUnit = this._majorUnit;\n    const minorFormat = unit && formats[unit];\n    const majorFormat = majorUnit && formats[majorUnit];\n    const tick = ticks[index];\n    const major = majorUnit && majorFormat && tick && tick.major;\n\n    return this._adapter.format(time, format || (major ? majorFormat : minorFormat));\n  }\n\n  /**\n\t * @param {object[]} ticks\n\t */\n  generateTickLabels(ticks) {\n    let i, ilen, tick;\n\n    for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n      tick = ticks[i];\n      tick.label = this._tickFormatFunction(tick.value, i, ticks);\n    }\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return value === null ? NaN : (value - this.min) / (this.max - this.min);\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getPixelForValue(value) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForValue(value);\n    return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return this.min + pos * (this.max - this.min);\n  }\n\n  /**\n\t * @param {string} label\n\t * @return {{w:number, h:number}}\n\t * @private\n\t */\n  _getLabelSize(label) {\n    const ticksOpts = this.options.ticks;\n    const tickLabelWidth = this.ctx.measureText(label).width;\n    const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);\n    const cosRotation = Math.cos(angle);\n    const sinRotation = Math.sin(angle);\n    const tickFontSize = this._resolveTickFontOptions(0).size;\n\n    return {\n      w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),\n      h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)\n    };\n  }\n\n  /**\n\t * @param {number} exampleTime\n\t * @return {number}\n\t * @private\n\t */\n  _getLabelCapacity(exampleTime) {\n    const timeOpts = this.options.time;\n    const displayFormats = timeOpts.displayFormats;\n\n    // pick the longest format (milliseconds) for guesstimation\n    const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;\n    const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [exampleTime], this._majorUnit), format);\n    const size = this._getLabelSize(exampleLabel);\n    // subtract 1 - if offset then there's one less label than tick\n    // if not offset then one half label padding is added to each end leaving room for one less label\n    const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;\n    return capacity > 0 ? capacity : 1;\n  }\n\n  /**\n\t * @protected\n\t */\n  getDataTimestamps() {\n    let timestamps = this._cache.data || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const metas = this.getMatchingVisibleMetas();\n\n    if (this._normalized && metas.length) {\n      return (this._cache.data = metas[0].controller.getAllParsedValues(this));\n    }\n\n    for (i = 0, ilen = metas.length; i < ilen; ++i) {\n      timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));\n    }\n\n    return (this._cache.data = this.normalize(timestamps));\n  }\n\n  /**\n\t * @protected\n\t */\n  getLabelTimestamps() {\n    const timestamps = this._cache.labels || [];\n    let i, ilen;\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const labels = this.getLabels();\n    for (i = 0, ilen = labels.length; i < ilen; ++i) {\n      timestamps.push(parse(this, labels[i]));\n    }\n\n    return (this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps));\n  }\n\n  /**\n\t * @param {number[]} values\n\t * @protected\n\t */\n  normalize(values) {\n    // It seems to be somewhat faster to do sorting first\n    return _arrayUnique(values.sort(sorter));\n  }\n}\n","import TimeScale from './scale.time.js';\nimport {_lookupByKey} from '../helpers/helpers.collection.js';\n\n/**\n * Linearly interpolates the given source `val` using the table. If value is out of bounds, values\n * at edges are used for the interpolation.\n * @param {object} table\n * @param {number} val\n * @param {boolean} [reverse] lookup time based on position instead of vice versa\n * @return {object}\n */\nfunction interpolate(table, val, reverse) {\n  let lo = 0;\n  let hi = table.length - 1;\n  let prevSource, nextSource, prevTarget, nextTarget;\n  if (reverse) {\n    if (val >= table[lo].pos && val <= table[hi].pos) {\n      ({lo, hi} = _lookupByKey(table, 'pos', val));\n    }\n    ({pos: prevSource, time: prevTarget} = table[lo]);\n    ({pos: nextSource, time: nextTarget} = table[hi]);\n  } else {\n    if (val >= table[lo].time && val <= table[hi].time) {\n      ({lo, hi} = _lookupByKey(table, 'time', val));\n    }\n    ({time: prevSource, pos: prevTarget} = table[lo]);\n    ({time: nextSource, pos: nextTarget} = table[hi]);\n  }\n\n  const span = nextSource - prevSource;\n  return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;\n}\n\nclass TimeSeriesScale extends TimeScale {\n\n  static id = 'timeseries';\n\n  /**\n   * @type {any}\n   */\n  static defaults = TimeScale.defaults;\n\n  /**\n\t * @param {object} props\n\t */\n  constructor(props) {\n    super(props);\n\n    /** @type {object[]} */\n    this._table = [];\n    /** @type {number} */\n    this._minPos = undefined;\n    /** @type {number} */\n    this._tableRange = undefined;\n  }\n\n  /**\n\t * @protected\n\t */\n  initOffsets() {\n    const timestamps = this._getTimestampsForTable();\n    const table = this._table = this.buildLookupTable(timestamps);\n    this._minPos = interpolate(table, this.min);\n    this._tableRange = interpolate(table, this.max) - this._minPos;\n    super.initOffsets(timestamps);\n  }\n\n  /**\n\t * Returns an array of {time, pos} objects used to interpolate a specific `time` or position\n\t * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is\n\t * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other\n\t * extremity (left + width or top + height). Note that it would be more optimized to directly\n\t * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need\n\t * to create the lookup table. The table ALWAYS contains at least two items: min and max.\n\t * @param {number[]} timestamps\n\t * @return {object[]}\n\t * @protected\n\t */\n  buildLookupTable(timestamps) {\n    const {min, max} = this;\n    const items = [];\n    const table = [];\n    let i, ilen, prev, curr, next;\n\n    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {\n      curr = timestamps[i];\n      if (curr >= min && curr <= max) {\n        items.push(curr);\n      }\n    }\n\n    if (items.length < 2) {\n      // In case there is less that 2 timestamps between min and max, the scale is defined by min and max\n      return [\n        {time: min, pos: 0},\n        {time: max, pos: 1}\n      ];\n    }\n\n    for (i = 0, ilen = items.length; i < ilen; ++i) {\n      next = items[i + 1];\n      prev = items[i - 1];\n      curr = items[i];\n\n      // only add points that breaks the scale linearity\n      if (Math.round((next + prev) / 2) !== curr) {\n        table.push({time: curr, pos: i / (ilen - 1)});\n      }\n    }\n    return table;\n  }\n\n  /**\n    * Generates all timestamps defined in the data.\n    * Important: this method can return ticks outside the min and max range, it's the\n    * responsibility of the calling code to clamp values if needed.\n    * @protected\n    */\n  _generate() {\n    const min = this.min;\n    const max = this.max;\n    let timestamps = super.getDataTimestamps();\n    if (!timestamps.includes(min) || !timestamps.length) {\n      timestamps.splice(0, 0, min);\n    }\n    if (!timestamps.includes(max) || timestamps.length === 1) {\n      timestamps.push(max);\n    }\n    return timestamps.sort((a, b) => a - b);\n  }\n\n  /**\n\t * Returns all timestamps\n\t * @return {number[]}\n\t * @private\n\t */\n  _getTimestampsForTable() {\n    let timestamps = this._cache.all || [];\n\n    if (timestamps.length) {\n      return timestamps;\n    }\n\n    const data = this.getDataTimestamps();\n    const label = this.getLabelTimestamps();\n    if (data.length && label.length) {\n      // If combining labels and data (data might not contain all labels),\n      // we need to recheck uniqueness and sort\n      timestamps = this.normalize(data.concat(label));\n    } else {\n      timestamps = data.length ? data : label;\n    }\n    timestamps = this._cache.all = timestamps;\n\n    return timestamps;\n  }\n\n  /**\n\t * @param {number} value - Milliseconds since epoch (1 January 1970 00:00:00 UTC)\n\t * @return {number}\n\t */\n  getDecimalForValue(value) {\n    return (interpolate(this._table, value) - this._minPos) / this._tableRange;\n  }\n\n  /**\n\t * @param {number} pixel\n\t * @return {number}\n\t */\n  getValueForPixel(pixel) {\n    const offsets = this._offsets;\n    const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;\n    return interpolate(this._table, decimal * this._tableRange + this._minPos, true);\n  }\n}\n\nexport default TimeSeriesScale;\n","import type { MouseEvent } from 'react';\nimport type {\n  ChartType,\n  ChartData,\n  DefaultDataPoint,\n  ChartDataset,\n  ChartOptions,\n  Chart,\n} from 'chart.js';\n\nimport type { ForwardedRef } from './types.js';\n\nconst defaultDatasetIdKey = 'label';\n\nexport function reforwardRef<T>(ref: ForwardedRef<T>, value: T) {\n  if (typeof ref === 'function') {\n    ref(value);\n  } else if (ref) {\n    ref.current = value;\n  }\n}\n\nexport function setOptions<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n>(chart: Chart<TType, TData, TLabel>, nextOptions: ChartOptions<TType>) {\n  const options = chart.options;\n\n  if (options && nextOptions) {\n    Object.assign(options, nextOptions);\n  }\n}\n\nexport function setLabels<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n>(\n  currentData: ChartData<TType, TData, TLabel>,\n  nextLabels: TLabel[] | undefined\n) {\n  currentData.labels = nextLabels;\n}\n\nexport function setDatasets<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n>(\n  currentData: ChartData<TType, TData, TLabel>,\n  nextDatasets: ChartDataset<TType, TData>[],\n  datasetIdKey = defaultDatasetIdKey\n) {\n  const addedDatasets: ChartDataset<TType, TData>[] = [];\n\n  currentData.datasets = nextDatasets.map(\n    (nextDataset: Record<string, unknown>) => {\n      // given the new set, find it's current match\n      const currentDataset = currentData.datasets.find(\n        (dataset: Record<string, unknown>) =>\n          dataset[datasetIdKey] === nextDataset[datasetIdKey]\n      );\n\n      // There is no original to update, so simply add new one\n      if (\n        !currentDataset ||\n        !nextDataset.data ||\n        addedDatasets.includes(currentDataset)\n      ) {\n        return { ...nextDataset } as ChartDataset<TType, TData>;\n      }\n\n      addedDatasets.push(currentDataset);\n\n      Object.assign(currentDataset, nextDataset);\n\n      return currentDataset;\n    }\n  );\n}\n\nexport function cloneData<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n>(data: ChartData<TType, TData, TLabel>, datasetIdKey = defaultDatasetIdKey) {\n  const nextData: ChartData<TType, TData, TLabel> = {\n    labels: [],\n    datasets: [],\n  };\n\n  setLabels(nextData, data.labels);\n  setDatasets(nextData, data.datasets, datasetIdKey);\n\n  return nextData;\n}\n\n/**\n * Get dataset from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */\nexport function getDatasetAtEvent(\n  chart: Chart,\n  event: MouseEvent<HTMLCanvasElement>\n) {\n  return chart.getElementsAtEventForMode(\n    event.nativeEvent,\n    'dataset',\n    { intersect: true },\n    false\n  );\n}\n\n/**\n * Get single dataset element from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */\nexport function getElementAtEvent(\n  chart: Chart,\n  event: MouseEvent<HTMLCanvasElement>\n) {\n  return chart.getElementsAtEventForMode(\n    event.nativeEvent,\n    'nearest',\n    { intersect: true },\n    false\n  );\n}\n\n/**\n * Get all dataset elements from mouse click event\n * @param chart - Chart.js instance\n * @param event - Mouse click event\n * @returns Dataset\n */\nexport function getElementsAtEvent(\n  chart: Chart,\n  event: MouseEvent<HTMLCanvasElement>\n) {\n  return chart.getElementsAtEventForMode(\n    event.nativeEvent,\n    'index',\n    { intersect: true },\n    false\n  );\n}\n","import React, { useEffect, useRef, forwardRef } from 'react';\nimport { Chart as ChartJS } from 'chart.js';\nimport type { ChartType, DefaultDataPoint } from 'chart.js';\n\nimport type { ForwardedRef, ChartProps, BaseChartComponent } from './types.js';\nimport {\n  reforwardRef,\n  cloneData,\n  setOptions,\n  setLabels,\n  setDatasets,\n} from './utils.js';\n\nfunction ChartComponent<\n  TType extends ChartType = ChartType,\n  TData = DefaultDataPoint<TType>,\n  TLabel = unknown\n>(\n  props: ChartProps<TType, TData, TLabel>,\n  ref: ForwardedRef<ChartJS<TType, TData, TLabel>>\n) {\n  const {\n    height = 150,\n    width = 300,\n    redraw = false,\n    datasetIdKey,\n    type,\n    data,\n    options,\n    plugins = [],\n    fallbackContent,\n    updateMode,\n    ...canvasProps\n  } = props as ChartProps;\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const chartRef = useRef<ChartJS | null>();\n\n  const renderChart = () => {\n    if (!canvasRef.current) return;\n\n    chartRef.current = new ChartJS(canvasRef.current, {\n      type,\n      data: cloneData(data, datasetIdKey),\n      options: options && { ...options },\n      plugins,\n    });\n\n    reforwardRef(ref, chartRef.current);\n  };\n\n  const destroyChart = () => {\n    reforwardRef(ref, null);\n\n    if (chartRef.current) {\n      chartRef.current.destroy();\n      chartRef.current = null;\n    }\n  };\n\n  useEffect(() => {\n    if (!redraw && chartRef.current && options) {\n      setOptions(chartRef.current, options);\n    }\n  }, [redraw, options]);\n\n  useEffect(() => {\n    if (!redraw && chartRef.current) {\n      setLabels(chartRef.current.config.data, data.labels);\n    }\n  }, [redraw, data.labels]);\n\n  useEffect(() => {\n    if (!redraw && chartRef.current && data.datasets) {\n      setDatasets(chartRef.current.config.data, data.datasets, datasetIdKey);\n    }\n  }, [redraw, data.datasets]);\n\n  useEffect(() => {\n    if (!chartRef.current) return;\n\n    if (redraw) {\n      destroyChart();\n      setTimeout(renderChart);\n    } else {\n      chartRef.current.update(updateMode);\n    }\n  }, [redraw, options, data.labels, data.datasets, updateMode]);\n\n  useEffect(() => {\n    if (!chartRef.current) return;\n\n    destroyChart();\n    setTimeout(renderChart);\n  }, [type]);\n\n  useEffect(() => {\n    renderChart();\n\n    return () => destroyChart();\n  }, []);\n\n  return (\n    <canvas\n      ref={canvasRef}\n      role='img'\n      height={height}\n      width={width}\n      {...canvasProps}\n    >\n      {fallbackContent}\n    </canvas>\n  );\n}\n\nexport const Chart = forwardRef(ChartComponent) as BaseChartComponent;\n","import React, { forwardRef } from 'react';\nimport {\n  Chart as ChartJS,\n  LineController,\n  BarController,\n  RadarController,\n  DoughnutController,\n  PolarAreaController,\n  BubbleController,\n  PieController,\n  ScatterController,\n} from 'chart.js';\nimport type { ChartType, ChartComponentLike } from 'chart.js';\n\nimport type {\n  ChartProps,\n  ChartJSOrUndefined,\n  TypedChartComponent,\n} from './types.js';\nimport { Chart } from './chart.js';\n\nfunction createTypedChart<T extends ChartType>(\n  type: T,\n  registerables: ChartComponentLike\n) {\n  ChartJS.register(registerables);\n\n  return forwardRef<ChartJSOrUndefined<T>, Omit<ChartProps<T>, 'type'>>(\n    (props, ref) => <Chart {...props} ref={ref} type={type} />\n  ) as TypedChartComponent<T>;\n}\n\nexport const Line = /* #__PURE__ */ createTypedChart('line', LineController);\n\nexport const Bar = /* #__PURE__ */ createTypedChart('bar', BarController);\n\nexport const Radar = /* #__PURE__ */ createTypedChart('radar', RadarController);\n\nexport const Doughnut = /* #__PURE__ */ createTypedChart(\n  'doughnut',\n  DoughnutController\n);\n\nexport const PolarArea = /* #__PURE__ */ createTypedChart(\n  'polarArea',\n  PolarAreaController\n);\n\nexport const Bubble = /* #__PURE__ */ createTypedChart(\n  'bubble',\n  BubbleController\n);\n\nexport const Pie = /* #__PURE__ */ createTypedChart('pie', PieController);\n\nexport const Scatter = /* #__PURE__ */ createTypedChart(\n  'scatter',\n  ScatterController\n);\n"],"names":["getCardContentUtilityClass","slot","generateUtilityClass","generateUtilityClasses","_excluded","CardContentRoot","styled","name","overridesResolver","props","styles","root","padding","paddingBottom","React","inProps","ref","useThemeProps","className","component","other","_objectWithoutPropertiesLoose","ownerState","_extends","classes","composeClasses","useUtilityClasses","_jsx","as","clsx","getCardUtilityClass","CardRoot","Paper","overflow","raised","elevation","undefined","DividerRoot","absolute","variant","light","orientation","vertical","flexItem","children","withChildren","withChildrenVertical","textAlign","textAlignRight","textAlignLeft","_ref","theme","margin","flexShrink","borderWidth","borderStyle","borderColor","vars","palette","divider","borderBottomWidth","position","bottom","left","width","concat","dividerChannel","alpha","marginLeft","spacing","marginRight","marginTop","marginBottom","height","borderRightWidth","alignSelf","_ref2","display","whiteSpace","border","content","_ref3","borderTop","_ref4","flexDirection","borderLeft","_ref5","DividerWrapper","wrapper","wrapperVertical","_ref6","paddingLeft","paddingRight","paddingTop","Divider","role","slots","getDividerUtilityClass","muiSkipListHighlight","getListItemAvatarUtilityClass","ListItemAvatarRoot","alignItems","alignItemsFlexStart","minWidth","context","ListContext","getListItemUtilityClass","getListItemSecondaryActionClassesUtilityClass","ListItemSecondaryActionRoot","disableGutters","right","top","transform","ListItemSecondaryAction","muiName","_excluded2","ListItemRoot","dense","gutters","disablePadding","button","hasSecondaryAction","secondaryAction","justifyContent","textDecoration","boxSizing","listItemButtonClasses","listItemClasses","focusVisible","backgroundColor","action","focus","selected","primary","mainChannel","selectedOpacity","main","focusOpacity","disabled","opacity","disabledOpacity","borderBottom","backgroundClip","transition","transitions","create","duration","shortest","hover","hoverOpacity","ListItemContainer","container","autoFocus","childrenProp","componentProp","components","componentsProps","ContainerComponent","ContainerProps","ContainerClassName","focusVisibleClassName","slotProps","childContext","listItemRef","useEnhancedEffect","current","toArray","length","isMuiElement","handleRef","useForkRef","Root","rootProps","componentProps","Component","ButtonBase","Provider","value","_jsxs","isHostComponent","pop","round","v","lim","l","h","Math","max","min","p2b","n2b","b2n","n2p","map$1","A","B","C","D","E","F","a","b","c","d","e","f","hex","h1","h2","eq","hexString","r","g","isShort","HUE_RE","hsl2rgbn","s","n","k","arguments","hsv2rgbn","hwb2rgbn","w","rgb","i","rgb2hsl","hueValue","calln","Array","isArray","map","hsl2rgb","hue","hueParse","str","m","exec","p1","p2","hwb2rgb","hsv2rgb","x","Z","Y","X","W","V","U","T","S","R","Q","P","O","N","M","L","K","G","H","I","J","names$1","OiceXe","antiquewEte","aqua","aquamarRe","azuY","beige","bisque","black","blanKedOmond","Xe","XeviTet","bPwn","burlywood","caMtXe","KartYuse","KocTate","cSO","cSnflowerXe","cSnsilk","crimson","cyan","xXe","xcyan","xgTMnPd","xWay","xgYF","xgYy","xkhaki","xmagFta","xTivegYF","xSange","xScEd","xYd","xsOmon","xsHgYF","xUXe","xUWay","xUgYy","xQe","xviTet","dAppRk","dApskyXe","dimWay","dimgYy","dodgerXe","fiYbrick","flSOwEte","foYstWAn","fuKsia","gaRsbSo","ghostwEte","gTd","gTMnPd","Way","gYF","gYFLw","gYy","honeyMw","hotpRk","RdianYd","Rdigo","ivSy","khaki","lavFMr","lavFMrXsh","lawngYF","NmoncEffon","ZXe","ZcSO","Zcyan","ZgTMnPdLw","ZWay","ZgYF","ZgYy","ZpRk","ZsOmon","ZsHgYF","ZskyXe","ZUWay","ZUgYy","ZstAlXe","ZLw","lime","limegYF","lRF","magFta","maPon","VaquamarRe","VXe","VScEd","VpurpN","VsHgYF","VUXe","VsprRggYF","VQe","VviTetYd","midnightXe","mRtcYam","mistyPse","moccasR","navajowEte","navy","Tdlace","Tive","TivedBb","Sange","SangeYd","ScEd","pOegTMnPd","pOegYF","pOeQe","pOeviTetYd","papayawEp","pHKpuff","peru","pRk","plum","powMrXe","purpN","YbeccapurpN","Yd","Psybrown","PyOXe","saddNbPwn","sOmon","sandybPwn","sHgYF","sHshell","siFna","silver","skyXe","UXe","UWay","UgYy","snow","sprRggYF","stAlXe","tan","teO","tEstN","tomato","Qe","viTet","JHt","wEte","wEtesmoke","Lw","LwgYF","names","nameParse","unpacked","keys","Object","tkeys","j","ok","nk","replace","parseInt","unpack","transparent","toLowerCase","RGB_RE","to","pow","from","modHSL","ratio","tmp","clone","proto","assign","fromObject","input","functionParse","charAt","rgbParse","Color","constructor","type","ret","len","hexParse","this","_rgb","_valid","valid","obj","rgbString","hslString","mix","color","weight","c1","c2","w2","p","w1","interpolate","t","rgb1","rgb2","clearer","greyscale","val","opaquer","negate","lighten","darken","saturate","desaturate","rotate","deg","noop","uid","id","isNullOrUndef","prototype","toString","call","slice","isObject","isNumberFinite","Number","isFinite","finiteOrDefault","defaultValue","valueOrDefault","toDimension","dimension","endsWith","parseFloat","callback","fn","args","thisArg","apply","each","loopable","reverse","_elementsEqual","a0","a1","ilen","v0","v1","datasetIndex","index","source","target","klen","isValidKey","key","indexOf","_merger","options","tval","sval","merge","sources","merger","mergeIf","_mergerIf","hasOwnProperty","keyResolvers","o","y","resolveObjectKey","resolver","parts","split","part","push","_splitKey","_getKeyResolver","_capitalize","toUpperCase","defined","isFunction","setsEqual","size","item","has","PI","TAU","PITAU","INFINITY","POSITIVE_INFINITY","RAD_PER_DEG","HALF_PI","QUARTER_PI","TWO_THIRDS_PI","log10","sign","almostEquals","epsilon","abs","niceNum","range","roundedRange","niceRange","floor","fraction","isNumber","isNaN","_setMinAndMaxByKey","array","property","toRadians","degrees","toDegrees","radians","_decimalPlaces","getAngleFromPoint","centrePoint","anglePoint","distanceFromXCenter","distanceFromYCenter","radialDistanceFromCenter","sqrt","angle","atan2","distance","distanceBetweenPoints","pt1","pt2","_angleDiff","_normalizeAngle","_angleBetween","start","end","sameAngleIsFullCircle","angleToStart","angleToEnd","startToAngle","endToAngle","_limitValue","_isBetween","_lookup","table","cmp","mid","hi","lo","_lookupByKey","last","ti","_rlookupByKey","arrayEvents","unlistenArrayEvents","listener","stub","_chartjs","listeners","splice","forEach","_arrayUnique","items","set","Set","requestAnimFrame","window","requestAnimationFrame","throttled","argsToUse","ticking","_len2","_key2","_toLeftRightCenter","align","_alignStartEnd","_getStartAndCountOfVisiblePoints","meta","points","animationsDisabled","pointCount","count","_sorted","iScale","_parsed","axis","minDefined","maxDefined","getUserBounds","getPixelForValue","_scaleRangesChanged","xScale","yScale","_scaleRanges","newRanges","xmin","xmax","ymin","ymax","changed","atEdge","elasticIn","sin","elasticOut","effects","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","cos","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInElastic","easeOutElastic","easeInOutElastic","easeInBack","easeOutBack","easeInOutBack","easeInBounce","easeOutBounce","easeInOutBounce","isPatternOrGradient","getHoverColor","numbers","colors","intlCache","Map","formatNumber","num","locale","cacheKey","JSON","stringify","formatter","get","Intl","NumberFormat","getNumberFormat","format","formatters","values","numeric","tickValue","ticks","chart","notation","delta","maxTick","calculateDelta","logDelta","numDecimal","minimumFractionDigits","maximumFractionDigits","logarithmic","remain","significand","includes","Ticks","overrides","descriptors","getScope$1","node","scope","Defaults","_descriptors","_appliers","animation","datasets","devicePixelRatio","platform","getDevicePixelRatio","elements","events","font","family","style","lineHeight","hoverBackgroundColor","ctx","hoverBorderColor","hoverColor","indexAxis","interaction","mode","intersect","includeInvisible","maintainAspectRatio","onHover","onClick","parsing","plugins","responsive","scale","scales","showLine","drawActiveElementsOnTop","describe","override","route","targetScope","targetName","scopeObject","targetScopeObject","privateName","defineProperties","writable","enumerable","local","appliers","defaults","_scriptable","startsWith","_indexable","_fallback","delay","easing","loop","properties","active","resize","show","animations","visible","hide","autoPadding","offset","beginAtZero","bounds","clip","grace","grid","lineWidth","drawOnChartArea","drawTicks","tickLength","tickWidth","_ctx","tickColor","dash","dashOffset","title","text","minRotation","maxRotation","mirror","textStrokeWidth","textStrokeColor","autoSkip","autoSkipPadding","labelOffset","minor","major","crossAlign","showLabelBackdrop","backdropColor","backdropPadding","_measureText","data","gc","longest","string","textWidth","measureText","_longestText","arrayOfThings","cache","garbageCollect","save","jlen","thing","nestedThing","restore","gcLen","_alignPixel","pixel","currentDevicePixelRatio","halfWidth","clearCanvas","canvas","getContext","resetTransform","clearRect","drawPoint","drawPointLegend","xOffset","yOffset","cornerRadius","xOffsetW","yOffsetW","pointStyle","rotation","radius","rad","translate","drawImage","beginPath","ellipse","arc","closePath","moveTo","lineTo","SQRT1_2","rect","fill","stroke","_isPointInArea","point","area","clipArea","unclipArea","_steppedLineTo","previous","flip","midpoint","_bezierCurveTo","bezierCurveTo","cp1x","cp2x","cp1y","cp2y","decorateText","line","opts","strikethrough","underline","metrics","actualBoundingBoxLeft","actualBoundingBoxRight","actualBoundingBoxAscent","actualBoundingBoxDescent","yDecoration","strokeStyle","fillStyle","decorationWidth","drawBackdrop","oldColor","fillRect","renderText","lines","strokeWidth","strokeColor","translation","textBaseline","setRenderOpts","backdrop","strokeText","maxWidth","fillText","addRoundedRectPath","topLeft","bottomLeft","bottomRight","topRight","LINE_HEIGHT","FONT_STYLE","toLineHeight","matches","match","numberOrZero","_readValueToProps","objProps","read","prop","toTRBL","toTRBLCorners","toPadding","toFont","fallback","console","warn","toFontString","resolve","inputs","info","cacheable","createContext","parentContext","_createResolver","scopes","prefixes","getTarget","finalRootScopes","_resolve","Symbol","toStringTag","_cacheable","_scopes","_rootScopes","_getTarget","Proxy","deleteProperty","_keys","_cached","proxy","prefix","readKey","needsSubResolver","createSubResolver","_resolveWithPrefixes","getOwnPropertyDescriptor","Reflect","getPrototypeOf","getKeysFromAllScopes","ownKeys","storage","_storage","_attachContext","subProxy","descriptorDefaults","_proxy","_context","_subProxy","_stack","setContext","receiver","isScriptable","getValue","Error","join","add","delete","_resolveScriptable","isIndexable","arr","filter","_resolveArray","_resolveWithContext","allKeys","configurable","scriptable","indexable","_allKeys","resolveFallback","getScope","parent","addScopes","parentScopes","parentFallback","rootScopes","allScopes","addScopesFromKey","subGetTarget","resolveKeysFromAllScopes","_parseObjectDataRadialScale","_parsing","parsed","parse","EPSILON","getPoint","skip","getValueAxis","splineCurve","firstPoint","middlePoint","afterPoint","next","d01","d12","s01","s12","fa","fb","splineCurveMonotone","valueAxis","pointsLen","deltaK","mK","pointBefore","pointCurrent","pointAfter","slopeDelta","alphaK","betaK","tauK","squaredMagnitude","monotoneAdjust","iPixel","vPixel","monotoneCompute","capControlPoint","pt","_updateBezierControlPoints","controlPoints","spanGaps","cubicInterpolationMode","prev","tension","capBezierPoints","inArea","inAreaPrev","inAreaNext","_isDomSupported","document","_getParentNode","domNode","parentNode","host","parseMaxStyle","styleValue","parentProperty","valueInPixels","getComputedStyle","element","ownerDocument","defaultView","positions","getPositionedStyle","suffix","result","pos","useOffsetPos","shadowRoot","getRelativePosition","event","borderBox","paddings","borders","box","touches","offsetX","offsetY","getBoundingClientRect","clientX","clientY","getCanvasPosition","round1","getMaximumSize","bbWidth","bbHeight","aspectRatio","margins","maxHeight","containerSize","containerStyle","containerBorder","containerPadding","clientWidth","clientHeight","getContainerSize","retinaScale","forceRatio","forceStyle","pixelRatio","deviceHeight","deviceWidth","setTransform","supportsEventListenerOptions","passiveSupported","passive","addEventListener","removeEventListener","readUsedSize","el","getPropertyValue","getStyle","_pointInLine","_steppedInterpolation","_bezierInterpolation","cp1","cp2","getRtlAdapter","rtl","rectX","setWidth","xPlus","leftForLtr","itemWidth","getRightToLeftAdapter","_itemWidth","overrideTextDirection","direction","original","getPropertyPriority","setProperty","prevTextDirection","restoreTextDirection","propertyFn","between","compare","normalize","normalizeSegment","_boundSegment","segment","startBound","endBound","getSegment","prevValue","inside","subStart","shouldStart","shouldStop","_boundSegments","segments","sub","splitByStyles","segmentOptions","chartContext","_chart","baseStyle","readStyle","_datasetIndex","prevStyle","addStyle","st","dir","p0","p0DataIndex","p1DataIndex","styleChanged","doSplitByStyles","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","replacer","Animator","_request","_charts","_running","_lastDate","_notify","anims","date","callbacks","numSteps","initial","currentStep","_refresh","_update","Date","now","remaining","running","draw","_active","_total","tick","_getAnims","charts","complete","progress","listen","cb","reduce","acc","cur","_duration","stop","cancel","remove","animator","interpolators","boolean","factor","c0","number","Animation","cfg","currentValue","_fn","_easing","_start","_loop","_target","_prop","_from","_to","_promises","update","elapsed","wait","promises","Promise","res","rej","resolved","method","Animations","config","_properties","configure","animationOptions","animatedProps","getOwnPropertyNames","option","_animateOptions","newOptions","$shared","$animations","resolveTargetOptions","_createAnimations","anim","all","awaitAll","then","scaleClip","allowedOverflow","getSortedDatasetIndices","filterVisible","metasets","_getSortedDatasetMetas","applyStack","stack","dsIndex","singleMode","otherValue","isStacked","stacked","getOrCreateStack","stacks","stackKey","indexValue","subStack","getLastIndexInStack","vScale","positive","getMatchingVisibleMetas","updateStacks","controller","_cachedMeta","_stacks","iAxis","vAxis","indexScale","valueScale","getStackKey","_top","_bottom","_visualValues","getFirstScaleId","shift","clearStacks","isDirectUpdateMode","cloneIfNotShared","cached","shared","DatasetController","_cachedDataOpts","getMeta","_type","_data","_objectData","_sharedOptions","_drawStart","_drawCount","enableOptionSharing","supportsDecimation","$context","_syncList","datasetElementType","dataElementType","initialize","linkScales","_stacked","addElements","isPluginEnabled","updateIndex","dataset","getDataset","chooseId","xid","xAxisID","yid","yAxisID","rid","rAxisID","iid","iAxisID","vid","vAxisID","getScaleForId","rScale","getDatasetMeta","scaleID","_getOtherScale","reset","_destroy","_dataCheck","adata","convertObjectDataToArray","isExtensible","defineProperty","base","_len","_key","object","buildOrUpdateElements","resetNewElements","stackChanged","oldStacked","_resyncElements","scopeKeys","datasetScopeKeys","getOptionScopes","createResolver","sorted","parseArrayData","parseObjectData","parsePrimitiveData","isNotInOrderComparedToPrev","labels","getLabels","singleScale","xAxisKey","yAxisKey","getParsed","getDataElement","updateRangeFromParsed","parsedValue","NaN","getMinMax","canStack","otherScale","createStack","hidden","NEGATIVE_INFINITY","otherMin","otherMax","_skip","getAllParsedValues","getMaxOverflow","getLabelAndValue","label","getLabelForValue","_clip","toClip","defaultClip","chartArea","resolveDatasetElementOptions","resolveDataElementOptions","dataIndex","raw","createDataContext","createDatasetContext","_resolveElementOptions","elementType","sharing","datasetElementScopeKeys","resolveNamedOptions","freeze","_resolveAnimations","datasetAnimationScopeKeys","getSharedOptions","includeOptions","sharedOptions","_animationsDisabled","_getSharedOptions","firstOpts","previouslySharedOptions","updateSharedOptions","updateElement","_setStyle","removeHoverStyle","setHoverStyle","_removeDatasetHoverStyle","_setDatasetHoverStyle","arg1","arg2","numMeta","numData","_insertElements","_removeElements","move","updateElements","removed","_sync","_dataChanges","_onDataPush","_onDataPop","_onDataShift","_onDataSplice","newCount","_onDataUnshift","computeMinSampleSize","_cache","$bar","visibleMetas","sort","getAllScaleValues","curr","_length","updateMinAndPrev","getPixelForTick","parseValue","entry","startValue","endValue","barStart","barEnd","_custom","parseFloatBar","parseArrayOrPrimitive","isFloatBar","custom","setBorderSkipped","edge","borderSkipped","horizontal","borderProps","enableBorderRadius","parseEdge","orig","v2","startEnd","setInflateAmount","inflateAmount","_defineProperty","BarController","iAxisKey","vAxisKey","super","bars","getBasePixel","isHorizontal","ruler","_getRuler","vpixels","head","_calculateBarValuePixels","ipixels","_calculateBarIndexPixels","center","_getStacks","grouped","skipNull","_getStackCount","_getStackIndex","pixels","barThickness","_startPixel","_endPixel","stackCount","categoryPercentage","barPercentage","baseValue","minBarLength","actualBase","floating","getDataVisibility","barSign","startPixel","getPixelForDecimal","endPixel","getValueForPixel","halfGrid","getLineWidthForValue","maxBarThickness","Infinity","percent","chunk","computeFlexCategoryTraits","thickness","computeFitCategoryTraits","stackIndex","rects","_index_","_value_","BubbleController","DoughnutController","innerRadius","outerRadius","getter","_getRotation","_getCircumference","circumference","_getRotationExtents","isDatasetVisible","arcs","getMaxBorderWidth","getMaxOffset","maxSize","cutout","toPercentage","chartWeight","_getRingWeight","ratioX","ratioY","startAngle","endAngle","startX","startY","endX","endY","calcMax","calcMin","maxX","maxY","minX","minY","getRatioAndOffset","maxRadius","radiusLength","_getVisibleDatasetWeightTotal","total","calculateTotal","_getRingWeightOffset","_circumference","animateRotate","calculateCircumference","animationOpts","centerX","centerY","animateScale","metaData","borderAlign","hoverBorderWidth","hoverOffset","ringWeightOffset","legend","generateLabels","fontColor","legendItem","toggleDataVisibility","LineController","_dataset","_decimated","animated","maxGapLength","directUpdate","pointsCount","prevParsed","nullData","lastPoint","updateControlPoints","PolarAreaController","bind","_updateRadius","minSize","cutoutPercentage","getVisibleDatasetCount","xCenter","yCenter","datasetStartAngle","getIndexAngle","defaultAngle","countVisibleElements","_computeAngle","getDistanceFromCenterForValue","angleLines","circular","pointLabels","PieController","RadarController","_fullLoop","pointPosition","getPointPositionForValue","ScatterController","registry","getElement","abstract","DateAdapterBase","members","init","formats","diff","startOf","endOf","adapters","binarySearch","metaset","lookupMethod","_reversePixels","getRange","evaluateInteractionItems","handler","getSortedVisibleDatasetMetas","getIntersectItems","useFinalPosition","isPointInArea","inRange","getNearestCartesianItems","distanceMetric","useX","useY","deltaX","deltaY","getDistanceMetricForAxis","minDistance","getCenterPoint","getNearestItems","getProps","getNearestRadialItems","getAxisItems","rangeMethod","intersectsItem","Interaction","modes","nearest","STATIC_POSITIONS","filterByPosition","filterDynamicPositionByAxis","sortByWeight","setLayoutDims","layouts","params","wrap","stackWeight","placed","buildStacks","vBoxMaxWidth","hBoxMaxHeight","layout","fullSize","availableWidth","availableHeight","getCombinedMax","maxPadding","updateMaxPadding","boxPadding","updateDims","getPadding","newWidth","outerWidth","newHeight","outerHeight","widthChanged","heightChanged","same","getMargins","marginForPositions","fitBoxes","boxes","refitBoxes","refit","setBoxDims","placeBoxes","userPadding","addBox","_layers","z","removeBox","layoutItem","minPadding","layoutBoxes","wrapBoxes","centerHorizontal","centerVertical","leftAndTop","rightAndBottom","buildLayoutBoxes","verticalBoxes","horizontalBoxes","beforeLayout","visibleVerticalBoxCount","updatePos","change","handleMaxPadding","BasePlatform","acquireContext","releaseContext","isAttached","updateConfig","BasicPlatform","EXPANDO_KEY","EVENT_TYPES","touchstart","touchmove","touchend","pointerenter","pointerdown","pointermove","pointerup","pointerleave","pointerout","isNullOrEmpty","eventListenerOptions","removeListener","nodeListContains","nodeList","contains","createAttachObserver","observer","MutationObserver","entries","trigger","addedNodes","removedNodes","observe","childList","subtree","createDetachObserver","drpListeningCharts","oldDevicePixelRatio","onWindowResize","dpr","createResizeObserver","ResizeObserver","contentRect","listenDevicePixelRatioChanges","releaseObserver","disconnect","unlistenDevicePixelRatioChanges","createProxyAndListen","native","fromNativeEvent","addListener","DomPlatform","renderHeight","getAttribute","renderWidth","displayWidth","displayHeight","initCanvas","removeAttribute","setAttribute","proxies","$proxies","attach","detach","isConnected","Element","tooltipPosition","hasValue","final","tickOpts","determinedMaxTicks","_tickSize","maxScale","maxChart","_maxLength","determineMaxTicks","ticksLimit","maxTicksLimit","majorIndices","enabled","getMajorIndices","numMajorIndices","first","newTicks","ceil","skipMajors","evenMajorSpacing","getEvenSpacing","factors","_factorize","calculateSpacing","avgMajorSpacing","majorStart","majorEnd","offsetFromEdge","getTicksLimit","ticksLength","sample","numItems","increment","getPixelForGridLine","offsetGridLines","validIndex","lineValue","getTickMarkLength","getTitleHeight","titleAlign","reverseAlign","Scale","_margins","labelRotation","_range","_gridLineItems","_labelItems","_labelSizes","_longestTextCache","_userMax","_userMin","_suggestedMax","_suggestedMin","_ticksLength","_borderValue","_dataLimitsCached","suggestedMin","suggestedMax","metas","getTicks","xLabels","yLabels","getLabelItems","_computeLabelItems","beforeUpdate","sampleSize","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","minmax","keepZero","_addGrace","beforeBuildTicks","buildTicks","afterBuildTicks","samplingEnabled","_convertTicksToLabels","beforeCalculateLabelRotation","calculateLabelRotation","afterCalculateLabelRotation","afterAutoSkip","beforeFit","fit","afterFit","afterUpdate","reversePixels","_alignToPixels","alignToPixels","_callHooks","notifyPlugins","beforeTickToLabelConversion","generateTickLabels","afterTickToLabelConversion","numTicks","maxLabelDiagonal","_isVisible","labelSizes","_getLabelSizes","maxLabelWidth","widest","maxLabelHeight","highest","asin","titleOpts","gridOpts","titleHeight","tickPadding","angleRadians","labelHeight","labelWidth","_calculatePadding","_handleMargins","isRotated","labelsBelowTicks","offsetLeft","offsetRight","isFullSize","_computeLabelSizes","caches","widths","heights","tickFont","fontString","nestedLabel","widestLabelSize","highestLabelSize","_resolveTickFontOptions","valueAt","idx","decimal","getDecimalForPixel","getBaseValue","createTickContext","optionTicks","rot","_computeGridLineItems","tl","borderOpts","axisWidth","axisHalfWidth","alignBorderValue","borderValue","alignedLineValue","tx1","ty1","tx2","ty2","x1","y1","x2","y2","positionAxisID","limit","step","optsAtIndex","optsAtIndexBorder","lineColor","tickBorderDash","tickBorderDashOffset","tickAndPadding","hTickAndPadding","lineCount","textOffset","_getXAxisLabelAlignment","_getYAxisLabelAlignment","halfCount","tickTextAlign","labelPadding","_computeLabelArea","drawBackground","findIndex","drawGrid","drawLine","setLineDash","lineDashOffset","drawBorder","lastLineWidth","drawLabels","renderTextOptions","drawTitle","titleX","titleY","titleArgs","tz","gz","bz","axisID","_maxDigits","fontSize","TypedRegistry","isForType","isPrototypeOf","register","parentScope","isIChartComponent","itemDefaults","defaultRoutes","routes","propertyParts","sourceName","sourceScope","routeDefaults","registerDefaults","unregister","Registry","controllers","_typedRegistries","_each","addControllers","_len3","_key3","_len4","_key4","addPlugins","_len5","_key5","addScales","_len6","_key6","getController","_get","getPlugin","getScale","removeControllers","_len7","_key7","removeElements","_len8","_key8","removePlugins","_len9","_key9","removeScales","_len10","_key10","typedRegistry","arg","reg","_getRegistryForType","_exec","itemReg","camelMethod","PluginService","_init","notify","hook","_createDescriptors","descriptor","plugin","cancelable","invalidate","_oldCache","_notifyStateChanges","localIds","allPlugins","getOpts","pluginOpts","createDescriptors","previousDescriptors","some","pluginScopeKeys","getIndexAxis","datasetDefaults","idMatchesAxis","determineAxis","_len11","scaleOptions","_key11","getAxisFromDataset","mergeScaleConfig","chartDefaults","configScales","chartIndexAxis","scaleConf","error","boundDs","retrieveAxisFromDatasets","defaultId","getDefaultScaleIDFromAxis","defaultScaleOptions","defaultID","getAxisFromDefaultScaleID","initOptions","initData","keyCache","keysCached","cachedKeys","generate","addIfFound","Config","_config","initConfig","_scopeCache","_resolverCache","clearCache","clear","datasetType","additionalOptionScopes","_cachedScopes","mainScope","resetCache","keyLists","chartOptionScopes","subPrefixes","getResolver","hasFunction","needContext","resolverCache","KNOWN_POSITIONS","positionIsHorizontal","compare2Level","l1","l2","onAnimationsComplete","onComplete","onAnimationProgress","onProgress","getCanvas","getElementById","instances","getChart","moveNumericKeys","intKey","getSizeForArea","field","Chart","invalidatePlugins","userConfig","initialCanvas","existingChart","OffscreenCanvas","_detectPlatform","_options","_aspectRatio","_metasets","_lastEvent","_listeners","_responsiveListeners","_sortedMetasets","_plugins","_hiddenIndices","attached","_doResize","timeout","clearTimeout","setTimeout","debounce","resizeDelay","_initialize","bindEvents","_resizeBeforeDraw","_resize","newSize","newRatio","onResize","render","ensureScalesHaveIDs","axisOptions","buildOrUpdateScales","scaleOpts","updated","isRadial","dposition","dtype","scaleType","hasUpdated","_updateMetasets","_destroyDatasetMeta","_removeUnreferencedMetasets","buildOrUpdateControllers","newControllers","order","ControllerClass","_resetElements","animsDisabled","_updateScales","_checkEventBindings","_updateHiddenIndices","_minPadding","_updateLayout","_updateDatasets","_eventHandler","_updateHoverStyles","existingEvents","newEvents","unbindEvents","changes","_getUniformDataChanges","datasetCount","makeSet","changeSet","noArea","_idx","_updateDataset","layers","_drawDatasets","_drawDataset","useClip","getDatasetArea","getElementsAtEventForMode","setDatasetVisibility","_updateVisibility","_stop","destroy","toBase64Image","toDataURL","bindUserEvents","bindResponsiveEvents","_add","_remove","detached","updateHoverStyle","getActiveElements","setActiveElements","activeElements","lastActive","pluginId","replay","hoverOptions","deactivated","activated","inChartArea","eventFilter","_handleEvent","_getActiveElements","isClick","_isClickEvent","lastEvent","determineLastEvent","parseBorderRadius$1","angleDelta","borderRadius","halfThickness","innerLimit","computeOuterLimit","outerArcLimit","outerStart","outerEnd","innerStart","innerEnd","rThetaToXY","theta","pathArc","pixelMargin","innerR","spacingOffset","avNogSpacingRadius","angleOffset","outerStartAdjustedRadius","outerEndAdjustedRadius","outerStartAdjustedAngle","outerEndAdjustedAngle","innerStartAdjustedRadius","innerEndAdjustedRadius","innerStartAdjustedAngle","innerEndAdjustedAngle","outerMidAdjustedAngle","pCenter","p4","innerMidAdjustedAngle","p8","outerStartX","outerStartY","outerEndX","outerEndY","fullCircles","inner","lineJoin","angleMargin","clipArc","ArcElement","chartX","chartY","rAdjust","betweenAngles","withinRadius","halfAngle","halfRadius","radiusOffset","drawArc","setStyle","lineCap","pathVars","paramsStart","paramsEnd","segmentStart","segmentEnd","outside","pathSegment","lineMethod","stepped","getLineMethod","fastPathSegment","prevX","lastY","avgX","countX","pointIndex","drawX","truncX","_getSegmentMethod","usePath2D","Path2D","path","_path","strokePathWithCache","segmentMethod","strokePathDirect","LineElement","_points","_segments","_pointsUpdated","findStartAndEnd","solidSegments","_computeSegments","_interpolate","_getInterpolationMethod","interpolated","inRange$1","hitRadius","PointElement","mouseX","mouseY","inXRange","inYRange","hoverRadius","getBarBounds","bar","half","skipOrLimit","boundingRects","maxW","maxH","parseBorderWidth","maxR","enableBorder","parseBorderRadius","outer","skipX","skipY","addNormalRectPath","inflateRect","amount","refRect","BarElement","addRectPath","getBoxSize","labelOpts","boxHeight","boxWidth","usePointStyle","pointStyleWidth","itemHeight","Legend","_added","legendHitBoxes","_hoveredItem","doughnutMode","legendItems","columnSizes","lineWidths","buildLabels","labelFont","_computeTitleHeight","_fitRows","_fitCols","hitboxes","totalHeight","row","_itemHeight","heightLimit","totalWidth","currentColWidth","currentColHeight","col","legendItemText","calculateItemWidth","fontLineHeight","calculateLegendItemHeight","calculateItemHeight","calculateItemSize","adjustHitBoxes","rtlHelper","hitbox","_draw","defaultColor","halfFontSize","cursor","textDirection","lineDash","drawOptions","SQRT2","yBoxTop","xBoxLeft","drawLegendBox","_textX","titleFont","titlePadding","topPaddingPlusHalfFontSize","_getLegendItemAt","hitBox","lh","handleEvent","onLeave","isListened","hoveredItem","sameItem","itemsEqual","plugin_legend","_element","_args","afterEvent","ci","useBorderRadius","Title","_padding","textSize","_drawArgs","fontOpts","plugin_title","titleBlock","createTitle","WeakMap","positioners","average","eventPosition","nearestElement","tp","pushOrConcat","toPush","splitNewlines","String","createTooltipItem","formattedValue","getTooltipSize","tooltip","body","footer","bodyFont","footerFont","titleLineCount","footerLineCount","bodyLineItemCount","combinedBodyLength","bodyItem","before","after","beforeBody","afterBody","titleSpacing","titleMarginBottom","displayColors","bodySpacing","footerMarginTop","footerSpacing","widthPadding","maxLineWidth","determineXAlign","yAlign","chartWidth","xAlign","caret","caretSize","caretPadding","doesNotFitWithAlign","determineAlignment","determineYAlign","getBackgroundPoint","alignment","paddingAndSize","alignX","alignY","getAlignedX","getBeforeAfterBodyLines","overrideCallbacks","defaultCallbacks","beforeTitle","tooltipItems","labelCount","afterTitle","beforeLabel","tooltipItem","labelColor","labelTextColor","bodyColor","labelPointStyle","afterLabel","beforeFooter","afterFooter","invokeCallbackWithFallback","Tooltip","_eventPosition","_size","_cachedAnimations","_tooltipItems","dataPoints","caretX","caretY","labelColors","labelPointStyles","labelTextColors","getTitle","getBeforeBody","getBody","bodyItems","scoped","getAfterBody","getFooter","_createItems","itemSort","positionAndSize","backgroundPoint","external","drawCaret","tooltipPoint","caretPosition","getCaretPosition","x3","y3","ptX","ptY","titleColor","_drawColorBox","colorX","rtlColorX","yOffSet","colorY","multiKeyBackground","outerX","innerX","strokeRect","drawBody","bodyAlign","bodyLineHeight","xLinePadding","fillLineOfText","bodyAlignForCalculation","textColor","drawFooter","footerAlign","footerColor","tooltipSize","quadraticCurveTo","_updateAnimationTarget","animX","animY","_willRender","hasTooltipContent","globalAlpha","positionChanged","_positionChanged","_ignoreReplayEvents","plugin_tooltip","afterInit","afterDraw","findOrAddLabel","addedLabels","addIfString","unshift","lastIndexOf","_getLabelForValue","CategoryScale","_startValue","_valueRange","_addedLabels","added","generateTicks$1","generationOptions","dataRange","precision","maxTicks","maxDigits","includeBounds","unit","maxSpaces","rmin","rmax","countDefined","minSpacing","niceMin","niceMax","numSpaces","rounded","almostWhole","decimalPlaces","relativeLabelSize","_ref7","LinearScaleBase","_endValue","handleTickRangeOptions","setMin","setMax","minSign","maxSign","getTickLimit","stepSize","computeTickLimit","LinearScale","log10Floor","changeExponent","isMajor","tickVal","steps","rangeExp","rangeStep","generateTicks","_ref8","minExp","exp","startExp","lastTick","LogarithmicScale","_zero","getTickBackdropHeight","determineLimits","fitWithPointLabels","limits","valueCount","_pointLabels","pointLabelOpts","additionalAngle","centerPointLabels","getPointLabelContext","getPointPosition","drawingArea","plFont","updateLimits","setCenterPoint","_pointLabelItems","itemOpts","extra","createPointLabelItem","isNotOverlapped","buildPointLabelItems","hLimits","vLimits","outerDistance","pointLabelPosition","yForAngle","getTextAlignForAngle","leftForTextAlign","drawPointLabelBox","backdropLeft","backdropTop","backdropWidth","backdropHeight","pathRadiusLine","RadialLinearScale","leftMovement","rightMovement","topMovement","bottomMovement","scalingFactor","getValueForDistanceFromCenter","scaledDistance","pointLabel","createPointLabelContext","distanceFromCenter","getBasePosition","getPointLabelPosition","drawPointLabels","gridLineOpts","drawRadiusLine","animate","INTERVALS","millisecond","common","second","minute","hour","day","week","month","quarter","year","UNITS","sorter","adapter","_adapter","parser","isoWeekday","_parseOpts","determineUnitForAutoTicks","minUnit","capacity","interval","MAX_SAFE_INTEGER","addTick","time","timestamps","ticksFromTimestamps","majorUnit","setMajorTicks","TimeScale","_unit","_majorUnit","_offsets","_normalized","displayFormats","normalized","_applyBounds","_getLabelBounds","getLabelTimestamps","timeOpts","_generate","_filterBetween","_getLabelCapacity","determineUnitForFormatting","determineMajorUnit","initOffsets","offsetAfterAutoskip","getDecimalForValue","weekday","hasWeekday","getDataTimestamps","tooltipFormat","datetime","fmt","_tickFormatFunction","minorFormat","majorFormat","offsets","_getLabelSize","ticksOpts","tickLabelWidth","cosRotation","sinRotation","tickFontSize","exampleTime","exampleLabel","prevSource","nextSource","prevTarget","nextTarget","span","TimeSeriesScale","_table","_minPos","_tableRange","_getTimestampsForTable","buildLookupTable","defaultDatasetIdKey","reforwardRef","setLabels","currentData","nextLabels","setDatasets","nextDatasets","datasetIdKey","addedDatasets","nextDataset","currentDataset","find","cloneData","nextData","ChartComponent","redraw","fallbackContent","updateMode","canvasProps","canvasRef","useRef","chartRef","renderChart","Chart$1","destroyChart","useEffect","nextOptions","setOptions","forwardRef","createTypedChart","registerables","Bar"],"sourceRoot":""}